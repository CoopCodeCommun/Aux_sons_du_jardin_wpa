function _mergeNamespaces(n2, m) {
  for (var i2 = 0; i2 < m.length; i2++) {
    const e2 = m[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n2)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$1(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = flushIndex) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b) => getId(a2) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b) => {
  const diff = getId(a2) - getId(b);
  if (diff === 0) {
    if (a2.pre && !b.pre)
      return -1;
    if (b.pre && !a2.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => a2.trim());
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs: attrs2, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs2;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs2;
        },
        slots,
        emit
      } : { attrs: attrs2, slots, emit }) : render2(props, null));
      fallthroughAttrs = Component.props ? attrs2 : getFunctionalFallthrough(attrs2);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs2) => {
  let res;
  for (const key in attrs2) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs2[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs2, props) => {
  const res = {};
  for (const key in attrs2) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs2[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions$1(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions$1(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs2 = {};
  def(attrs2, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs2);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs2;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs2;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs: attrs2, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs2, key)) {
            if (value !== attrs2[key]) {
              attrs2[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs2[key]) {
            attrs2[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs2)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs2 !== rawCurrentProps) {
      for (const key in attrs2) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs2[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs2) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs2) || value !== attrs2[key]) {
          attrs2[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b) {
  return getType(a2) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style2)) {
      if (isProxy(style2) && !isArray$1(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$1(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs2;
  {
    return {
      get attrs() {
        return attrs2 || (attrs2 = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.2.38";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$1(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
/* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
/*!
  * vue-router v4.1.5
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b.params) && stringifyQuery2(a2.query) === stringifyQuery2(b.query) && a2.hash === b.hash;
}
function isSameRouteRecord(a2, b) {
  return (a2.aliasOf || a2) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a2, b) {
  if (Object.keys(a2).length !== Object.keys(b).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b) {
  return isArray(a2) ? isEquivalentArray(a2, b) : isArray(b) ? isEquivalentArray(b, a2) : a2 === b;
}
function isEquivalentArray(a2, b) {
  return isArray(b) ? a2.length === b.length && a2.every((value, i2) => value === b[i2]) : a2.length === 1 && a2[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign(
      {},
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value = match[i2] || "";
      const key = keys[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
function compareScoreArray(a2, b) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b.length) {
    const diff = b[i2] - a2[i2];
    if (diff)
      return diff;
    i2++;
  }
  if (a2.length < b.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(
        paramsFromLocation(
          currentLocation.params,
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i2 = handlers.indexOf(handler);
      if (i2 > -1)
        handlers.splice(i2, 1);
    };
  }
  function reset2() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router2.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs: attrs2, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs2, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        params: "path" in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        true,
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(
            assign({
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
              force
            }),
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list())
      guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(
            error.to,
            toLocation
          ).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && !isNavigationFailure(failure, 8)) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router3 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router3;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app2.provide(routerKey, router3);
      app2.provide(routeLocationKey, reactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router2;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from.matched[i2];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i2];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
var Html5QrcodeSupportedFormats;
(function(Html5QrcodeSupportedFormats2) {
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["QR_CODE"] = 0] = "QR_CODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["AZTEC"] = 1] = "AZTEC";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODABAR"] = 2] = "CODABAR";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_39"] = 3] = "CODE_39";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_93"] = 4] = "CODE_93";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_128"] = 5] = "CODE_128";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["DATA_MATRIX"] = 6] = "DATA_MATRIX";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["MAXICODE"] = 7] = "MAXICODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["ITF"] = 8] = "ITF";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_13"] = 9] = "EAN_13";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_8"] = 10] = "EAN_8";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["PDF_417"] = 11] = "PDF_417";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_14"] = 12] = "RSS_14";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_A"] = 14] = "UPC_A";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_E"] = 15] = "UPC_E";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));
var html5QrcodeSupportedFormatsTextMap = /* @__PURE__ */ new Map([
  [Html5QrcodeSupportedFormats.QR_CODE, "QR_CODE"],
  [Html5QrcodeSupportedFormats.AZTEC, "AZTEC"],
  [Html5QrcodeSupportedFormats.CODABAR, "CODABAR"],
  [Html5QrcodeSupportedFormats.CODE_39, "CODE_39"],
  [Html5QrcodeSupportedFormats.CODE_93, "CODE_93"],
  [Html5QrcodeSupportedFormats.CODE_128, "CODE_128"],
  [Html5QrcodeSupportedFormats.DATA_MATRIX, "DATA_MATRIX"],
  [Html5QrcodeSupportedFormats.MAXICODE, "MAXICODE"],
  [Html5QrcodeSupportedFormats.ITF, "ITF"],
  [Html5QrcodeSupportedFormats.EAN_13, "EAN_13"],
  [Html5QrcodeSupportedFormats.EAN_8, "EAN_8"],
  [Html5QrcodeSupportedFormats.PDF_417, "PDF_417"],
  [Html5QrcodeSupportedFormats.RSS_14, "RSS_14"],
  [Html5QrcodeSupportedFormats.RSS_EXPANDED, "RSS_EXPANDED"],
  [Html5QrcodeSupportedFormats.UPC_A, "UPC_A"],
  [Html5QrcodeSupportedFormats.UPC_E, "UPC_E"],
  [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, "UPC_EAN_EXTENSION"]
]);
var DecodedTextType;
(function(DecodedTextType2) {
  DecodedTextType2[DecodedTextType2["UNKNOWN"] = 0] = "UNKNOWN";
  DecodedTextType2[DecodedTextType2["URL"] = 1] = "URL";
})(DecodedTextType || (DecodedTextType = {}));
function isValidHtml5QrcodeSupportedFormats(format) {
  return Object.values(Html5QrcodeSupportedFormats).includes(format);
}
var Html5QrcodeScanType;
(function(Html5QrcodeScanType2) {
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_CAMERA"] = 0] = "SCAN_TYPE_CAMERA";
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_FILE"] = 1] = "SCAN_TYPE_FILE";
})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));
var Html5QrcodeConstants = function() {
  function Html5QrcodeConstants2() {
  }
  Html5QrcodeConstants2.GITHUB_PROJECT_URL = "https://github.com/mebjas/html5-qrcode";
  Html5QrcodeConstants2.SCAN_DEFAULT_FPS = 2;
  Html5QrcodeConstants2.DEFAULT_DISABLE_FLIP = false;
  Html5QrcodeConstants2.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;
  Html5QrcodeConstants2.DEFAULT_SUPPORTED_SCAN_TYPE = [
    Html5QrcodeScanType.SCAN_TYPE_CAMERA,
    Html5QrcodeScanType.SCAN_TYPE_FILE
  ];
  return Html5QrcodeConstants2;
}();
var QrcodeResultFormat = function() {
  function QrcodeResultFormat2(format, formatName) {
    this.format = format;
    this.formatName = formatName;
  }
  QrcodeResultFormat2.prototype.toString = function() {
    return this.formatName;
  };
  QrcodeResultFormat2.create = function(format) {
    if (!html5QrcodeSupportedFormatsTextMap.has(format)) {
      throw format + " not in html5QrcodeSupportedFormatsTextMap";
    }
    return new QrcodeResultFormat2(format, html5QrcodeSupportedFormatsTextMap.get(format));
  };
  return QrcodeResultFormat2;
}();
var Html5QrcodeResultFactory = function() {
  function Html5QrcodeResultFactory2() {
  }
  Html5QrcodeResultFactory2.createFromText = function(decodedText) {
    var qrcodeResult = {
      text: decodedText
    };
    return {
      decodedText,
      result: qrcodeResult
    };
  };
  Html5QrcodeResultFactory2.createFromQrcodeResult = function(qrcodeResult) {
    return {
      decodedText: qrcodeResult.text,
      result: qrcodeResult
    };
  };
  return Html5QrcodeResultFactory2;
}();
var Html5QrcodeErrorTypes;
(function(Html5QrcodeErrorTypes2) {
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["UNKWOWN_ERROR"] = 0] = "UNKWOWN_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["IMPLEMENTATION_ERROR"] = 1] = "IMPLEMENTATION_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["NO_CODE_FOUND_ERROR"] = 2] = "NO_CODE_FOUND_ERROR";
})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));
var Html5QrcodeErrorFactory = function() {
  function Html5QrcodeErrorFactory2() {
  }
  Html5QrcodeErrorFactory2.createFrom = function(error) {
    return {
      errorMessage: error,
      type: Html5QrcodeErrorTypes.UNKWOWN_ERROR
    };
  };
  return Html5QrcodeErrorFactory2;
}();
var BaseLoggger = function() {
  function BaseLoggger2(verbose) {
    this.verbose = verbose;
  }
  BaseLoggger2.prototype.log = function(message) {
    if (this.verbose) {
      console.log(message);
    }
  };
  BaseLoggger2.prototype.warn = function(message) {
    if (this.verbose) {
      console.warn(message);
    }
  };
  BaseLoggger2.prototype.logError = function(message, isExperimental) {
    if (this.verbose || isExperimental === true) {
      console.error(message);
    }
  };
  BaseLoggger2.prototype.logErrors = function(errors) {
    if (errors.length === 0) {
      throw "Logger#logError called without arguments";
    }
    if (this.verbose) {
      console.error(errors);
    }
  };
  return BaseLoggger2;
}();
function isNullOrUndefined(obj) {
  return typeof obj === "undefined" || obj === null;
}
var Html5QrcodeStrings = function() {
  function Html5QrcodeStrings2() {
  }
  Html5QrcodeStrings2.codeParseError = function(exception) {
    return "QR code parse error, error = " + exception;
  };
  Html5QrcodeStrings2.errorGettingUserMedia = function(error) {
    return "Error getting userMedia, error = " + error;
  };
  Html5QrcodeStrings2.onlyDeviceSupportedError = function() {
    return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string).";
  };
  Html5QrcodeStrings2.cameraStreamingNotSupported = function() {
    return "Camera streaming not supported by the browser.";
  };
  Html5QrcodeStrings2.unableToQuerySupportedDevices = function() {
    return "Unable to query supported devices, unknown error.";
  };
  Html5QrcodeStrings2.insecureContextCameraQueryError = function() {
    return "Camera access is only supported in secure context like https or localhost.";
  };
  return Html5QrcodeStrings2;
}();
var VideoConstraintsUtil = function() {
  function VideoConstraintsUtil2() {
  }
  VideoConstraintsUtil2.isMediaStreamConstraintsValid = function(videoConstraints, logger) {
    if (typeof videoConstraints !== "object") {
      var typeofVideoConstraints = typeof videoConstraints;
      logger.logError("videoConstraints should be of type object, the " + ("object passed is of type " + typeofVideoConstraints + "."), true);
      return false;
    }
    var bannedKeys = [
      "autoGainControl",
      "channelCount",
      "echoCancellation",
      "latency",
      "noiseSuppression",
      "sampleRate",
      "sampleSize",
      "volume"
    ];
    var bannedkeysSet = new Set(bannedKeys);
    var keysInVideoConstraints = Object.keys(videoConstraints);
    for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {
      var key = keysInVideoConstraints_1[_i];
      if (bannedkeysSet.has(key)) {
        logger.logError(key + " is not supported videoConstaints.", true);
        return false;
      }
    }
    return true;
  };
  return VideoConstraintsUtil2;
}();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var zxingJs_umd$1 = { exports: {} };
(function(module2, exports2) {
  (function(global2, factory) {
    factory(exports2);
  })(commonjsGlobal, function(exports3) {
    /*! *****************************************************************************
    	    Copyright (c) Microsoft Corporation. All rights reserved.
    	    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    	    this file except in compliance with the License. You may obtain a copy of the
    	    License at http://www.apache.org/licenses/LICENSE-2.0
    
    	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    	    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    	    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    	    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    	    See the Apache Version 2.0 License for specific language governing permissions
    	    and limitations under the License.
    	    ***************************************************************************** */
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p2 in b)
        if (b.hasOwnProperty(p2))
          d[p2] = b[p2];
    };
    function __extends2(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function fixProto(target, prototype) {
      var setPrototypeOf = Object.setPrototypeOf;
      setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
    }
    function fixStack(target, fn) {
      if (fn === void 0) {
        fn = target.constructor;
      }
      var captureStackTrace = Error.captureStackTrace;
      captureStackTrace && captureStackTrace(target, fn);
    }
    var CustomError = function(_super) {
      __extends2(CustomError2, _super);
      function CustomError2(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
    class Exception extends CustomError {
      constructor(message = void 0) {
        super(message);
        this.message = message;
      }
      getKind() {
        const ex = this.constructor;
        return ex.kind;
      }
    }
    Exception.kind = "Exception";
    class ArgumentException extends Exception {
    }
    ArgumentException.kind = "ArgumentException";
    class IllegalArgumentException extends Exception {
    }
    IllegalArgumentException.kind = "IllegalArgumentException";
    class BinaryBitmap {
      constructor(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
          throw new IllegalArgumentException("Binarizer must be non-null.");
        }
      }
      getWidth() {
        return this.binarizer.getWidth();
      }
      getHeight() {
        return this.binarizer.getHeight();
      }
      getBlackRow(y, row) {
        return this.binarizer.getBlackRow(y, row);
      }
      getBlackMatrix() {
        if (this.matrix === null || this.matrix === void 0) {
          this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
      }
      isCropSupported() {
        return this.binarizer.getLuminanceSource().isCropSupported();
      }
      crop(left, top, width, height) {
        const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      isRotateSupported() {
        return this.binarizer.getLuminanceSource().isRotateSupported();
      }
      rotateCounterClockwise() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      rotateCounterClockwise45() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      toString() {
        try {
          return this.getBlackMatrix().toString();
        } catch (e2) {
          return "";
        }
      }
    }
    class ChecksumException extends Exception {
      static getChecksumInstance() {
        return new ChecksumException();
      }
    }
    ChecksumException.kind = "ChecksumException";
    class Binarizer {
      constructor(source) {
        this.source = source;
      }
      getLuminanceSource() {
        return this.source;
      }
      getWidth() {
        return this.source.getWidth();
      }
      getHeight() {
        return this.source.getHeight();
      }
    }
    class System {
      static arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      static currentTimeMillis() {
        return Date.now();
      }
    }
    class IndexOutOfBoundsException extends Exception {
    }
    IndexOutOfBoundsException.kind = "IndexOutOfBoundsException";
    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
      constructor(index = void 0, message = void 0) {
        super(message);
        this.index = index;
        this.message = message;
      }
    }
    ArrayIndexOutOfBoundsException.kind = "ArrayIndexOutOfBoundsException";
    class Arrays {
      static fill(a2, val) {
        for (let i2 = 0, len = a2.length; i2 < len; i2++)
          a2[i2] = val;
      }
      static fillWithin(a2, fromIndex, toIndex, val) {
        Arrays.rangeCheck(a2.length, fromIndex, toIndex);
        for (let i2 = fromIndex; i2 < toIndex; i2++)
          a2[i2] = val;
      }
      static rangeCheck(arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
          throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
        }
        if (fromIndex < 0) {
          throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (toIndex > arrayLength) {
          throw new ArrayIndexOutOfBoundsException(toIndex);
        }
      }
      static asList(...args) {
        return args;
      }
      static create(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x) => Array.from({ length: cols }).fill(value));
      }
      static createInt32Array(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x) => Int32Array.from({ length: cols }).fill(value));
      }
      static equals(first, second) {
        if (!first) {
          return false;
        }
        if (!second) {
          return false;
        }
        if (!first.length) {
          return false;
        }
        if (!second.length) {
          return false;
        }
        if (first.length !== second.length) {
          return false;
        }
        for (let i2 = 0, length = first.length; i2 < length; i2++) {
          if (first[i2] !== second[i2]) {
            return false;
          }
        }
        return true;
      }
      static hashCode(a2) {
        if (a2 === null) {
          return 0;
        }
        let result = 1;
        for (const element of a2) {
          result = 31 * result + element;
        }
        return result;
      }
      static fillUint8Array(a2, value) {
        for (let i2 = 0; i2 !== a2.length; i2++) {
          a2[i2] = value;
        }
      }
      static copyOf(original, newLength) {
        return original.slice(0, newLength);
      }
      static copyOfUint8Array(original, newLength) {
        if (original.length <= newLength) {
          const newArray = new Uint8Array(newLength);
          newArray.set(original);
          return newArray;
        }
        return original.slice(0, newLength);
      }
      static copyOfRange(original, from, to) {
        const newLength = to - from;
        const copy = new Int32Array(newLength);
        System.arraycopy(original, from, copy, 0, newLength);
        return copy;
      }
      static binarySearch(ar, el, comparator2) {
        if (void 0 === comparator2) {
          comparator2 = Arrays.numberComparator;
        }
        let m = 0;
        let n2 = ar.length - 1;
        while (m <= n2) {
          const k = n2 + m >> 1;
          const cmp = comparator2(el, ar[k]);
          if (cmp > 0) {
            m = k + 1;
          } else if (cmp < 0) {
            n2 = k - 1;
          } else {
            return k;
          }
        }
        return -m - 1;
      }
      static numberComparator(a2, b) {
        return a2 - b;
      }
    }
    class Integer {
      static numberOfTrailingZeros(i2) {
        let y;
        if (i2 === 0)
          return 32;
        let n2 = 31;
        y = i2 << 16;
        if (y !== 0) {
          n2 -= 16;
          i2 = y;
        }
        y = i2 << 8;
        if (y !== 0) {
          n2 -= 8;
          i2 = y;
        }
        y = i2 << 4;
        if (y !== 0) {
          n2 -= 4;
          i2 = y;
        }
        y = i2 << 2;
        if (y !== 0) {
          n2 -= 2;
          i2 = y;
        }
        return n2 - (i2 << 1 >>> 31);
      }
      static numberOfLeadingZeros(i2) {
        if (i2 === 0) {
          return 32;
        }
        let n2 = 1;
        if (i2 >>> 16 === 0) {
          n2 += 16;
          i2 <<= 16;
        }
        if (i2 >>> 24 === 0) {
          n2 += 8;
          i2 <<= 8;
        }
        if (i2 >>> 28 === 0) {
          n2 += 4;
          i2 <<= 4;
        }
        if (i2 >>> 30 === 0) {
          n2 += 2;
          i2 <<= 2;
        }
        n2 -= i2 >>> 31;
        return n2;
      }
      static toHexString(i2) {
        return i2.toString(16);
      }
      static toBinaryString(intNumber) {
        return String(parseInt(String(intNumber), 2));
      }
      static bitCount(i2) {
        i2 = i2 - (i2 >>> 1 & 1431655765);
        i2 = (i2 & 858993459) + (i2 >>> 2 & 858993459);
        i2 = i2 + (i2 >>> 4) & 252645135;
        i2 = i2 + (i2 >>> 8);
        i2 = i2 + (i2 >>> 16);
        return i2 & 63;
      }
      static truncDivision(dividend, divisor) {
        return Math.trunc(dividend / divisor);
      }
      static parseInt(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    Integer.MIN_VALUE_32_BITS = -2147483648;
    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class BitArray {
      constructor(size2, bits) {
        if (void 0 === size2) {
          this.size = 0;
          this.bits = new Int32Array(1);
        } else {
          this.size = size2;
          if (void 0 === bits || null === bits) {
            this.bits = BitArray.makeArray(size2);
          } else {
            this.bits = bits;
          }
        }
      }
      getSize() {
        return this.size;
      }
      getSizeInBytes() {
        return Math.floor((this.size + 7) / 8);
      }
      ensureCapacity(size2) {
        if (size2 > this.bits.length * 32) {
          const newBits = BitArray.makeArray(size2);
          System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
          this.bits = newBits;
        }
      }
      get(i2) {
        return (this.bits[Math.floor(i2 / 32)] & 1 << (i2 & 31)) !== 0;
      }
      set(i2) {
        this.bits[Math.floor(i2 / 32)] |= 1 << (i2 & 31);
      }
      flip(i2) {
        this.bits[Math.floor(i2 / 32)] ^= 1 << (i2 & 31);
      }
      getNextSet(from) {
        const size2 = this.size;
        if (from >= size2) {
          return size2;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size2;
          }
          currentBits = bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size2 ? size2 : result;
      }
      getNextUnset(from) {
        const size2 = this.size;
        if (from >= size2) {
          return size2;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = ~bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size2;
          }
          currentBits = ~bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size2 ? size2 : result;
      }
      setBulk(i2, newBits) {
        this.bits[Math.floor(i2 / 32)] = newBits;
      }
      setRange(start, end) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i2 = firstInt; i2 <= lastInt; i2++) {
          const firstBit = i2 > firstInt ? 0 : start & 31;
          const lastBit = i2 < lastInt ? 31 : end & 31;
          const mask = (2 << lastBit) - (1 << firstBit);
          bits[i2] |= mask;
        }
      }
      clear() {
        const max = this.bits.length;
        const bits = this.bits;
        for (let i2 = 0; i2 < max; i2++) {
          bits[i2] = 0;
        }
      }
      isRange(start, end, value) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return true;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i2 = firstInt; i2 <= lastInt; i2++) {
          const firstBit = i2 > firstInt ? 0 : start & 31;
          const lastBit = i2 < lastInt ? 31 : end & 31;
          const mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
          if ((bits[i2] & mask) !== (value ? mask : 0)) {
            return false;
          }
        }
        return true;
      }
      appendBit(bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
          this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
        }
        this.size++;
      }
      appendBits(value, numBits) {
        if (numBits < 0 || numBits > 32) {
          throw new IllegalArgumentException("Num bits must be between 0 and 32");
        }
        this.ensureCapacity(this.size + numBits);
        for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
          this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
        }
      }
      appendBitArray(other) {
        const otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        for (let i2 = 0; i2 < otherSize; i2++) {
          this.appendBit(other.get(i2));
        }
      }
      xor(other) {
        if (this.size !== other.size) {
          throw new IllegalArgumentException("Sizes don't match");
        }
        const bits = this.bits;
        for (let i2 = 0, length = bits.length; i2 < length; i2++) {
          bits[i2] ^= other.bits[i2];
        }
      }
      toBytes(bitOffset, array, offset, numBytes) {
        for (let i2 = 0; i2 < numBytes; i2++) {
          let theByte = 0;
          for (let j = 0; j < 8; j++) {
            if (this.get(bitOffset)) {
              theByte |= 1 << 7 - j;
            }
            bitOffset++;
          }
          array[offset + i2] = theByte;
        }
      }
      getBitArray() {
        return this.bits;
      }
      reverse() {
        const newBits = new Int32Array(this.bits.length);
        const len = Math.floor((this.size - 1) / 32);
        const oldBitsLen = len + 1;
        const bits = this.bits;
        for (let i2 = 0; i2 < oldBitsLen; i2++) {
          let x = bits[i2];
          x = x >> 1 & 1431655765 | (x & 1431655765) << 1;
          x = x >> 2 & 858993459 | (x & 858993459) << 2;
          x = x >> 4 & 252645135 | (x & 252645135) << 4;
          x = x >> 8 & 16711935 | (x & 16711935) << 8;
          x = x >> 16 & 65535 | (x & 65535) << 16;
          newBits[len - i2] = x;
        }
        if (this.size !== oldBitsLen * 32) {
          const leftOffset = oldBitsLen * 32 - this.size;
          let currentInt = newBits[0] >>> leftOffset;
          for (let i2 = 1; i2 < oldBitsLen; i2++) {
            const nextInt = newBits[i2];
            currentInt |= nextInt << 32 - leftOffset;
            newBits[i2 - 1] = currentInt;
            currentInt = nextInt >>> leftOffset;
          }
          newBits[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits;
      }
      static makeArray(size2) {
        return new Int32Array(Math.floor((size2 + 31) / 32));
      }
      equals(o2) {
        if (!(o2 instanceof BitArray)) {
          return false;
        }
        const other = o2;
        return this.size === other.size && Arrays.equals(this.bits, other.bits);
      }
      hashCode() {
        return 31 * this.size + Arrays.hashCode(this.bits);
      }
      toString() {
        let result = "";
        for (let i2 = 0, size2 = this.size; i2 < size2; i2++) {
          if ((i2 & 7) === 0) {
            result += " ";
          }
          result += this.get(i2) ? "X" : ".";
        }
        return result;
      }
      clone() {
        return new BitArray(this.size, this.bits.slice());
      }
    }
    var DecodeHintType;
    (function(DecodeHintType2) {
      DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
      DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
      DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
      DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
      DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
      DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
      DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
      DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 7] = "ASSUME_GS1";
      DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
      DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
      DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
    })(DecodeHintType || (DecodeHintType = {}));
    var DecodeHintType$1 = DecodeHintType;
    class FormatException extends Exception {
      static getFormatInstance() {
        return new FormatException();
      }
    }
    FormatException.kind = "FormatException";
    var CharacterSetValueIdentifiers;
    (function(CharacterSetValueIdentifiers2) {
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
    class CharacterSetECI {
      constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {
        this.valueIdentifier = valueIdentifier;
        this.name = name;
        if (typeof valuesParam === "number") {
          this.values = Int32Array.from([valuesParam]);
        } else {
          this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI.NAME_TO_ECI.set(name, this);
        const values = this.values;
        for (let i2 = 0, length = values.length; i2 !== length; i2++) {
          const v2 = values[i2];
          CharacterSetECI.VALUES_TO_ECI.set(v2, this);
        }
        for (const otherName of otherEncodingNames) {
          CharacterSetECI.NAME_TO_ECI.set(otherName, this);
        }
      }
      getValueIdentifier() {
        return this.valueIdentifier;
      }
      getName() {
        return this.name;
      }
      getValue() {
        return this.values[0];
      }
      static getCharacterSetECIByValue(value) {
        if (value < 0 || value >= 900) {
          throw new FormatException("incorect value");
        }
        const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      static getCharacterSetECIByName(name) {
        const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      equals(o2) {
        if (!(o2 instanceof CharacterSetECI)) {
          return false;
        }
        const other = o2;
        return this.getName() === other.getName();
      }
    }
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.VALUES_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.NAME_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, "Big5");
    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
    class UnsupportedOperationException extends Exception {
    }
    UnsupportedOperationException.kind = "UnsupportedOperationException";
    class StringEncoding {
      static decode(bytes, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customDecoder) {
          return this.customDecoder(bytes, encodingName);
        }
        if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
          return this.decodeFallback(bytes, encodingName);
        }
        return new TextDecoder(encodingName).decode(bytes);
      }
      static shouldDecodeOnFallback(encodingName) {
        return !StringEncoding.isBrowser() && encodingName === "ISO-8859-1";
      }
      static encode(s2, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customEncoder) {
          return this.customEncoder(s2, encodingName);
        }
        if (typeof TextEncoder === "undefined") {
          return this.encodeFallback(s2);
        }
        return new TextEncoder().encode(s2);
      }
      static isBrowser() {
        return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
      }
      static encodingName(encoding) {
        return typeof encoding === "string" ? encoding : encoding.getName();
      }
      static encodingCharacterSet(encoding) {
        if (encoding instanceof CharacterSetECI) {
          return encoding;
        }
        return CharacterSetECI.getCharacterSetECIByName(encoding);
      }
      static decodeFallback(bytes, encoding) {
        const characterSet = this.encodingCharacterSet(encoding);
        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
          let s2 = "";
          for (let i2 = 0, length = bytes.length; i2 < length; i2++) {
            let h2 = bytes[i2].toString(16);
            if (h2.length < 2) {
              h2 = "0" + h2;
            }
            s2 += "%" + h2;
          }
          return decodeURIComponent(s2);
        }
        if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        }
        throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
      }
      static isDecodeFallbackSupported(characterSet) {
        return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);
      }
      static encodeFallback(s2) {
        const encodedURIstring = btoa(unescape(encodeURIComponent(s2)));
        const charList = encodedURIstring.split("");
        const uintArray = [];
        for (let i2 = 0; i2 < charList.length; i2++) {
          uintArray.push(charList[i2].charCodeAt(0));
        }
        return new Uint8Array(uintArray);
      }
    }
    class StringUtils {
      static castAsNonUtf8Char(code, encoding = null) {
        const e2 = encoding ? encoding.getName() : this.ISO88591;
        return StringEncoding.decode(new Uint8Array([code]), e2);
      }
      static guessEncoding(bytes, hints) {
        if (hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.CHARACTER_SET)) {
          return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
        }
        const length = bytes.length;
        let canBeISO88591 = true;
        let canBeShiftJIS = true;
        let canBeUTF8 = true;
        let utf8BytesLeft = 0;
        let utf2BytesChars = 0;
        let utf3BytesChars = 0;
        let utf4BytesChars = 0;
        let sjisBytesLeft = 0;
        let sjisKatakanaChars = 0;
        let sjisCurKatakanaWordLength = 0;
        let sjisCurDoubleBytesWordLength = 0;
        let sjisMaxKatakanaWordLength = 0;
        let sjisMaxDoubleBytesWordLength = 0;
        let isoHighOther = 0;
        const utf8bom = bytes.length > 3 && bytes[0] === 239 && bytes[1] === 187 && bytes[2] === 191;
        for (let i2 = 0; i2 < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i2++) {
          const value = bytes[i2] & 255;
          if (canBeUTF8) {
            if (utf8BytesLeft > 0) {
              if ((value & 128) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft--;
              }
            } else if ((value & 128) !== 0) {
              if ((value & 64) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft++;
                if ((value & 32) === 0) {
                  utf2BytesChars++;
                } else {
                  utf8BytesLeft++;
                  if ((value & 16) === 0) {
                    utf3BytesChars++;
                  } else {
                    utf8BytesLeft++;
                    if ((value & 8) === 0) {
                      utf4BytesChars++;
                    } else {
                      canBeUTF8 = false;
                    }
                  }
                }
              }
            }
          }
          if (canBeISO88591) {
            if (value > 127 && value < 160) {
              canBeISO88591 = false;
            } else if (value > 159) {
              if (value < 192 || value === 215 || value === 247) {
                isoHighOther++;
              }
            }
          }
          if (canBeShiftJIS) {
            if (sjisBytesLeft > 0) {
              if (value < 64 || value === 127 || value > 252) {
                canBeShiftJIS = false;
              } else {
                sjisBytesLeft--;
              }
            } else if (value === 128 || value === 160 || value > 239) {
              canBeShiftJIS = false;
            } else if (value > 160 && value < 224) {
              sjisKatakanaChars++;
              sjisCurDoubleBytesWordLength = 0;
              sjisCurKatakanaWordLength++;
              if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
              }
            } else if (value > 127) {
              sjisBytesLeft++;
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength++;
              if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
              }
            } else {
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength = 0;
            }
          }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
          canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
          canBeShiftJIS = false;
        }
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
          return StringUtils.UTF8;
        }
        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeISO88591 && canBeShiftJIS) {
          return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
        }
        if (canBeISO88591) {
          return StringUtils.ISO88591;
        }
        if (canBeShiftJIS) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeUTF8) {
          return StringUtils.UTF8;
        }
        return StringUtils.PLATFORM_DEFAULT_ENCODING;
      }
      static format(append, ...args) {
        let i2 = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (args[++i2] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = args[i2];
              break;
            case "c":
              val = args[i2][0];
              break;
            case "f":
              val = parseFloat(args[i2]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(args[i2]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(args[i2]).toExponential(exp);
              break;
            case "x":
              val = parseInt(args[i2]).toString(base ? base : 16);
              break;
            case "d":
              val = parseFloat(parseInt(args[i2], base ? base : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
          let size2 = parseInt(p1);
          let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size2)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return append.replace(regex, callback);
      }
      static getBytes(str, encoding) {
        return StringEncoding.encode(str, encoding);
      }
      static getCharCode(str, index = 0) {
        return str.charCodeAt(index);
      }
      static getCharAt(charCode) {
        return String.fromCharCode(charCode);
      }
    }
    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
    StringUtils.GB2312 = "GB2312";
    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
    StringUtils.EUC_JP = "EUC_JP";
    StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
    StringUtils.ASSUME_SHIFT_JIS = false;
    class StringBuilder {
      constructor(value = "") {
        this.value = value;
      }
      enableDecoding(encoding) {
        this.encoding = encoding;
        return this;
      }
      append(s2) {
        if (typeof s2 === "string") {
          this.value += s2.toString();
        } else if (this.encoding) {
          this.value += StringUtils.castAsNonUtf8Char(s2, this.encoding);
        } else {
          this.value += String.fromCharCode(s2);
        }
        return this;
      }
      appendChars(str, offset, len) {
        for (let i2 = offset; offset < offset + len; i2++) {
          this.append(str[i2]);
        }
        return this;
      }
      length() {
        return this.value.length;
      }
      charAt(n2) {
        return this.value.charAt(n2);
      }
      deleteCharAt(n2) {
        this.value = this.value.substr(0, n2) + this.value.substring(n2 + 1);
      }
      setCharAt(n2, c2) {
        this.value = this.value.substr(0, n2) + c2 + this.value.substr(n2 + 1);
      }
      substring(start, end) {
        return this.value.substring(start, end);
      }
      setLengthToZero() {
        this.value = "";
      }
      toString() {
        return this.value;
      }
      insert(n2, c2) {
        this.value = this.value.substr(0, n2) + c2 + this.value.substr(n2 + c2.length);
      }
    }
    class BitMatrix {
      constructor(width, height, rowSize, bits) {
        this.width = width;
        this.height = height;
        this.rowSize = rowSize;
        this.bits = bits;
        if (void 0 === height || null === height) {
          height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
          throw new IllegalArgumentException("Both dimensions must be greater than 0");
        }
        if (void 0 === rowSize || null === rowSize) {
          rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (void 0 === bits || null === bits) {
          this.bits = new Int32Array(this.rowSize * this.height);
        }
      }
      static parseFromBooleanArray(image) {
        const height = image.length;
        const width = image[0].length;
        const bits = new BitMatrix(width, height);
        for (let i2 = 0; i2 < height; i2++) {
          const imageI = image[i2];
          for (let j = 0; j < width; j++) {
            if (imageI[j]) {
              bits.set(j, i2);
            }
          }
        }
        return bits;
      }
      static parseFromString(stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
          throw new IllegalArgumentException("stringRepresentation cannot be null");
        }
        const bits = new Array(stringRepresentation.length);
        let bitsPos = 0;
        let rowStartPos = 0;
        let rowLength = -1;
        let nRows = 0;
        let pos = 0;
        while (pos < stringRepresentation.length) {
          if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
            if (bitsPos > rowStartPos) {
              if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
              } else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException("row lengths do not match");
              }
              rowStartPos = bitsPos;
              nRows++;
            }
            pos++;
          } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
            pos += setString.length;
            bits[bitsPos] = true;
            bitsPos++;
          } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
            pos += unsetString.length;
            bits[bitsPos] = false;
            bitsPos++;
          } else {
            throw new IllegalArgumentException("illegal character encountered: " + stringRepresentation.substring(pos));
          }
        }
        if (bitsPos > rowStartPos) {
          if (rowLength === -1) {
            rowLength = bitsPos - rowStartPos;
          } else if (bitsPos - rowStartPos !== rowLength) {
            throw new IllegalArgumentException("row lengths do not match");
          }
          nRows++;
        }
        const matrix = new BitMatrix(rowLength, nRows);
        for (let i2 = 0; i2 < bitsPos; i2++) {
          if (bits[i2]) {
            matrix.set(Math.floor(i2 % rowLength), Math.floor(i2 / rowLength));
          }
        }
        return matrix;
      }
      get(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        return (this.bits[offset] >>> (x & 31) & 1) !== 0;
      }
      set(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] |= 1 << (x & 31) & 4294967295;
      }
      unset(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] &= ~(1 << (x & 31) & 4294967295);
      }
      flip(x, y) {
        const offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] ^= 1 << (x & 31) & 4294967295;
      }
      xor(mask) {
        if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
          throw new IllegalArgumentException("input matrix dimensions do not match");
        }
        const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y = 0, height = this.height; y < height; y++) {
          const offset = y * rowSize;
          const row = mask.getRow(y, rowArray).getBitArray();
          for (let x = 0; x < rowSize; x++) {
            bits[offset + x] ^= row[x];
          }
        }
      }
      clear() {
        const bits = this.bits;
        const max = bits.length;
        for (let i2 = 0; i2 < max; i2++) {
          bits[i2] = 0;
        }
      }
      setRegion(left, top, width, height) {
        if (top < 0 || left < 0) {
          throw new IllegalArgumentException("Left and top must be nonnegative");
        }
        if (height < 1 || width < 1) {
          throw new IllegalArgumentException("Height and width must be at least 1");
        }
        const right = left + width;
        const bottom = top + height;
        if (bottom > this.height || right > this.width) {
          throw new IllegalArgumentException("The region must fit inside the matrix");
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y = top; y < bottom; y++) {
          const offset = y * rowSize;
          for (let x = left; x < right; x++) {
            bits[offset + Math.floor(x / 32)] |= 1 << (x & 31) & 4294967295;
          }
        }
      }
      getRow(y, row) {
        if (row === null || row === void 0 || row.getSize() < this.width) {
          row = new BitArray(this.width);
        } else {
          row.clear();
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        const offset = y * rowSize;
        for (let x = 0; x < rowSize; x++) {
          row.setBulk(x * 32, bits[offset + x]);
        }
        return row;
      }
      setRow(y, row) {
        System.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
      }
      rotate180() {
        const width = this.getWidth();
        const height = this.getHeight();
        let topRow = new BitArray(width);
        let bottomRow = new BitArray(width);
        for (let i2 = 0, length = Math.floor((height + 1) / 2); i2 < length; i2++) {
          topRow = this.getRow(i2, topRow);
          bottomRow = this.getRow(height - 1 - i2, bottomRow);
          topRow.reverse();
          bottomRow.reverse();
          this.setRow(i2, bottomRow);
          this.setRow(height - 1 - i2, topRow);
        }
      }
      getEnclosingRectangle() {
        const width = this.width;
        const height = this.height;
        const rowSize = this.rowSize;
        const bits = this.bits;
        let left = width;
        let top = height;
        let right = -1;
        let bottom = -1;
        for (let y = 0; y < height; y++) {
          for (let x32 = 0; x32 < rowSize; x32++) {
            const theBits = bits[y * rowSize + x32];
            if (theBits !== 0) {
              if (y < top) {
                top = y;
              }
              if (y > bottom) {
                bottom = y;
              }
              if (x32 * 32 < left) {
                let bit = 0;
                while ((theBits << 31 - bit & 4294967295) === 0) {
                  bit++;
                }
                if (x32 * 32 + bit < left) {
                  left = x32 * 32 + bit;
                }
              }
              if (x32 * 32 + 31 > right) {
                let bit = 31;
                while (theBits >>> bit === 0) {
                  bit--;
                }
                if (x32 * 32 + bit > right) {
                  right = x32 * 32 + bit;
                }
              }
            }
          }
        }
        if (right < left || bottom < top) {
          return null;
        }
        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
      }
      getTopLeftOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
          bitsOffset++;
        }
        if (bitsOffset === bits.length) {
          return null;
        }
        const y = bitsOffset / rowSize;
        let x = bitsOffset % rowSize * 32;
        const theBits = bits[bitsOffset];
        let bit = 0;
        while ((theBits << 31 - bit & 4294967295) === 0) {
          bit++;
        }
        x += bit;
        return Int32Array.from([x, y]);
      }
      getBottomRightOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
          bitsOffset--;
        }
        if (bitsOffset < 0) {
          return null;
        }
        const y = Math.floor(bitsOffset / rowSize);
        let x = Math.floor(bitsOffset % rowSize) * 32;
        const theBits = bits[bitsOffset];
        let bit = 31;
        while (theBits >>> bit === 0) {
          bit--;
        }
        x += bit;
        return Int32Array.from([x, y]);
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      getRowSize() {
        return this.rowSize;
      }
      equals(o2) {
        if (!(o2 instanceof BitMatrix)) {
          return false;
        }
        const other = o2;
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);
      }
      hashCode() {
        let hash = this.width;
        hash = 31 * hash + this.width;
        hash = 31 * hash + this.height;
        hash = 31 * hash + this.rowSize;
        hash = 31 * hash + Arrays.hashCode(this.bits);
        return hash;
      }
      toString(setString = "X ", unsetString = "  ", lineSeparator = "\n") {
        return this.buildToString(setString, unsetString, lineSeparator);
      }
      buildToString(setString, unsetString, lineSeparator) {
        let result = new StringBuilder();
        for (let y = 0, height = this.height; y < height; y++) {
          for (let x = 0, width = this.width; x < width; x++) {
            result.append(this.get(x, y) ? setString : unsetString);
          }
          result.append(lineSeparator);
        }
        return result.toString();
      }
      clone() {
        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
      }
    }
    class NotFoundException extends Exception {
      static getNotFoundInstance() {
        return new NotFoundException();
      }
    }
    NotFoundException.kind = "NotFoundException";
    class GlobalHistogramBinarizer extends Binarizer {
      constructor(source) {
        super(source);
        this.luminances = GlobalHistogramBinarizer.EMPTY;
        this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
      }
      getBlackRow(y, row) {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        if (row === void 0 || row === null || row.getSize() < width) {
          row = new BitArray(width);
        } else {
          row.clear();
        }
        this.initArrays(width);
        const localLuminances = source.getRow(y, this.luminances);
        const localBuckets = this.buckets;
        for (let x = 0; x < width; x++) {
          localBuckets[(localLuminances[x] & 255) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        if (width < 3) {
          for (let x = 0; x < width; x++) {
            if ((localLuminances[x] & 255) < blackPoint) {
              row.set(x);
            }
          }
        } else {
          let left = localLuminances[0] & 255;
          let center = localLuminances[1] & 255;
          for (let x = 1; x < width - 1; x++) {
            const right = localLuminances[x + 1] & 255;
            if ((center * 4 - left - right) / 2 < blackPoint) {
              row.set(x);
            }
            left = center;
            center = right;
          }
        }
        return row;
      }
      getBlackMatrix() {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        const matrix = new BitMatrix(width, height);
        this.initArrays(width);
        const localBuckets = this.buckets;
        for (let y = 1; y < 5; y++) {
          const row = Math.floor(height * y / 5);
          const localLuminances2 = source.getRow(row, this.luminances);
          const right = Math.floor(width * 4 / 5);
          for (let x = Math.floor(width / 5); x < right; x++) {
            const pixel = localLuminances2[x] & 255;
            localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
          }
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        const localLuminances = source.getMatrix();
        for (let y = 0; y < height; y++) {
          const offset = y * width;
          for (let x = 0; x < width; x++) {
            const pixel = localLuminances[offset + x] & 255;
            if (pixel < blackPoint) {
              matrix.set(x, y);
            }
          }
        }
        return matrix;
      }
      createBinarizer(source) {
        return new GlobalHistogramBinarizer(source);
      }
      initArrays(luminanceSize) {
        if (this.luminances.length < luminanceSize) {
          this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        const buckets = this.buckets;
        for (let x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
          buckets[x] = 0;
        }
      }
      static estimateBlackPoint(buckets) {
        const numBuckets = buckets.length;
        let maxBucketCount = 0;
        let firstPeak = 0;
        let firstPeakSize = 0;
        for (let x = 0; x < numBuckets; x++) {
          if (buckets[x] > firstPeakSize) {
            firstPeak = x;
            firstPeakSize = buckets[x];
          }
          if (buckets[x] > maxBucketCount) {
            maxBucketCount = buckets[x];
          }
        }
        let secondPeak = 0;
        let secondPeakScore = 0;
        for (let x = 0; x < numBuckets; x++) {
          const distanceToBiggest = x - firstPeak;
          const score = buckets[x] * distanceToBiggest * distanceToBiggest;
          if (score > secondPeakScore) {
            secondPeak = x;
            secondPeakScore = score;
          }
        }
        if (firstPeak > secondPeak) {
          const temp = firstPeak;
          firstPeak = secondPeak;
          secondPeak = temp;
        }
        if (secondPeak - firstPeak <= numBuckets / 16) {
          throw new NotFoundException();
        }
        let bestValley = secondPeak - 1;
        let bestValleyScore = -1;
        for (let x = secondPeak - 1; x > firstPeak; x--) {
          const fromFirst = x - firstPeak;
          const score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
          if (score > bestValleyScore) {
            bestValley = x;
            bestValleyScore = score;
          }
        }
        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
      }
    }
    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
    class HybridBinarizer extends GlobalHistogramBinarizer {
      constructor(source) {
        super(source);
        this.matrix = null;
      }
      getBlackMatrix() {
        if (this.matrix !== null) {
          return this.matrix;
        }
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
          const luminances = source.getMatrix();
          let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subWidth++;
          }
          let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subHeight++;
          }
          const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
          const newMatrix = new BitMatrix(width, height);
          HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
          this.matrix = newMatrix;
        } else {
          this.matrix = super.getBlackMatrix();
        }
        return this.matrix;
      }
      createBinarizer(source) {
        return new HybridBinarizer(source);
      }
      static calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        for (let y = 0; y < subHeight; y++) {
          let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          const top = HybridBinarizer.cap(y, 2, subHeight - 3);
          for (let x = 0; x < subWidth; x++) {
            let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            const left = HybridBinarizer.cap(x, 2, subWidth - 3);
            let sum = 0;
            for (let z = -2; z <= 2; z++) {
              const blackRow = blackPoints[top + z];
              sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
            }
            const average = sum / 25;
            HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
          }
        }
      }
      static cap(value, min, max) {
        return value < min ? min : value > max ? max : value;
      }
      static thresholdBlock(luminances, xoffset, yoffset, threshold, stride, matrix) {
        for (let y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
          for (let x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
            if ((luminances[offset + x] & 255) <= threshold) {
              matrix.set(xoffset + x, yoffset + y);
            }
          }
        }
      }
      static calculateBlackPoints(luminances, subWidth, subHeight, width, height) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        const blackPoints = new Array(subHeight);
        for (let y = 0; y < subHeight; y++) {
          blackPoints[y] = new Int32Array(subWidth);
          let yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          for (let x = 0; x < subWidth; x++) {
            let xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            let sum = 0;
            let min = 255;
            let max = 0;
            for (let yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
              for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                const pixel = luminances[offset + xx] & 255;
                sum += pixel;
                if (pixel < min) {
                  min = pixel;
                }
                if (pixel > max) {
                  max = pixel;
                }
              }
              if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                  for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                    sum += luminances[offset + xx] & 255;
                  }
                }
              }
            }
            let average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;
            if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
              average = min / 2;
              if (y > 0 && x > 0) {
                const averageNeighborBlackPoint = (blackPoints[y - 1][x] + 2 * blackPoints[y][x - 1] + blackPoints[y - 1][x - 1]) / 4;
                if (min < averageNeighborBlackPoint) {
                  average = averageNeighborBlackPoint;
                }
              }
            }
            blackPoints[y][x] = average;
          }
        }
        return blackPoints;
      }
    }
    HybridBinarizer.BLOCK_SIZE_POWER = 3;
    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER;
    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1;
    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
    class LuminanceSource {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      getWidth() {
        return this.width;
      }
      getHeight() {
        return this.height;
      }
      isCropSupported() {
        return false;
      }
      crop(left, top, width, height) {
        throw new UnsupportedOperationException("This luminance source does not support cropping.");
      }
      isRotateSupported() {
        return false;
      }
      rotateCounterClockwise() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");
      }
      rotateCounterClockwise45() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");
      }
      toString() {
        const row = new Uint8ClampedArray(this.width);
        let result = new StringBuilder();
        for (let y = 0; y < this.height; y++) {
          const sourceRow = this.getRow(y, row);
          for (let x = 0; x < this.width; x++) {
            const luminance = sourceRow[x] & 255;
            let c2;
            if (luminance < 64) {
              c2 = "#";
            } else if (luminance < 128) {
              c2 = "+";
            } else if (luminance < 192) {
              c2 = ".";
            } else {
              c2 = " ";
            }
            result.append(c2);
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class InvertedLuminanceSource extends LuminanceSource {
      constructor(delegate) {
        super(delegate.getWidth(), delegate.getHeight());
        this.delegate = delegate;
      }
      getRow(y, row) {
        const sourceRow = this.delegate.getRow(y, row);
        const width = this.getWidth();
        for (let i2 = 0; i2 < width; i2++) {
          sourceRow[i2] = 255 - (sourceRow[i2] & 255);
        }
        return sourceRow;
      }
      getMatrix() {
        const matrix = this.delegate.getMatrix();
        const length = this.getWidth() * this.getHeight();
        const invertedMatrix = new Uint8ClampedArray(length);
        for (let i2 = 0; i2 < length; i2++) {
          invertedMatrix[i2] = 255 - (matrix[i2] & 255);
        }
        return invertedMatrix;
      }
      isCropSupported() {
        return this.delegate.isCropSupported();
      }
      crop(left, top, width, height) {
        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
      }
      isRotateSupported() {
        return this.delegate.isRotateSupported();
      }
      invert() {
        return this.delegate;
      }
      rotateCounterClockwise() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
      }
      rotateCounterClockwise45() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
      }
    }
    class HTMLCanvasElementLuminanceSource extends LuminanceSource {
      constructor(canvas) {
        super(canvas.width, canvas.height);
        this.canvas = canvas;
        this.tempCanvasElement = null;
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
      }
      static makeBufferFromCanvasImageData(canvas) {
        const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
      }
      static toGrayscaleBuffer(imageBuffer, width, height) {
        const grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (let i2 = 0, j = 0, length = imageBuffer.length; i2 < length; i2 += 4, j++) {
          let gray;
          const alpha = imageBuffer[i2 + 3];
          if (alpha === 0) {
            gray = 255;
          } else {
            const pixelR = imageBuffer[i2];
            const pixelG = imageBuffer[i2 + 1];
            const pixelB = imageBuffer[i2 + 2];
            gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
          }
          grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
      }
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        const start = y * width;
        if (row === null) {
          row = this.buffer.slice(start, start + width);
        } else {
          if (row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          row.set(this.buffer.slice(start, start + width));
        }
        return row;
      }
      getMatrix() {
        return this.buffer;
      }
      isCropSupported() {
        return true;
      }
      crop(left, top, width, height) {
        super.crop(left, top, width, height);
        return this;
      }
      isRotateSupported() {
        return true;
      }
      rotateCounterClockwise() {
        this.rotate(-90);
        return this;
      }
      rotateCounterClockwise45() {
        this.rotate(-45);
        return this;
      }
      getTempCanvasElement() {
        if (null === this.tempCanvasElement) {
          const tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
          tempCanvasElement.width = this.canvas.width;
          tempCanvasElement.height = this.canvas.height;
          this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
      }
      rotate(angle) {
        const tempCanvasElement = this.getTempCanvasElement();
        const tempContext = tempCanvasElement.getContext("2d");
        const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
        const width = this.canvas.width;
        const height = this.canvas.height;
        const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
    class VideoInputDevice {
      constructor(deviceId, label, groupId) {
        this.deviceId = deviceId;
        this.label = label;
        this.kind = "videoinput";
        this.groupId = groupId || void 0;
      }
      toJSON() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label
        };
      }
    }
    var __awaiter2 = (globalThis || commonjsGlobal || self || window || void 0) && (globalThis || commonjsGlobal || self || window || void 0).__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class BrowserCodeReader {
      constructor(reader, timeBetweenScansMillis = 500, _hints) {
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
        this._hints = _hints;
        this._stopContinuousDecode = false;
        this._stopAsyncDecode = false;
        this._timeBetweenDecodingAttempts = 0;
      }
      get hasNavigator() {
        return typeof navigator !== "undefined";
      }
      get isMediaDevicesSuported() {
        return this.hasNavigator && !!navigator.mediaDevices;
      }
      get canEnumerateDevices() {
        return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
      }
      get timeBetweenDecodingAttempts() {
        return this._timeBetweenDecodingAttempts;
      }
      set timeBetweenDecodingAttempts(millis) {
        this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
      }
      set hints(hints) {
        this._hints = hints || null;
      }
      get hints() {
        return this._hints;
      }
      listVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.hasNavigator) {
            throw new Error("Can't enumerate devices, navigator is not present.");
          }
          if (!this.canEnumerateDevices) {
            throw new Error("Can't enumerate devices, method not supported.");
          }
          const devices = yield navigator.mediaDevices.enumerateDevices();
          const videoDevices = [];
          for (const device of devices) {
            const kind = device.kind === "video" ? "videoinput" : device.kind;
            if (kind !== "videoinput") {
              continue;
            }
            const deviceId = device.deviceId || device.id;
            const label = device.label || `Video device ${videoDevices.length + 1}`;
            const groupId = device.groupId;
            const videoDevice = { deviceId, label, kind, groupId };
            videoDevices.push(videoDevice);
          }
          return videoDevices;
        });
      }
      getVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          return devices.map((d) => new VideoInputDevice(d.deviceId, d.label));
        });
      }
      findDeviceById(deviceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          if (!devices) {
            return null;
          }
          return devices.find((x) => x.deviceId === deviceId);
        });
      }
      decodeFromInputVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
        });
      }
      decodeOnceFromVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeOnceFromConstraints(constraints, videoSource);
        });
      }
      decodeOnceFromConstraints(constraints, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeOnceFromStream(stream, videoSource);
        });
      }
      decodeOnceFromStream(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          const result = yield this.decodeOnce(video);
          return result;
        });
      }
      decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
        });
      }
      decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
        });
      }
      decodeFromConstraints(constraints, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeFromStream(stream, videoSource, callbackFn);
        });
      }
      decodeFromStream(stream, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          return yield this.decodeContinuously(video, callbackFn);
        });
      }
      stopAsyncDecode() {
        this._stopAsyncDecode = true;
      }
      stopContinuousDecode() {
        this._stopContinuousDecode = true;
      }
      attachStreamToVideo(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const videoElement = this.prepareVideoElement(videoSource);
          this.addVideoSource(videoElement, stream);
          this.videoElement = videoElement;
          this.stream = stream;
          yield this.playVideoOnLoadAsync(videoElement);
          return videoElement;
        });
      }
      playVideoOnLoadAsync(videoElement) {
        return new Promise((resolve2, reject) => this.playVideoOnLoad(videoElement, () => resolve2()));
      }
      playVideoOnLoad(element, callbackFn) {
        this.videoEndedListener = () => this.stopStreams();
        this.videoCanPlayListener = () => this.tryPlayVideo(element);
        element.addEventListener("ended", this.videoEndedListener);
        element.addEventListener("canplay", this.videoCanPlayListener);
        element.addEventListener("playing", callbackFn);
        this.tryPlayVideo(element);
      }
      isVideoPlaying(video) {
        return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
      }
      tryPlayVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.isVideoPlaying(videoElement)) {
            console.warn("Trying to play video that is already playing.");
            return;
          }
          try {
            yield videoElement.play();
          } catch (_a2) {
            console.warn("It was not possible to play the video.");
          }
        });
      }
      getMediaElement(mediaElementId, type) {
        const mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
          throw new ArgumentException(`element with id '${mediaElementId}' not found`);
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
          throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
        }
        return mediaElement;
      }
      decodeFromImage(source, url) {
        if (!source && !url) {
          throw new ArgumentException("either imageElement with a src set or an url must be provided");
        }
        if (url && !source) {
          return this.decodeFromImageUrl(url);
        }
        return this.decodeFromImageElement(source);
      }
      decodeFromVideo(source, url) {
        if (!source && !url) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrl(url);
        }
        return this.decodeFromVideoElement(source);
      }
      decodeFromVideoContinuously(source, url, callbackFn) {
        if (void 0 === source && void 0 === url) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url && !source) {
          return this.decodeFromVideoUrlContinuously(url, callbackFn);
        }
        return this.decodeFromVideoElementContinuously(source, callbackFn);
      }
      decodeFromImageElement(source) {
        if (!source) {
          throw new ArgumentException("An image element must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement(source);
        this.imageElement = element;
        let task;
        if (this.isImageLoaded(element)) {
          task = this.decodeOnce(element, false, true);
        } else {
          task = this._decodeOnLoadImage(element);
        }
        return task;
      }
      decodeFromVideoElement(source) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideo(element);
      }
      decodeFromVideoElementContinuously(source, callbackFn) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideoContinuously(element, callbackFn);
      }
      _decodeFromVideoElementSetup(source) {
        if (!source) {
          throw new ArgumentException("A video element must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement(source);
        this.videoElement = element;
        return element;
      }
      decodeFromImageUrl(url) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement();
        this.imageElement = element;
        const decodeTask = this._decodeOnLoadImage(element);
        element.src = url;
        return decodeTask;
      }
      decodeFromVideoUrl(url) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElement(element);
        element.src = url;
        return decodeTask;
      }
      decodeFromVideoUrlContinuously(url, callbackFn) {
        if (!url) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
        element.src = url;
        return decodeTask;
      }
      _decodeOnLoadImage(element) {
        return new Promise((resolve2, reject) => {
          this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve2, reject);
          element.addEventListener("load", this.imageLoadedListener);
        });
      }
      _decodeOnLoadVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          return yield this.decodeOnce(videoElement);
        });
      }
      _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          this.decodeContinuously(videoElement, callbackFn);
        });
      }
      isImageLoaded(img) {
        if (!img.complete) {
          return false;
        }
        if (img.naturalWidth === 0) {
          return false;
        }
        return true;
      }
      prepareImageElement(imageSource) {
        let imageElement;
        if (typeof imageSource === "undefined") {
          imageElement = document.createElement("img");
          imageElement.width = 200;
          imageElement.height = 200;
        }
        if (typeof imageSource === "string") {
          imageElement = this.getMediaElement(imageSource, "img");
        }
        if (imageSource instanceof HTMLImageElement) {
          imageElement = imageSource;
        }
        return imageElement;
      }
      prepareVideoElement(videoSource) {
        let videoElement;
        if (!videoSource && typeof document !== "undefined") {
          videoElement = document.createElement("video");
          videoElement.width = 200;
          videoElement.height = 200;
        }
        if (typeof videoSource === "string") {
          videoElement = this.getMediaElement(videoSource, "video");
        }
        if (videoSource instanceof HTMLVideoElement) {
          videoElement = videoSource;
        }
        videoElement.setAttribute("autoplay", "true");
        videoElement.setAttribute("muted", "true");
        videoElement.setAttribute("playsinline", "true");
        return videoElement;
      }
      decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
        this._stopAsyncDecode = false;
        const loop = (resolve2, reject) => {
          if (this._stopAsyncDecode) {
            reject(new NotFoundException("Video stream has ended before any code could be detected."));
            this._stopAsyncDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            resolve2(result);
          } catch (e2) {
            const ifNotFound = retryIfNotFound && e2 instanceof NotFoundException;
            const isChecksumOrFormatError = e2 instanceof ChecksumException || e2 instanceof FormatException;
            const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
            if (ifNotFound || ifChecksumOrFormat) {
              return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve2, reject);
            }
            reject(e2);
          }
        };
        return new Promise((resolve2, reject) => loop(resolve2, reject));
      }
      decodeContinuously(element, callbackFn) {
        this._stopContinuousDecode = false;
        const loop = () => {
          if (this._stopContinuousDecode) {
            this._stopContinuousDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            callbackFn(result, null);
            setTimeout(loop, this.timeBetweenScansMillis);
          } catch (e2) {
            callbackFn(null, e2);
            const isChecksumOrFormatError = e2 instanceof ChecksumException || e2 instanceof FormatException;
            const isNotFound = e2 instanceof NotFoundException;
            if (isChecksumOrFormatError || isNotFound) {
              setTimeout(loop, this._timeBetweenDecodingAttempts);
            }
          }
        };
        loop();
      }
      decode(element) {
        const binaryBitmap = this.createBinaryBitmap(element);
        return this.decodeBitmap(binaryBitmap);
      }
      createBinaryBitmap(mediaElement) {
        const ctx = this.getCaptureCanvasContext(mediaElement);
        this.drawImageOnCanvas(ctx, mediaElement);
        const canvas = this.getCaptureCanvas(mediaElement);
        const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
        const hybridBinarizer = new HybridBinarizer(luminanceSource);
        return new BinaryBitmap(hybridBinarizer);
      }
      getCaptureCanvasContext(mediaElement) {
        if (!this.captureCanvasContext) {
          const elem = this.getCaptureCanvas(mediaElement);
          const ctx = elem.getContext("2d");
          this.captureCanvasContext = ctx;
        }
        return this.captureCanvasContext;
      }
      getCaptureCanvas(mediaElement) {
        if (!this.captureCanvas) {
          const elem = this.createCaptureCanvas(mediaElement);
          this.captureCanvas = elem;
        }
        return this.captureCanvas;
      }
      drawImageOnCanvas(canvasElementContext, srcElement) {
        canvasElementContext.drawImage(srcElement, 0, 0);
      }
      decodeBitmap(binaryBitmap) {
        return this.reader.decode(binaryBitmap, this._hints);
      }
      createCaptureCanvas(mediaElement) {
        if (typeof document === "undefined") {
          this._destroyCaptureCanvas();
          return null;
        }
        const canvasElement = document.createElement("canvas");
        let width;
        let height;
        if (typeof mediaElement !== "undefined") {
          if (mediaElement instanceof HTMLVideoElement) {
            width = mediaElement.videoWidth;
            height = mediaElement.videoHeight;
          } else if (mediaElement instanceof HTMLImageElement) {
            width = mediaElement.naturalWidth || mediaElement.width;
            height = mediaElement.naturalHeight || mediaElement.height;
          }
        }
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
      }
      stopStreams() {
        if (this.stream) {
          this.stream.getVideoTracks().forEach((t2) => t2.stop());
          this.stream = void 0;
        }
        if (this._stopAsyncDecode === false) {
          this.stopAsyncDecode();
        }
        if (this._stopContinuousDecode === false) {
          this.stopContinuousDecode();
        }
      }
      reset() {
        this.stopStreams();
        this._destroyVideoElement();
        this._destroyImageElement();
        this._destroyCaptureCanvas();
      }
      _destroyVideoElement() {
        if (!this.videoElement) {
          return;
        }
        if (typeof this.videoEndedListener !== "undefined") {
          this.videoElement.removeEventListener("ended", this.videoEndedListener);
        }
        if (typeof this.videoPlayingEventListener !== "undefined") {
          this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
        }
        if (typeof this.videoCanPlayListener !== "undefined") {
          this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
        }
        this.cleanVideoSource(this.videoElement);
        this.videoElement = void 0;
      }
      _destroyImageElement() {
        if (!this.imageElement) {
          return;
        }
        if (void 0 !== this.imageLoadedListener) {
          this.imageElement.removeEventListener("load", this.imageLoadedListener);
        }
        this.imageElement.src = void 0;
        this.imageElement.removeAttribute("src");
        this.imageElement = void 0;
      }
      _destroyCaptureCanvas() {
        this.captureCanvasContext = void 0;
        this.captureCanvas = void 0;
      }
      addVideoSource(videoElement, stream) {
        try {
          videoElement.srcObject = stream;
        } catch (err) {
          videoElement.src = URL.createObjectURL(stream);
        }
      }
      cleanVideoSource(videoElement) {
        try {
          videoElement.srcObject = null;
        } catch (err) {
          videoElement.src = "";
        }
        this.videoElement.removeAttribute("src");
      }
    }
    class Result {
      constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format, timestamp = System.currentTimeMillis()) {
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits;
        this.resultPoints = resultPoints;
        this.format = format;
        this.timestamp = timestamp;
        this.text = text;
        this.rawBytes = rawBytes;
        if (void 0 === numBits || null === numBits) {
          this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
        } else {
          this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format;
        this.resultMetadata = null;
        if (void 0 === timestamp || null === timestamp) {
          this.timestamp = System.currentTimeMillis();
        } else {
          this.timestamp = timestamp;
        }
      }
      getText() {
        return this.text;
      }
      getRawBytes() {
        return this.rawBytes;
      }
      getNumBits() {
        return this.numBits;
      }
      getResultPoints() {
        return this.resultPoints;
      }
      getBarcodeFormat() {
        return this.format;
      }
      getResultMetadata() {
        return this.resultMetadata;
      }
      putMetadata(type, value) {
        if (this.resultMetadata === null) {
          this.resultMetadata = /* @__PURE__ */ new Map();
        }
        this.resultMetadata.set(type, value);
      }
      putAllMetadata(metadata) {
        if (metadata !== null) {
          if (this.resultMetadata === null) {
            this.resultMetadata = metadata;
          } else {
            this.resultMetadata = new Map(metadata);
          }
        }
      }
      addResultPoints(newPoints) {
        const oldPoints = this.resultPoints;
        if (oldPoints === null) {
          this.resultPoints = newPoints;
        } else if (newPoints !== null && newPoints.length > 0) {
          const allPoints = new Array(oldPoints.length + newPoints.length);
          System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
          System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
          this.resultPoints = allPoints;
        }
      }
      getTimestamp() {
        return this.timestamp;
      }
      toString() {
        return this.text;
      }
    }
    var BarcodeFormat;
    (function(BarcodeFormat2) {
      BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
      BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
      BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
      BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
      BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
      BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
      BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
      BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
      BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
      BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
      BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
      BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
      BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
      BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
      BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
      BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
      BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
    })(BarcodeFormat || (BarcodeFormat = {}));
    var BarcodeFormat$1 = BarcodeFormat;
    var ResultMetadataType;
    (function(ResultMetadataType2) {
      ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
      ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
      ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
      ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
      ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
      ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
      ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
      ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
      ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
    })(ResultMetadataType || (ResultMetadataType = {}));
    var ResultMetadataType$1 = ResultMetadataType;
    class DecoderResult {
      constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
        this.structuredAppendParity = structuredAppendParity;
        this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
      }
      getRawBytes() {
        return this.rawBytes;
      }
      getNumBits() {
        return this.numBits;
      }
      setNumBits(numBits) {
        this.numBits = numBits;
      }
      getText() {
        return this.text;
      }
      getByteSegments() {
        return this.byteSegments;
      }
      getECLevel() {
        return this.ecLevel;
      }
      getErrorsCorrected() {
        return this.errorsCorrected;
      }
      setErrorsCorrected(errorsCorrected) {
        this.errorsCorrected = errorsCorrected;
      }
      getErasures() {
        return this.erasures;
      }
      setErasures(erasures) {
        this.erasures = erasures;
      }
      getOther() {
        return this.other;
      }
      setOther(other) {
        this.other = other;
      }
      hasStructuredAppend() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
      }
      getStructuredAppendParity() {
        return this.structuredAppendParity;
      }
      getStructuredAppendSequenceNumber() {
        return this.structuredAppendSequenceNumber;
      }
    }
    class AbstractGenericGF {
      exp(a2) {
        return this.expTable[a2];
      }
      log(a2) {
        if (a2 === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a2];
      }
      static addOrSubtract(a2, b) {
        return a2 ^ b;
      }
    }
    class GenericGFPoly {
      constructor(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field;
        const coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = Int32Array.from([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      getDegree() {
        return this.coefficients.length - 1;
      }
      isZero() {
        return this.coefficients[0] === 0;
      }
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      evaluateAt(a2) {
        if (a2 === 0) {
          return this.getCoefficient(0);
        }
        const coefficients = this.coefficients;
        let result;
        if (a2 === 1) {
          result = 0;
          for (let i2 = 0, length = coefficients.length; i2 !== length; i2++) {
            const coefficient = coefficients[i2];
            result = AbstractGenericGF.addOrSubtract(result, coefficient);
          }
          return result;
        }
        result = coefficients[0];
        const size2 = coefficients.length;
        const field = this.field;
        for (let i2 = 1; i2 < size2; i2++) {
          result = AbstractGenericGF.addOrSubtract(field.multiply(a2, result), coefficients[i2]);
        }
        return result;
      }
      addOrSubtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          const temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i2 = lengthDiff; i2 < largerCoefficients.length; i2++) {
          sumDiff[i2] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
        }
        return new GenericGFPoly(this.field, sumDiff);
      }
      multiply(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero() || other.isZero()) {
          return this.field.getZero();
        }
        const aCoefficients = this.coefficients;
        const aLength = aCoefficients.length;
        const bCoefficients = other.coefficients;
        const bLength = bCoefficients.length;
        const product = new Int32Array(aLength + bLength - 1);
        const field = this.field;
        for (let i2 = 0; i2 < aLength; i2++) {
          const aCoeff = aCoefficients[i2];
          for (let j = 0; j < bLength; j++) {
            product[i2 + j] = AbstractGenericGF.addOrSubtract(product[i2 + j], field.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new GenericGFPoly(field, product);
      }
      multiplyScalar(scalar) {
        if (scalar === 0) {
          return this.field.getZero();
        }
        if (scalar === 1) {
          return this;
        }
        const size2 = this.coefficients.length;
        const field = this.field;
        const product = new Int32Array(size2);
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < size2; i2++) {
          product[i2] = field.multiply(coefficients[i2], scalar);
        }
        return new GenericGFPoly(field, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.field.getZero();
        }
        const coefficients = this.coefficients;
        const size2 = coefficients.length;
        const product = new Int32Array(size2 + degree);
        const field = this.field;
        for (let i2 = 0; i2 < size2; i2++) {
          product[i2] = field.multiply(coefficients[i2], coefficient);
        }
        return new GenericGFPoly(field, product);
      }
      divide(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (other.isZero()) {
          throw new IllegalArgumentException("Divide by 0");
        }
        const field = this.field;
        let quotient = field.getZero();
        let remainder = this;
        const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
          const degreeDifference = remainder.getDegree() - other.getDegree();
          const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
          const term = other.multiplyByMonomial(degreeDifference, scale);
          const iterationQuotient = field.buildMonomial(degreeDifference, scale);
          quotient = quotient.addOrSubtract(iterationQuotient);
          remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
      }
      toString() {
        let result = "";
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = this.getCoefficient(degree);
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result += " - ";
              coefficient = -coefficient;
            } else {
              if (result.length > 0) {
                result += " + ";
              }
            }
            if (degree === 0 || coefficient !== 1) {
              const alphaPower = this.field.log(coefficient);
              if (alphaPower === 0) {
                result += "1";
              } else if (alphaPower === 1) {
                result += "a";
              } else {
                result += "a^";
                result += alphaPower;
              }
            }
            if (degree !== 0) {
              if (degree === 1) {
                result += "x";
              } else {
                result += "x^";
                result += degree;
              }
            }
          }
        }
        return result;
      }
    }
    class ArithmeticException extends Exception {
    }
    ArithmeticException.kind = "ArithmeticException";
    class GenericGF extends AbstractGenericGF {
      constructor(primitive, size2, generatorBase) {
        super();
        this.primitive = primitive;
        this.size = size2;
        this.generatorBase = generatorBase;
        const expTable = new Int32Array(size2);
        let x = 1;
        for (let i2 = 0; i2 < size2; i2++) {
          expTable[i2] = x;
          x *= 2;
          if (x >= size2) {
            x ^= primitive;
            x &= size2 - 1;
          }
        }
        this.expTable = expTable;
        const logTable = new Int32Array(size2);
        for (let i2 = 0; i2 < size2 - 1; i2++) {
          logTable[expTable[i2]] = i2;
        }
        this.logTable = logTable;
        this.zero = new GenericGFPoly(this, Int32Array.from([0]));
        this.one = new GenericGFPoly(this, Int32Array.from([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        const coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly(this, coefficients);
      }
      inverse(a2) {
        if (a2 === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.size - this.logTable[a2] - 1];
      }
      multiply(a2, b) {
        if (a2 === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a2] + this.logTable[b]) % (this.size - 1)];
      }
      getSize() {
        return this.size;
      }
      getGeneratorBase() {
        return this.generatorBase;
      }
      toString() {
        return "GF(0x" + Integer.toHexString(this.primitive) + "," + this.size + ")";
      }
      equals(o2) {
        return o2 === this;
      }
    }
    GenericGF.AZTEC_DATA_12 = new GenericGF(4201, 4096, 1);
    GenericGF.AZTEC_DATA_10 = new GenericGF(1033, 1024, 1);
    GenericGF.AZTEC_DATA_6 = new GenericGF(67, 64, 1);
    GenericGF.AZTEC_PARAM = new GenericGF(19, 16, 1);
    GenericGF.QR_CODE_FIELD_256 = new GenericGF(285, 256, 0);
    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(301, 256, 1);
    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
    class ReedSolomonException extends Exception {
    }
    ReedSolomonException.kind = "ReedSolomonException";
    class IllegalStateException extends Exception {
    }
    IllegalStateException.kind = "IllegalStateException";
    class ReedSolomonDecoder {
      constructor(field) {
        this.field = field;
      }
      decode(received, twoS) {
        const field = this.field;
        const poly = new GenericGFPoly(field, received);
        const syndromeCoefficients = new Int32Array(twoS);
        let noError = true;
        for (let i2 = 0; i2 < twoS; i2++) {
          const evalResult = poly.evaluateAt(field.exp(i2 + field.getGeneratorBase()));
          syndromeCoefficients[syndromeCoefficients.length - 1 - i2] = evalResult;
          if (evalResult !== 0) {
            noError = false;
          }
        }
        if (noError) {
          return;
        }
        const syndrome = new GenericGFPoly(field, syndromeCoefficients);
        const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
        const sigma = sigmaOmega[0];
        const omega = sigmaOmega[1];
        const errorLocations = this.findErrorLocations(sigma);
        const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (let i2 = 0; i2 < errorLocations.length; i2++) {
          const position = received.length - 1 - field.log(errorLocations[i2]);
          if (position < 0) {
            throw new ReedSolomonException("Bad error location");
          }
          received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i2]);
        }
      }
      runEuclideanAlgorithm(a2, b, R) {
        if (a2.getDegree() < b.getDegree()) {
          const temp = a2;
          a2 = b;
          b = temp;
        }
        const field = this.field;
        let rLast = a2;
        let r2 = b;
        let tLast = field.getZero();
        let t2 = field.getOne();
        while (r2.getDegree() >= (R / 2 | 0)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r2;
          tLast = t2;
          if (rLast.isZero()) {
            throw new ReedSolomonException("r_{i-1} was zero");
          }
          r2 = rLastLast;
          let q = field.getZero();
          const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          const dltInverse = field.inverse(denominatorLeadingTerm);
          while (r2.getDegree() >= rLast.getDegree() && !r2.isZero()) {
            const degreeDiff = r2.getDegree() - rLast.getDegree();
            const scale = field.multiply(r2.getCoefficient(r2.getDegree()), dltInverse);
            q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
            r2 = r2.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t2 = q.multiply(tLast).addOrSubtract(tLastLast);
          if (r2.getDegree() >= rLast.getDegree()) {
            throw new IllegalStateException("Division algorithm failed to reduce polynomial?");
          }
        }
        const sigmaTildeAtZero = t2.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw new ReedSolomonException("sigmaTilde(0) was zero");
        }
        const inverse = field.inverse(sigmaTildeAtZero);
        const sigma = t2.multiplyScalar(inverse);
        const omega = r2.multiplyScalar(inverse);
        return [sigma, omega];
      }
      findErrorLocations(errorLocator) {
        const numErrors = errorLocator.getDegree();
        if (numErrors === 1) {
          return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        const result = new Int32Array(numErrors);
        let e2 = 0;
        const field = this.field;
        for (let i2 = 1; i2 < field.getSize() && e2 < numErrors; i2++) {
          if (errorLocator.evaluateAt(i2) === 0) {
            result[e2] = field.inverse(i2);
            e2++;
          }
        }
        if (e2 !== numErrors) {
          throw new ReedSolomonException("Error locator degree does not match number of roots");
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocations) {
        const s2 = errorLocations.length;
        const result = new Int32Array(s2);
        const field = this.field;
        for (let i2 = 0; i2 < s2; i2++) {
          const xiInverse = field.inverse(errorLocations[i2]);
          let denominator = 1;
          for (let j = 0; j < s2; j++) {
            if (i2 !== j) {
              const term = field.multiply(errorLocations[j], xiInverse);
              const termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
              denominator = field.multiply(denominator, termPlus1);
            }
          }
          result[i2] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
          if (field.getGeneratorBase() !== 0) {
            result[i2] = field.multiply(result[i2], xiInverse);
          }
        }
        return result;
      }
    }
    var Table;
    (function(Table2) {
      Table2[Table2["UPPER"] = 0] = "UPPER";
      Table2[Table2["LOWER"] = 1] = "LOWER";
      Table2[Table2["MIXED"] = 2] = "MIXED";
      Table2[Table2["DIGIT"] = 3] = "DIGIT";
      Table2[Table2["PUNCT"] = 4] = "PUNCT";
      Table2[Table2["BINARY"] = 5] = "BINARY";
    })(Table || (Table = {}));
    class Decoder {
      decode(detectorResult) {
        this.ddata = detectorResult;
        let matrix = detectorResult.getBits();
        let rawbits = this.extractBits(matrix);
        let correctedBits = this.correctBits(rawbits);
        let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);
        let result = Decoder.getEncodedData(correctedBits);
        let decoderResult = new DecoderResult(rawBytes, result, null, null);
        decoderResult.setNumBits(correctedBits.length);
        return decoderResult;
      }
      static highLevelDecode(correctedBits) {
        return this.getEncodedData(correctedBits);
      }
      static getEncodedData(correctedBits) {
        let endIndex = correctedBits.length;
        let latchTable = Table.UPPER;
        let shiftTable = Table.UPPER;
        let result = "";
        let index = 0;
        while (index < endIndex) {
          if (shiftTable === Table.BINARY) {
            if (endIndex - index < 5) {
              break;
            }
            let length = Decoder.readCode(correctedBits, index, 5);
            index += 5;
            if (length === 0) {
              if (endIndex - index < 11) {
                break;
              }
              length = Decoder.readCode(correctedBits, index, 11) + 31;
              index += 11;
            }
            for (let charCount = 0; charCount < length; charCount++) {
              if (endIndex - index < 8) {
                index = endIndex;
                break;
              }
              const code = Decoder.readCode(correctedBits, index, 8);
              result += StringUtils.castAsNonUtf8Char(code);
              index += 8;
            }
            shiftTable = latchTable;
          } else {
            let size2 = shiftTable === Table.DIGIT ? 4 : 5;
            if (endIndex - index < size2) {
              break;
            }
            let code = Decoder.readCode(correctedBits, index, size2);
            index += size2;
            let str = Decoder.getCharacter(shiftTable, code);
            if (str.startsWith("CTRL_")) {
              latchTable = shiftTable;
              shiftTable = Decoder.getTable(str.charAt(5));
              if (str.charAt(6) === "L") {
                latchTable = shiftTable;
              }
            } else {
              result += str;
              shiftTable = latchTable;
            }
          }
        }
        return result;
      }
      static getTable(t2) {
        switch (t2) {
          case "L":
            return Table.LOWER;
          case "P":
            return Table.PUNCT;
          case "M":
            return Table.MIXED;
          case "D":
            return Table.DIGIT;
          case "B":
            return Table.BINARY;
          case "U":
          default:
            return Table.UPPER;
        }
      }
      static getCharacter(table, code) {
        switch (table) {
          case Table.UPPER:
            return Decoder.UPPER_TABLE[code];
          case Table.LOWER:
            return Decoder.LOWER_TABLE[code];
          case Table.MIXED:
            return Decoder.MIXED_TABLE[code];
          case Table.PUNCT:
            return Decoder.PUNCT_TABLE[code];
          case Table.DIGIT:
            return Decoder.DIGIT_TABLE[code];
          default:
            throw new IllegalStateException("Bad table");
        }
      }
      correctBits(rawbits) {
        let gf;
        let codewordSize;
        if (this.ddata.getNbLayers() <= 2) {
          codewordSize = 6;
          gf = GenericGF.AZTEC_DATA_6;
        } else if (this.ddata.getNbLayers() <= 8) {
          codewordSize = 8;
          gf = GenericGF.AZTEC_DATA_8;
        } else if (this.ddata.getNbLayers() <= 22) {
          codewordSize = 10;
          gf = GenericGF.AZTEC_DATA_10;
        } else {
          codewordSize = 12;
          gf = GenericGF.AZTEC_DATA_12;
        }
        let numDataCodewords = this.ddata.getNbDatablocks();
        let numCodewords = rawbits.length / codewordSize;
        if (numCodewords < numDataCodewords) {
          throw new FormatException();
        }
        let offset = rawbits.length % codewordSize;
        let dataWords = new Int32Array(numCodewords);
        for (let i2 = 0; i2 < numCodewords; i2++, offset += codewordSize) {
          dataWords[i2] = Decoder.readCode(rawbits, offset, codewordSize);
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(gf);
          rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
        } catch (ex) {
          throw new FormatException(ex);
        }
        let mask = (1 << codewordSize) - 1;
        let stuffedBits = 0;
        for (let i2 = 0; i2 < numDataCodewords; i2++) {
          let dataWord = dataWords[i2];
          if (dataWord === 0 || dataWord === mask) {
            throw new FormatException();
          } else if (dataWord === 1 || dataWord === mask - 1) {
            stuffedBits++;
          }
        }
        let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
        let index = 0;
        for (let i2 = 0; i2 < numDataCodewords; i2++) {
          let dataWord = dataWords[i2];
          if (dataWord === 1 || dataWord === mask - 1) {
            correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
            index += codewordSize - 1;
          } else {
            for (let bit = codewordSize - 1; bit >= 0; --bit) {
              correctedBits[index++] = (dataWord & 1 << bit) !== 0;
            }
          }
        }
        return correctedBits;
      }
      extractBits(matrix) {
        let compact = this.ddata.isCompact();
        let layers = this.ddata.getNbLayers();
        let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let rawbits = new Array(this.totalBitsInLayer(layers, compact));
        if (compact) {
          for (let i2 = 0; i2 < alignmentMap.length; i2++) {
            alignmentMap[i2] = i2;
          }
        } else {
          let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = baseMatrixSize / 2;
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i2 = 0; i2 < origCenter; i2++) {
            let newOffset = i2 + Integer.truncDivision(i2, 15);
            alignmentMap[origCenter - i2 - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i2] = center + newOffset + 1;
          }
        }
        for (let i2 = 0, rowOffset = 0; i2 < layers; i2++) {
          let rowSize = (layers - i2) * 4 + (compact ? 9 : 12);
          let low = i2 * 2;
          let high = baseMatrixSize - 1 - low;
          for (let j = 0; j < rowSize; j++) {
            let columnOffset = j * 2;
            for (let k = 0; k < 2; k++) {
              rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
              rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
              rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
              rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
            }
          }
          rowOffset += rowSize * 8;
        }
        return rawbits;
      }
      static readCode(rawbits, startIndex, length) {
        let res = 0;
        for (let i2 = startIndex; i2 < startIndex + length; i2++) {
          res <<= 1;
          if (rawbits[i2]) {
            res |= 1;
          }
        }
        return res;
      }
      static readByte(rawbits, startIndex) {
        let n2 = rawbits.length - startIndex;
        if (n2 >= 8) {
          return Decoder.readCode(rawbits, startIndex, 8);
        }
        return Decoder.readCode(rawbits, startIndex, n2) << 8 - n2;
      }
      static convertBoolArrayToByteArray(boolArr) {
        let byteArr = new Uint8Array((boolArr.length + 7) / 8);
        for (let i2 = 0; i2 < byteArr.length; i2++) {
          byteArr[i2] = Decoder.readByte(boolArr, 8 * i2);
        }
        return byteArr;
      }
      totalBitsInLayer(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Decoder.UPPER_TABLE = [
      "CTRL_PS",
      " ",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "CTRL_LL",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder.LOWER_TABLE = [
      "CTRL_PS",
      " ",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "CTRL_US",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder.MIXED_TABLE = [
      "CTRL_PS",
      " ",
      "\\1",
      "\\2",
      "\\3",
      "\\4",
      "\\5",
      "\\6",
      "\\7",
      "\b",
      "	",
      "\n",
      "\\13",
      "\f",
      "\r",
      "\\33",
      "\\34",
      "\\35",
      "\\36",
      "\\37",
      "@",
      "\\",
      "^",
      "_",
      "`",
      "|",
      "~",
      "\\177",
      "CTRL_LL",
      "CTRL_UL",
      "CTRL_PL",
      "CTRL_BS"
    ];
    Decoder.PUNCT_TABLE = [
      "",
      "\r",
      "\r\n",
      ". ",
      ", ",
      ": ",
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "[",
      "]",
      "{",
      "}",
      "CTRL_UL"
    ];
    Decoder.DIGIT_TABLE = [
      "CTRL_PS",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ",",
      ".",
      "CTRL_UL",
      "CTRL_US"
    ];
    class MathUtils {
      constructor() {
      }
      static round(d) {
        if (NaN === d)
          return 0;
        if (d <= Number.MIN_SAFE_INTEGER)
          return Number.MIN_SAFE_INTEGER;
        if (d >= Number.MAX_SAFE_INTEGER)
          return Number.MAX_SAFE_INTEGER;
        return d + (d < 0 ? -0.5 : 0.5) | 0;
      }
      static distance(aX, aY, bX, bY) {
        const xDiff = aX - bX;
        const yDiff = aY - bY;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
      }
      static sum(array) {
        let count = 0;
        for (let i2 = 0, length = array.length; i2 !== length; i2++) {
          const a2 = array[i2];
          count += a2;
        }
        return count;
      }
    }
    class Float {
      static floatToIntBits(f2) {
        return f2;
      }
    }
    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class ResultPoint {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
      equals(other) {
        if (other instanceof ResultPoint) {
          const otherPoint = other;
          return this.x === otherPoint.x && this.y === otherPoint.y;
        }
        return false;
      }
      hashCode() {
        return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
      }
      toString() {
        return "(" + this.x + "," + this.y + ")";
      }
      static orderBestPatterns(patterns) {
        const zeroOneDistance = this.distance(patterns[0], patterns[1]);
        const oneTwoDistance = this.distance(patterns[1], patterns[2]);
        const zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        let pointA;
        let pointB;
        let pointC;
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
          pointB = patterns[0];
          pointA = patterns[1];
          pointC = patterns[2];
        } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
          pointB = patterns[1];
          pointA = patterns[0];
          pointC = patterns[2];
        } else {
          pointB = patterns[2];
          pointA = patterns[0];
          pointC = patterns[1];
        }
        if (this.crossProductZ(pointA, pointB, pointC) < 0) {
          const temp = pointA;
          pointA = pointC;
          pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
      }
      static distance(pattern1, pattern2) {
        return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
      }
      static crossProductZ(pointA, pointB, pointC) {
        const bX = pointB.x;
        const bY = pointB.y;
        return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
      }
    }
    class DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class AztecDetectorResult extends DetectorResult {
      constructor(bits, points, compact, nbDatablocks, nbLayers) {
        super(bits, points);
        this.compact = compact;
        this.nbDatablocks = nbDatablocks;
        this.nbLayers = nbLayers;
      }
      getNbLayers() {
        return this.nbLayers;
      }
      getNbDatablocks() {
        return this.nbDatablocks;
      }
      isCompact() {
        return this.compact;
      }
    }
    class WhiteRectangleDetector {
      constructor(image, initSize, x, y) {
        this.image = image;
        this.height = image.getHeight();
        this.width = image.getWidth();
        if (void 0 === initSize || null === initSize) {
          initSize = WhiteRectangleDetector.INIT_SIZE;
        }
        if (void 0 === x || null === x) {
          x = image.getWidth() / 2 | 0;
        }
        if (void 0 === y || null === y) {
          y = image.getHeight() / 2 | 0;
        }
        const halfsize = initSize / 2 | 0;
        this.leftInit = x - halfsize;
        this.rightInit = x + halfsize;
        this.upInit = y - halfsize;
        this.downInit = y + halfsize;
        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
          throw new NotFoundException();
        }
      }
      detect() {
        let left = this.leftInit;
        let right = this.rightInit;
        let up = this.upInit;
        let down = this.downInit;
        let sizeExceeded = false;
        let aBlackPointFoundOnBorder = true;
        let atLeastOneBlackPointFoundOnBorder = false;
        let atLeastOneBlackPointFoundOnRight = false;
        let atLeastOneBlackPointFoundOnBottom = false;
        let atLeastOneBlackPointFoundOnLeft = false;
        let atLeastOneBlackPointFoundOnTop = false;
        const width = this.width;
        const height = this.height;
        while (aBlackPointFoundOnBorder) {
          aBlackPointFoundOnBorder = false;
          let rightBorderNotWhite = true;
          while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
            rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
            if (rightBorderNotWhite) {
              right++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnRight = true;
            } else if (!atLeastOneBlackPointFoundOnRight) {
              right++;
            }
          }
          if (right >= width) {
            sizeExceeded = true;
            break;
          }
          let bottomBorderNotWhite = true;
          while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
            bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
            if (bottomBorderNotWhite) {
              down++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnBottom = true;
            } else if (!atLeastOneBlackPointFoundOnBottom) {
              down++;
            }
          }
          if (down >= height) {
            sizeExceeded = true;
            break;
          }
          let leftBorderNotWhite = true;
          while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
            leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
            if (leftBorderNotWhite) {
              left--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnLeft = true;
            } else if (!atLeastOneBlackPointFoundOnLeft) {
              left--;
            }
          }
          if (left < 0) {
            sizeExceeded = true;
            break;
          }
          let topBorderNotWhite = true;
          while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
            topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
            if (topBorderNotWhite) {
              up--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnTop = true;
            } else if (!atLeastOneBlackPointFoundOnTop) {
              up--;
            }
          }
          if (up < 0) {
            sizeExceeded = true;
            break;
          }
          if (aBlackPointFoundOnBorder) {
            atLeastOneBlackPointFoundOnBorder = true;
          }
        }
        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
          const maxSize = right - left;
          let z = null;
          for (let i2 = 1; z === null && i2 < maxSize; i2++) {
            z = this.getBlackPointOnSegment(left, down - i2, left + i2, down);
          }
          if (z == null) {
            throw new NotFoundException();
          }
          let t2 = null;
          for (let i2 = 1; t2 === null && i2 < maxSize; i2++) {
            t2 = this.getBlackPointOnSegment(left, up + i2, left + i2, up);
          }
          if (t2 == null) {
            throw new NotFoundException();
          }
          let x = null;
          for (let i2 = 1; x === null && i2 < maxSize; i2++) {
            x = this.getBlackPointOnSegment(right, up + i2, right - i2, up);
          }
          if (x == null) {
            throw new NotFoundException();
          }
          let y = null;
          for (let i2 = 1; y === null && i2 < maxSize; i2++) {
            y = this.getBlackPointOnSegment(right, down - i2, right - i2, down);
          }
          if (y == null) {
            throw new NotFoundException();
          }
          return this.centerEdges(y, z, x, t2);
        } else {
          throw new NotFoundException();
        }
      }
      getBlackPointOnSegment(aX, aY, bX, bY) {
        const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
        const xStep = (bX - aX) / dist;
        const yStep = (bY - aY) / dist;
        const image = this.image;
        for (let i2 = 0; i2 < dist; i2++) {
          const x = MathUtils.round(aX + i2 * xStep);
          const y = MathUtils.round(aY + i2 * yStep);
          if (image.get(x, y)) {
            return new ResultPoint(x, y);
          }
        }
        return null;
      }
      centerEdges(y, z, x, t2) {
        const yi = y.getX();
        const yj = y.getY();
        const zi = z.getX();
        const zj = z.getY();
        const xi = x.getX();
        const xj = x.getY();
        const ti = t2.getX();
        const tj = t2.getY();
        const CORR = WhiteRectangleDetector.CORR;
        if (yi < this.width / 2) {
          return [
            new ResultPoint(ti - CORR, tj + CORR),
            new ResultPoint(zi + CORR, zj + CORR),
            new ResultPoint(xi - CORR, xj - CORR),
            new ResultPoint(yi + CORR, yj - CORR)
          ];
        } else {
          return [
            new ResultPoint(ti + CORR, tj + CORR),
            new ResultPoint(zi + CORR, zj - CORR),
            new ResultPoint(xi - CORR, xj + CORR),
            new ResultPoint(yi - CORR, yj - CORR)
          ];
        }
      }
      containsBlackPoint(a2, b, fixed, horizontal) {
        const image = this.image;
        if (horizontal) {
          for (let x = a2; x <= b; x++) {
            if (image.get(x, fixed)) {
              return true;
            }
          }
        } else {
          for (let y = a2; y <= b; y++) {
            if (image.get(fixed, y)) {
              return true;
            }
          }
        }
        return false;
      }
    }
    WhiteRectangleDetector.INIT_SIZE = 10;
    WhiteRectangleDetector.CORR = 1;
    class GridSampler {
      static checkAndNudgePoints(image, points) {
        const width = image.getWidth();
        const height = image.getHeight();
        let nudged = true;
        for (let offset = 0; offset < points.length && nudged; offset += 2) {
          const x = Math.floor(points[offset]);
          const y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x === -1) {
            points[offset] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset + 1] = height - 1;
            nudged = true;
          }
        }
        nudged = true;
        for (let offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
          const x = Math.floor(points[offset]);
          const y = Math.floor(points[offset + 1]);
          if (x < -1 || x > width || y < -1 || y > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x === -1) {
            points[offset] = 0;
            nudged = true;
          } else if (x === width) {
            points[offset] = width - 1;
            nudged = true;
          }
          if (y === -1) {
            points[offset + 1] = 0;
            nudged = true;
          } else if (y === height) {
            points[offset + 1] = height - 1;
            nudged = true;
          }
        }
      }
    }
    class PerspectiveTransform {
      constructor(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
        this.a11 = a11;
        this.a21 = a21;
        this.a31 = a31;
        this.a12 = a12;
        this.a22 = a22;
        this.a32 = a32;
        this.a13 = a13;
        this.a23 = a23;
        this.a33 = a33;
      }
      static quadrilateralToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
        const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
      }
      transformPoints(points) {
        const max = points.length;
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        for (let i2 = 0; i2 < max; i2 += 2) {
          const x = points[i2];
          const y = points[i2 + 1];
          const denominator = a13 * x + a23 * y + a33;
          points[i2] = (a11 * x + a21 * y + a31) / denominator;
          points[i2 + 1] = (a12 * x + a22 * y + a32) / denominator;
        }
      }
      transformPointsWithValues(xValues, yValues) {
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        const n2 = xValues.length;
        for (let i2 = 0; i2 < n2; i2++) {
          const x = xValues[i2];
          const y = yValues[i2];
          const denominator = a13 * x + a23 * y + a33;
          xValues[i2] = (a11 * x + a21 * y + a31) / denominator;
          yValues[i2] = (a12 * x + a22 * y + a32) / denominator;
        }
      }
      static squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3) {
        const dx3 = x0 - x1 + x2 - x3;
        const dy3 = y0 - y1 + y2 - y3;
        if (dx3 === 0 && dy3 === 0) {
          return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
        } else {
          const dx1 = x1 - x2;
          const dx2 = x3 - x2;
          const dy1 = y1 - y2;
          const dy2 = y3 - y2;
          const denominator = dx1 * dy2 - dx2 * dy1;
          const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
          const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
          return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
        }
      }
      static quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3) {
        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
      }
      buildAdjoint() {
        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
      }
      times(other) {
        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
      }
    }
    class DefaultGridSampler extends GridSampler {
      sampleGrid(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
        const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
      }
      sampleGridWithTransform(image, dimensionX, dimensionY, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
          throw new NotFoundException();
        }
        const bits = new BitMatrix(dimensionX, dimensionY);
        const points = new Float32Array(2 * dimensionX);
        for (let y = 0; y < dimensionY; y++) {
          const max = points.length;
          const iValue = y + 0.5;
          for (let x = 0; x < max; x += 2) {
            points[x] = x / 2 + 0.5;
            points[x + 1] = iValue;
          }
          transform.transformPoints(points);
          GridSampler.checkAndNudgePoints(image, points);
          try {
            for (let x = 0; x < max; x += 2) {
              if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                bits.set(x / 2, y);
              }
            }
          } catch (aioobe) {
            throw new NotFoundException();
          }
        }
        return bits;
      }
    }
    class GridSamplerInstance {
      static setGridSampler(newGridSampler) {
        GridSamplerInstance.gridSampler = newGridSampler;
      }
      static getInstance() {
        return GridSamplerInstance.gridSampler;
      }
    }
    GridSamplerInstance.gridSampler = new DefaultGridSampler();
    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      toResultPoint() {
        return new ResultPoint(this.getX(), this.getY());
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
    }
    class Detector {
      constructor(image) {
        this.EXPECTED_CORNER_BITS = new Int32Array([
          3808,
          476,
          2107,
          1799
        ]);
        this.image = image;
      }
      detect() {
        return this.detectMirror(false);
      }
      detectMirror(isMirror) {
        let pCenter = this.getMatrixCenter();
        let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
        if (isMirror) {
          let temp = bullsEyeCorners[0];
          bullsEyeCorners[0] = bullsEyeCorners[2];
          bullsEyeCorners[2] = temp;
        }
        this.extractParameters(bullsEyeCorners);
        let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
        let corners = this.getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
      }
      extractParameters(bullsEyeCorners) {
        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
          throw new NotFoundException();
        }
        let length = 2 * this.nbCenterLayers;
        let sides = new Int32Array([
          this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
          this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
          this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
          this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
        ]);
        this.shift = this.getRotation(sides, length);
        let parameterData = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          let side = sides[(this.shift + i2) % 4];
          if (this.compact) {
            parameterData <<= 7;
            parameterData += side >> 1 & 127;
          } else {
            parameterData <<= 10;
            parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
          }
        }
        let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
        if (this.compact) {
          this.nbLayers = (correctedData >> 6) + 1;
          this.nbDataBlocks = (correctedData & 63) + 1;
        } else {
          this.nbLayers = (correctedData >> 11) + 1;
          this.nbDataBlocks = (correctedData & 2047) + 1;
        }
      }
      getRotation(sides, length) {
        let cornerBits = 0;
        sides.forEach((side, idx, arr) => {
          let t2 = (side >> length - 2 << 1) + (side & 1);
          cornerBits = (cornerBits << 3) + t2;
        });
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        for (let shift = 0; shift < 4; shift++) {
          if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
            return shift;
          }
        }
        throw new NotFoundException();
      }
      getCorrectedParameterData(parameterData, compact) {
        let numCodewords;
        let numDataCodewords;
        if (compact) {
          numCodewords = 7;
          numDataCodewords = 2;
        } else {
          numCodewords = 10;
          numDataCodewords = 4;
        }
        let numECCodewords = numCodewords - numDataCodewords;
        let parameterWords = new Int32Array(numCodewords);
        for (let i2 = numCodewords - 1; i2 >= 0; --i2) {
          parameterWords[i2] = parameterData & 15;
          parameterData >>= 4;
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
          rsDecoder.decode(parameterWords, numECCodewords);
        } catch (ignored) {
          throw new NotFoundException();
        }
        let result = 0;
        for (let i2 = 0; i2 < numDataCodewords; i2++) {
          result = (result << 4) + parameterWords[i2];
        }
        return result;
      }
      getBullsEyeCorners(pCenter) {
        let pina = pCenter;
        let pinb = pCenter;
        let pinc = pCenter;
        let pind = pCenter;
        let color = true;
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          let pouta = this.getFirstDifferent(pina, color, 1, -1);
          let poutb = this.getFirstDifferent(pinb, color, 1, 1);
          let poutc = this.getFirstDifferent(pinc, color, -1, 1);
          let poutd = this.getFirstDifferent(pind, color, -1, -1);
          if (this.nbCenterLayers > 2) {
            let q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
            if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
              break;
            }
          }
          pina = pouta;
          pinb = poutb;
          pinc = poutc;
          pind = poutd;
          color = !color;
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
          throw new NotFoundException();
        }
        this.compact = this.nbCenterLayers === 5;
        let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
        let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
        let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
        let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
      }
      getMatrixCenter() {
        let pointA;
        let pointB;
        let pointC;
        let pointD;
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e2) {
          let cx2 = this.image.getWidth() / 2;
          let cy2 = this.image.getHeight() / 2;
          pointA = this.getFirstDifferent(new Point(cx2 + 7, cy2 - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx2 + 7, cy2 + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx2 - 7, cy2 + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx2 - 7, cy2 - 7), false, -1, -1).toResultPoint();
        }
        let cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx, cy).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e2) {
          pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        return new Point(cx, cy);
      }
      getMatrixCornerPoints(bullsEyeCorners) {
        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
      }
      sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
        let sampler = GridSamplerInstance.getInstance();
        let dimension = this.getDimension();
        let low = dimension / 2 - this.nbCenterLayers;
        let high = dimension / 2 + this.nbCenterLayers;
        return sampler.sampleGrid(
          image,
          dimension,
          dimension,
          low,
          low,
          high,
          low,
          high,
          high,
          low,
          high,
          topLeft.getX(),
          topLeft.getY(),
          topRight.getX(),
          topRight.getY(),
          bottomRight.getX(),
          bottomRight.getY(),
          bottomLeft.getX(),
          bottomLeft.getY()
        );
      }
      sampleLine(p1, p2, size2) {
        let result = 0;
        let d = this.distanceResultPoint(p1, p2);
        let moduleSize = d / size2;
        let px = p1.getX();
        let py = p1.getY();
        let dx = moduleSize * (p2.getX() - p1.getX()) / d;
        let dy = moduleSize * (p2.getY() - p1.getY()) / d;
        for (let i2 = 0; i2 < size2; i2++) {
          if (this.image.get(MathUtils.round(px + i2 * dx), MathUtils.round(py + i2 * dy))) {
            result |= 1 << size2 - i2 - 1;
          }
        }
        return result;
      }
      isWhiteOrBlackRectangle(p1, p2, p3, p4) {
        let corr = 3;
        p1 = new Point(p1.getX() - corr, p1.getY() + corr);
        p2 = new Point(p2.getX() - corr, p2.getY() - corr);
        p3 = new Point(p3.getX() + corr, p3.getY() - corr);
        p4 = new Point(p4.getX() + corr, p4.getY() + corr);
        let cInit = this.getColor(p4, p1);
        if (cInit === 0) {
          return false;
        }
        let c2 = this.getColor(p1, p2);
        if (c2 !== cInit) {
          return false;
        }
        c2 = this.getColor(p2, p3);
        if (c2 !== cInit) {
          return false;
        }
        c2 = this.getColor(p3, p4);
        return c2 === cInit;
      }
      getColor(p1, p2) {
        let d = this.distancePoint(p1, p2);
        let dx = (p2.getX() - p1.getX()) / d;
        let dy = (p2.getY() - p1.getY()) / d;
        let error = 0;
        let px = p1.getX();
        let py = p1.getY();
        let colorModel = this.image.get(p1.getX(), p1.getY());
        let iMax = Math.ceil(d);
        for (let i2 = 0; i2 < iMax; i2++) {
          px += dx;
          py += dy;
          if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
            error++;
          }
        }
        let errRatio = error / d;
        if (errRatio > 0.1 && errRatio < 0.9) {
          return 0;
        }
        return errRatio <= 0.1 === colorModel ? 1 : -1;
      }
      getFirstDifferent(init, color, dx, dy) {
        let x = init.getX() + dx;
        let y = init.getY() + dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
          y += dy;
        }
        x -= dx;
        y -= dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          x += dx;
        }
        x -= dx;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
          y += dy;
        }
        y -= dy;
        return new Point(x, y);
      }
      expandSquare(cornerPoints, oldSide, newSide) {
        let ratio = newSide / (2 * oldSide);
        let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
        let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
        let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
        let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        let results = [result0, result1, result2, result3];
        return results;
      }
      isValid(x, y) {
        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
      }
      isValidPoint(point) {
        let x = MathUtils.round(point.getX());
        let y = MathUtils.round(point.getY());
        return this.isValid(x, y);
      }
      distancePoint(a2, b) {
        return MathUtils.distance(a2.getX(), a2.getY(), b.getX(), b.getY());
      }
      distanceResultPoint(a2, b) {
        return MathUtils.distance(a2.getX(), a2.getY(), b.getX(), b.getY());
      }
      getDimension() {
        if (this.compact) {
          return 4 * this.nbLayers + 11;
        }
        if (this.nbLayers <= 4) {
          return 4 * this.nbLayers + 15;
        }
        return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
      }
    }
    class AztecReader {
      decode(image, hints = null) {
        let exception = null;
        let detector = new Detector(image.getBlackMatrix());
        let points = null;
        let decoderResult = null;
        try {
          let detectorResult = detector.detectMirror(false);
          points = detectorResult.getPoints();
          this.reportFoundResultPoints(hints, points);
          decoderResult = new Decoder().decode(detectorResult);
        } catch (e2) {
          exception = e2;
        }
        if (decoderResult == null) {
          try {
            let detectorResult = detector.detectMirror(true);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder().decode(detectorResult);
          } catch (e2) {
            if (exception != null) {
              throw exception;
            }
            throw e2;
          }
        }
        let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
        let byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        let ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      reportFoundResultPoints(hints, points) {
        if (hints != null) {
          let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (rpcb != null) {
            points.forEach((point, idx, arr) => {
              rpcb.foundPossibleResultPoint(point);
            });
          }
        }
      }
      reset() {
      }
    }
    class BrowserAztecCodeReader extends BrowserCodeReader {
      constructor(timeBetweenScansMillis = 500) {
        super(new AztecReader(), timeBetweenScansMillis);
      }
    }
    class OneDReader {
      decode(image, hints) {
        try {
          return this.doDecode(image, hints);
        } catch (nfe) {
          const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
          if (tryHarder && image.isRotateSupported()) {
            const rotatedImage = image.rotateCounterClockwise();
            const result = this.doDecode(rotatedImage, hints);
            const metadata = result.getResultMetadata();
            let orientation = 270;
            if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {
              orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;
            }
            result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
            const points = result.getResultPoints();
            if (points !== null) {
              const height = rotatedImage.getHeight();
              for (let i2 = 0; i2 < points.length; i2++) {
                points[i2] = new ResultPoint(height - points[i2].getY() - 1, points[i2].getX());
              }
            }
            return result;
          } else {
            throw new NotFoundException();
          }
        }
      }
      reset() {
      }
      doDecode(image, hints) {
        const width = image.getWidth();
        const height = image.getHeight();
        let row = new BitArray(width);
        const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
        const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
        let maxLines;
        if (tryHarder) {
          maxLines = height;
        } else {
          maxLines = 15;
        }
        const middle = Math.trunc(height / 2);
        for (let x = 0; x < maxLines; x++) {
          const rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
          const isAbove = (x & 1) === 0;
          const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
          if (rowNumber < 0 || rowNumber >= height) {
            break;
          }
          try {
            row = image.getBlackRow(rowNumber, row);
          } catch (ignored) {
            continue;
          }
          for (let attempt = 0; attempt < 2; attempt++) {
            if (attempt === 1) {
              row.reverse();
              if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {
                const newHints = /* @__PURE__ */ new Map();
                hints.forEach((hint, key) => newHints.set(key, hint));
                newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                hints = newHints;
              }
            }
            try {
              const result = this.decodeRow(rowNumber, row, hints);
              if (attempt === 1) {
                result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                const points = result.getResultPoints();
                if (points !== null) {
                  points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                  points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                }
              }
              return result;
            } catch (re) {
            }
          }
        }
        throw new NotFoundException();
      }
      static recordPattern(row, start, counters) {
        const numCounters = counters.length;
        for (let index = 0; index < numCounters; index++)
          counters[index] = 0;
        const end = row.getSize();
        if (start >= end) {
          throw new NotFoundException();
        }
        let isWhite = !row.get(start);
        let counterPosition = 0;
        let i2 = start;
        while (i2 < end) {
          if (row.get(i2) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (++counterPosition === numCounters) {
              break;
            } else {
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          i2++;
        }
        if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i2 === end)) {
          throw new NotFoundException();
        }
      }
      static recordPatternInReverse(row, start, counters) {
        let numTransitionsLeft = counters.length;
        let last = row.get(start);
        while (start > 0 && numTransitionsLeft >= 0) {
          if (row.get(--start) !== last) {
            numTransitionsLeft--;
            last = !last;
          }
        }
        if (numTransitionsLeft >= 0) {
          throw new NotFoundException();
        }
        OneDReader.recordPattern(row, start + 1, counters);
      }
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        const numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i2 = 0; i2 < numCounters; i2++) {
          total += counters[i2];
          patternLength += pattern[i2];
        }
        if (total < patternLength) {
          return Number.POSITIVE_INFINITY;
        }
        const unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x = 0; x < numCounters; x++) {
          const counter = counters[x];
          const scaledPattern = pattern[x] * unitBarWidth;
          const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return Number.POSITIVE_INFINITY;
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    class Code128Reader extends OneDReader {
      static findStartPattern(row) {
        const width = row.getSize();
        const rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let patternStart = rowOffset;
        let isWhite = false;
        const patternLength = 6;
        for (let i2 = rowOffset; i2 < width; i2++) {
          if (row.get(i2) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
              let bestMatch = -1;
              for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                  bestVariance = variance;
                  bestMatch = startCode;
                }
              }
              if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i2 - patternStart) / 2), patternStart, false)) {
                return Int32Array.from([patternStart, i2, bestMatch]);
              }
              patternStart += counters[0] + counters[1];
              counters = counters.slice(2, counters.length - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeCode(row, counters, rowOffset) {
        OneDReader.recordPattern(row, rowOffset, counters);
        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        for (let d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {
          const pattern = Code128Reader.CODE_PATTERNS[d];
          const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = d;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
      decodeRow(rowNumber, row, hints) {
        const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;
        const startPatternInfo = Code128Reader.findStartPattern(row);
        const startCode = startPatternInfo[2];
        let currentRawCodesIndex = 0;
        const rawCodes = new Uint8Array(20);
        rawCodes[currentRawCodesIndex++] = startCode;
        let codeSet;
        switch (startCode) {
          case Code128Reader.CODE_START_A:
            codeSet = Code128Reader.CODE_CODE_A;
            break;
          case Code128Reader.CODE_START_B:
            codeSet = Code128Reader.CODE_CODE_B;
            break;
          case Code128Reader.CODE_START_C:
            codeSet = Code128Reader.CODE_CODE_C;
            break;
          default:
            throw new FormatException();
        }
        let done = false;
        let isNextShifted = false;
        let result = "";
        let lastStart = startPatternInfo[0];
        let nextStart = startPatternInfo[1];
        const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let lastCode = 0;
        let code = 0;
        let checksumTotal = startCode;
        let multiplier = 0;
        let lastCharacterWasPrintable = true;
        let upperMode = false;
        let shiftUpperMode = false;
        while (!done) {
          const unshift = isNextShifted;
          isNextShifted = false;
          lastCode = code;
          code = Code128Reader.decodeCode(row, counters, nextStart);
          rawCodes[currentRawCodesIndex++] = code;
          if (code !== Code128Reader.CODE_STOP) {
            lastCharacterWasPrintable = true;
          }
          if (code !== Code128Reader.CODE_STOP) {
            multiplier++;
            checksumTotal += multiplier * code;
          }
          lastStart = nextStart;
          nextStart += counters.reduce((previous, current) => previous + current, 0);
          switch (code) {
            case Code128Reader.CODE_START_A:
            case Code128Reader.CODE_START_B:
            case Code128Reader.CODE_START_C:
              throw new FormatException();
          }
          switch (codeSet) {
            case Code128Reader.CODE_CODE_A:
              if (code < 64) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(code - 64);
                } else {
                  result += String.fromCharCode(code + 64);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_A:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_B:
              if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_B:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_C:
              if (code < 100) {
                if (code < 10) {
                  result += "0";
                }
                result += code;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
          }
          if (unshift) {
            codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
          }
        }
        const lastPatternSize = nextStart - lastStart;
        nextStart = row.getNextUnset(nextStart);
        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
          throw new NotFoundException();
        }
        checksumTotal -= multiplier * lastCode;
        if (checksumTotal % 103 !== lastCode) {
          throw new ChecksumException();
        }
        const resultLength = result.length;
        if (resultLength === 0) {
          throw new NotFoundException();
        }
        if (resultLength > 0 && lastCharacterWasPrintable) {
          if (codeSet === Code128Reader.CODE_CODE_C) {
            result = result.substring(0, resultLength - 2);
          } else {
            result = result.substring(0, resultLength - 1);
          }
        }
        const left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
        const right = lastStart + lastPatternSize / 2;
        const rawCodesSize = rawCodes.length;
        const rawBytes = new Uint8Array(rawCodesSize);
        for (let i2 = 0; i2 < rawCodesSize; i2++) {
          rawBytes[i2] = rawCodes[i2];
        }
        const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, new Date().getTime());
      }
    }
    Code128Reader.CODE_PATTERNS = [
      Int32Array.from([2, 1, 2, 2, 2, 2]),
      Int32Array.from([2, 2, 2, 1, 2, 2]),
      Int32Array.from([2, 2, 2, 2, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 2, 3]),
      Int32Array.from([1, 2, 1, 3, 2, 2]),
      Int32Array.from([1, 3, 1, 2, 2, 2]),
      Int32Array.from([1, 2, 2, 2, 1, 3]),
      Int32Array.from([1, 2, 2, 3, 1, 2]),
      Int32Array.from([1, 3, 2, 2, 1, 2]),
      Int32Array.from([2, 2, 1, 2, 1, 3]),
      Int32Array.from([2, 2, 1, 3, 1, 2]),
      Int32Array.from([2, 3, 1, 2, 1, 2]),
      Int32Array.from([1, 1, 2, 2, 3, 2]),
      Int32Array.from([1, 2, 2, 1, 3, 2]),
      Int32Array.from([1, 2, 2, 2, 3, 1]),
      Int32Array.from([1, 1, 3, 2, 2, 2]),
      Int32Array.from([1, 2, 3, 1, 2, 2]),
      Int32Array.from([1, 2, 3, 2, 2, 1]),
      Int32Array.from([2, 2, 3, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 3, 2]),
      Int32Array.from([2, 2, 1, 2, 3, 1]),
      Int32Array.from([2, 1, 3, 2, 1, 2]),
      Int32Array.from([2, 2, 3, 1, 1, 2]),
      Int32Array.from([3, 1, 2, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 2, 2, 2]),
      Int32Array.from([3, 2, 1, 1, 2, 2]),
      Int32Array.from([3, 2, 1, 2, 2, 1]),
      Int32Array.from([3, 1, 2, 2, 1, 2]),
      Int32Array.from([3, 2, 2, 1, 1, 2]),
      Int32Array.from([3, 2, 2, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 2, 3]),
      Int32Array.from([2, 1, 2, 3, 2, 1]),
      Int32Array.from([2, 3, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 3, 2, 3]),
      Int32Array.from([1, 3, 1, 1, 2, 3]),
      Int32Array.from([1, 3, 1, 3, 2, 1]),
      Int32Array.from([1, 1, 2, 3, 1, 3]),
      Int32Array.from([1, 3, 2, 1, 1, 3]),
      Int32Array.from([1, 3, 2, 3, 1, 1]),
      Int32Array.from([2, 1, 1, 3, 1, 3]),
      Int32Array.from([2, 3, 1, 1, 1, 3]),
      Int32Array.from([2, 3, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 3, 3]),
      Int32Array.from([1, 1, 2, 3, 3, 1]),
      Int32Array.from([1, 3, 2, 1, 3, 1]),
      Int32Array.from([1, 1, 3, 1, 2, 3]),
      Int32Array.from([1, 1, 3, 3, 2, 1]),
      Int32Array.from([1, 3, 3, 1, 2, 1]),
      Int32Array.from([3, 1, 3, 1, 2, 1]),
      Int32Array.from([2, 1, 1, 3, 3, 1]),
      Int32Array.from([2, 3, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 3, 1, 1, 3]),
      Int32Array.from([2, 1, 3, 3, 1, 1]),
      Int32Array.from([2, 1, 3, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 2, 3]),
      Int32Array.from([3, 1, 1, 3, 2, 1]),
      Int32Array.from([3, 3, 1, 1, 2, 1]),
      Int32Array.from([3, 1, 2, 1, 1, 3]),
      Int32Array.from([3, 1, 2, 3, 1, 1]),
      Int32Array.from([3, 3, 2, 1, 1, 1]),
      Int32Array.from([3, 1, 4, 1, 1, 1]),
      Int32Array.from([2, 2, 1, 4, 1, 1]),
      Int32Array.from([4, 3, 1, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2, 4]),
      Int32Array.from([1, 1, 1, 4, 2, 2]),
      Int32Array.from([1, 2, 1, 1, 2, 4]),
      Int32Array.from([1, 2, 1, 4, 2, 1]),
      Int32Array.from([1, 4, 1, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 2, 2, 1]),
      Int32Array.from([1, 1, 2, 2, 1, 4]),
      Int32Array.from([1, 1, 2, 4, 1, 2]),
      Int32Array.from([1, 2, 2, 1, 1, 4]),
      Int32Array.from([1, 2, 2, 4, 1, 1]),
      Int32Array.from([1, 4, 2, 1, 1, 2]),
      Int32Array.from([1, 4, 2, 2, 1, 1]),
      Int32Array.from([2, 4, 1, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 1, 4]),
      Int32Array.from([4, 1, 3, 1, 1, 1]),
      Int32Array.from([2, 4, 1, 1, 1, 2]),
      Int32Array.from([1, 3, 4, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 4, 2]),
      Int32Array.from([1, 2, 1, 1, 4, 2]),
      Int32Array.from([1, 2, 1, 2, 4, 1]),
      Int32Array.from([1, 1, 4, 2, 1, 2]),
      Int32Array.from([1, 2, 4, 1, 1, 2]),
      Int32Array.from([1, 2, 4, 2, 1, 1]),
      Int32Array.from([4, 1, 1, 2, 1, 2]),
      Int32Array.from([4, 2, 1, 1, 1, 2]),
      Int32Array.from([4, 2, 1, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 4, 1]),
      Int32Array.from([2, 1, 4, 1, 2, 1]),
      Int32Array.from([4, 1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 1, 4, 3]),
      Int32Array.from([1, 1, 1, 3, 4, 1]),
      Int32Array.from([1, 3, 1, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 1, 3]),
      Int32Array.from([1, 1, 4, 3, 1, 1]),
      Int32Array.from([4, 1, 1, 1, 1, 3]),
      Int32Array.from([4, 1, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 4, 1]),
      Int32Array.from([4, 1, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 1, 4, 1, 2]),
      Int32Array.from([2, 1, 1, 2, 1, 4]),
      Int32Array.from([2, 1, 1, 2, 3, 2]),
      Int32Array.from([2, 3, 3, 1, 1, 1, 2])
    ];
    Code128Reader.MAX_AVG_VARIANCE = 0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    Code128Reader.CODE_SHIFT = 98;
    Code128Reader.CODE_CODE_C = 99;
    Code128Reader.CODE_CODE_B = 100;
    Code128Reader.CODE_CODE_A = 101;
    Code128Reader.CODE_FNC_1 = 102;
    Code128Reader.CODE_FNC_2 = 97;
    Code128Reader.CODE_FNC_3 = 96;
    Code128Reader.CODE_FNC_4_A = 101;
    Code128Reader.CODE_FNC_4_B = 100;
    Code128Reader.CODE_START_A = 103;
    Code128Reader.CODE_START_B = 104;
    Code128Reader.CODE_START_C = 105;
    Code128Reader.CODE_STOP = 106;
    class Code39Reader extends OneDReader {
      constructor(usingCheckDigit = false, extendedMode = false) {
        super();
        this.usingCheckDigit = usingCheckDigit;
        this.extendedMode = extendedMode;
        this.decodeRowResult = "";
        this.counters = new Int32Array(9);
      }
      decodeRow(rowNumber, row, hints) {
        let theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = "";
        let start = Code39Reader.findAsteriskPattern(row, theCounters);
        let nextStart = row.getNextSet(start[1]);
        let end = row.getSize();
        let decodedChar;
        let lastStart;
        do {
          Code39Reader.recordPattern(row, nextStart, theCounters);
          let pattern = Code39Reader.toNarrowWidePattern(theCounters);
          if (pattern < 0) {
            throw new NotFoundException();
          }
          decodedChar = Code39Reader.patternToChar(pattern);
          this.decodeRowResult += decodedChar;
          lastStart = nextStart;
          for (let counter of theCounters) {
            nextStart += counter;
          }
          nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== "*");
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
        let lastPatternSize = 0;
        for (let counter of theCounters) {
          lastPatternSize += counter;
        }
        let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
        if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
          throw new NotFoundException();
        }
        if (this.usingCheckDigit) {
          let max = this.decodeRowResult.length - 1;
          let total = 0;
          for (let i2 = 0; i2 < max; i2++) {
            total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i2));
          }
          if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
            throw new ChecksumException();
          }
          this.decodeRowResult = this.decodeRowResult.substring(0, max);
        }
        if (this.decodeRowResult.length === 0) {
          throw new NotFoundException();
        }
        let resultString;
        if (this.extendedMode) {
          resultString = Code39Reader.decodeExtended(this.decodeRowResult);
        } else {
          resultString = this.decodeRowResult;
        }
        let left = (start[1] + start[0]) / 2;
        let right = lastStart + lastPatternSize / 2;
        return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, new Date().getTime());
      }
      static findAsteriskPattern(row, counters) {
        let width = row.getSize();
        let rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let isWhite = false;
        let patternLength = counters.length;
        for (let i2 = rowOffset; i2 < width; i2++) {
          if (row.get(i2) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i2 - patternStart) / 2)), patternStart, false)) {
                return [patternStart, i2];
              }
              patternStart += counters[0] + counters[1];
              counters.copyWithin(0, 2, 2 + counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static toNarrowWidePattern(counters) {
        let numCounters = counters.length;
        let maxNarrowCounter = 0;
        let wideCounters;
        do {
          let minCounter = 2147483647;
          for (let counter of counters) {
            if (counter < minCounter && counter > maxNarrowCounter) {
              minCounter = counter;
            }
          }
          maxNarrowCounter = minCounter;
          wideCounters = 0;
          let totalWideCountersWidth = 0;
          let pattern = 0;
          for (let i2 = 0; i2 < numCounters; i2++) {
            let counter = counters[i2];
            if (counter > maxNarrowCounter) {
              pattern |= 1 << numCounters - 1 - i2;
              wideCounters++;
              totalWideCountersWidth += counter;
            }
          }
          if (wideCounters === 3) {
            for (let i2 = 0; i2 < numCounters && wideCounters > 0; i2++) {
              let counter = counters[i2];
              if (counter > maxNarrowCounter) {
                wideCounters--;
                if (counter * 2 >= totalWideCountersWidth) {
                  return -1;
                }
              }
            }
            return pattern;
          }
        } while (wideCounters > 3);
        return -1;
      }
      static patternToChar(pattern) {
        for (let i2 = 0; i2 < Code39Reader.CHARACTER_ENCODINGS.length; i2++) {
          if (Code39Reader.CHARACTER_ENCODINGS[i2] === pattern) {
            return Code39Reader.ALPHABET_STRING.charAt(i2);
          }
        }
        if (pattern === Code39Reader.ASTERISK_ENCODING) {
          return "*";
        }
        throw new NotFoundException();
      }
      static decodeExtended(encoded) {
        let length = encoded.length;
        let decoded = "";
        for (let i2 = 0; i2 < length; i2++) {
          let c2 = encoded.charAt(i2);
          if (c2 === "+" || c2 === "$" || c2 === "%" || c2 === "/") {
            let next = encoded.charAt(i2 + 1);
            let decodedChar = "\0";
            switch (c2) {
              case "+":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                } else {
                  throw new FormatException();
                }
                break;
              case "$":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                } else {
                  throw new FormatException();
                }
                break;
              case "%":
                if (next >= "A" && next <= "E") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                } else if (next >= "F" && next <= "J") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                } else if (next >= "K" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                } else if (next >= "P" && next <= "T") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                } else if (next === "U") {
                  decodedChar = "\0";
                } else if (next === "V") {
                  decodedChar = "@";
                } else if (next === "W") {
                  decodedChar = "`";
                } else if (next === "X" || next === "Y" || next === "Z") {
                  decodedChar = "\x7F";
                } else {
                  throw new FormatException();
                }
                break;
              case "/":
                if (next >= "A" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                } else if (next === "Z") {
                  decodedChar = ":";
                } else {
                  throw new FormatException();
                }
                break;
            }
            decoded += decodedChar;
            i2++;
          } else {
            decoded += c2;
          }
        }
        return decoded;
      }
    }
    Code39Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
    Code39Reader.CHARACTER_ENCODINGS = [
      52,
      289,
      97,
      352,
      49,
      304,
      112,
      37,
      292,
      100,
      265,
      73,
      328,
      25,
      280,
      88,
      13,
      268,
      76,
      28,
      259,
      67,
      322,
      19,
      274,
      82,
      7,
      262,
      70,
      22,
      385,
      193,
      448,
      145,
      400,
      208,
      133,
      388,
      196,
      168,
      162,
      138,
      42
    ];
    Code39Reader.ASTERISK_ENCODING = 148;
    class ITFReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.narrowLineWidth = -1;
      }
      decodeRow(rowNumber, row, hints) {
        let startRange = this.decodeStart(row);
        let endRange = this.decodeEnd(row);
        let result = new StringBuilder();
        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
        let resultString = result.toString();
        let allowedLengths = null;
        if (hints != null) {
          allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
        }
        if (allowedLengths == null) {
          allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
        }
        let length = resultString.length;
        let lengthOK = false;
        let maxAllowedLength = 0;
        for (let value of allowedLengths) {
          if (length === value) {
            lengthOK = true;
            break;
          }
          if (value > maxAllowedLength) {
            maxAllowedLength = value;
          }
        }
        if (!lengthOK && length > maxAllowedLength) {
          lengthOK = true;
        }
        if (!lengthOK) {
          throw new FormatException();
        }
        const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
        let resultReturn = new Result(
          resultString,
          null,
          0,
          points,
          BarcodeFormat$1.ITF,
          new Date().getTime()
        );
        return resultReturn;
      }
      static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
        let counterDigitPair = new Int32Array(10);
        let counterBlack = new Int32Array(5);
        let counterWhite = new Int32Array(5);
        counterDigitPair.fill(0);
        counterBlack.fill(0);
        counterWhite.fill(0);
        while (payloadStart < payloadEnd) {
          OneDReader.recordPattern(row, payloadStart, counterDigitPair);
          for (let k = 0; k < 5; k++) {
            let twoK = 2 * k;
            counterBlack[k] = counterDigitPair[twoK];
            counterWhite[k] = counterDigitPair[twoK + 1];
          }
          let bestMatch = ITFReader.decodeDigit(counterBlack);
          resultString.append(bestMatch.toString());
          bestMatch = this.decodeDigit(counterWhite);
          resultString.append(bestMatch.toString());
          counterDigitPair.forEach(function(counterDigit) {
            payloadStart += counterDigit;
          });
        }
      }
      decodeStart(row) {
        let endStart = ITFReader.skipWhiteSpace(row);
        let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
        this.validateQuietZone(row, startPattern[0]);
        return startPattern;
      }
      validateQuietZone(row, startPattern) {
        let quietCount = this.narrowLineWidth * 10;
        quietCount = quietCount < startPattern ? quietCount : startPattern;
        for (let i2 = startPattern - 1; quietCount > 0 && i2 >= 0; i2--) {
          if (row.get(i2)) {
            break;
          }
          quietCount--;
        }
        if (quietCount !== 0) {
          throw new NotFoundException();
        }
      }
      static skipWhiteSpace(row) {
        const width = row.getSize();
        const endStart = row.getNextSet(0);
        if (endStart === width) {
          throw new NotFoundException();
        }
        return endStart;
      }
      decodeEnd(row) {
        row.reverse();
        try {
          let endStart = ITFReader.skipWhiteSpace(row);
          let endPattern;
          try {
            endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
          } catch (error) {
            if (error instanceof NotFoundException) {
              endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
            }
          }
          this.validateQuietZone(row, endPattern[0]);
          let temp = endPattern[0];
          endPattern[0] = row.getSize() - endPattern[1];
          endPattern[1] = row.getSize() - temp;
          return endPattern;
        } finally {
          row.reverse();
        }
      }
      static findGuardPattern(row, rowOffset, pattern) {
        let patternLength = pattern.length;
        let counters = new Int32Array(patternLength);
        let width = row.getSize();
        let isWhite = false;
        let counterPosition = 0;
        let patternStart = rowOffset;
        counters.fill(0);
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeDigit(counters) {
        let bestVariance = ITFReader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max = ITFReader.PATTERNS.length;
        for (let i2 = 0; i2 < max; i2++) {
          let pattern = ITFReader.PATTERNS[i2];
          let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i2;
          } else if (variance === bestVariance) {
            bestMatch = -1;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch % 10;
        } else {
          throw new NotFoundException();
        }
      }
    }
    ITFReader.PATTERNS = [
      Int32Array.from([1, 1, 2, 2, 1]),
      Int32Array.from([2, 1, 1, 1, 2]),
      Int32Array.from([1, 2, 1, 1, 2]),
      Int32Array.from([2, 2, 1, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 2]),
      Int32Array.from([2, 1, 2, 1, 1]),
      Int32Array.from([1, 2, 2, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2]),
      Int32Array.from([2, 1, 1, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 3, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 3]),
      Int32Array.from([1, 3, 1, 1, 3]),
      Int32Array.from([3, 3, 1, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 3]),
      Int32Array.from([3, 1, 3, 1, 1]),
      Int32Array.from([1, 3, 3, 1, 1]),
      Int32Array.from([1, 1, 1, 3, 3]),
      Int32Array.from([3, 1, 1, 3, 1]),
      Int32Array.from([1, 3, 1, 3, 1])
    ];
    ITFReader.MAX_AVG_VARIANCE = 0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
    ITFReader.END_PATTERN_REVERSED = [
      Int32Array.from([1, 1, 2]),
      Int32Array.from([1, 1, 3])
    ];
    class AbstractUPCEANReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.decodeRowStringBuffer = "";
      }
      static findStartGuardPattern(row) {
        let foundStart = false;
        let startRange;
        let nextStart = 0;
        let counters = Int32Array.from([0, 0, 0]);
        while (!foundStart) {
          counters = Int32Array.from([0, 0, 0]);
          startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
          let start = startRange[0];
          nextStart = startRange[1];
          let quietStart = start - (nextStart - start);
          if (quietStart >= 0) {
            foundStart = row.isRange(quietStart, start, false);
          }
        }
        return startRange;
      }
      static checkChecksum(s2) {
        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s2);
      }
      static checkStandardUPCEANChecksum(s2) {
        let length = s2.length;
        if (length === 0)
          return false;
        let check = parseInt(s2.charAt(length - 1), 10);
        return AbstractUPCEANReader.getStandardUPCEANChecksum(s2.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s2) {
        let length = s2.length;
        let sum = 0;
        for (let i2 = length - 1; i2 >= 0; i2 -= 2) {
          let digit = s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i2 = length - 2; i2 >= 0; i2 -= 2) {
          let digit = s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
      static decodeEnd(row, endStart) {
        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
      }
      static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
      }
      static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
        let width = row.getSize();
        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let patternLength = pattern.length;
        let isWhite = whiteFirst;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                return Int32Array.from([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              let slice = counters.slice(2, counters.length - 1);
              for (let i2 = 0; i2 < counterPosition - 1; i2++) {
                counters[i2] = slice[i2];
              }
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeDigit(row, counters, rowOffset, patterns) {
        this.recordPattern(row, rowOffset, counters);
        let bestVariance = this.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max = patterns.length;
        for (let i2 = 0; i2 < max; i2++) {
          let pattern = patterns[i2];
          let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i2;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
    }
    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    AbstractUPCEANReader.L_PATTERNS = [
      Int32Array.from([3, 2, 1, 1]),
      Int32Array.from([2, 2, 2, 1]),
      Int32Array.from([2, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 1]),
      Int32Array.from([1, 1, 3, 2]),
      Int32Array.from([1, 2, 3, 1]),
      Int32Array.from([1, 1, 1, 4]),
      Int32Array.from([1, 3, 1, 2]),
      Int32Array.from([1, 2, 1, 3]),
      Int32Array.from([3, 1, 1, 2])
    ];
    class UPCEANExtension5Support {
      constructor() {
        this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 5 && rowOffset < end; x++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 4 - x;
          }
          if (x !== 4) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 5) {
          throw new NotFoundException();
        }
        let checkDigit = this.determineCheckDigit(lgPatternFound);
        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static extensionChecksum(s2) {
        let length = s2.length;
        let sum = 0;
        for (let i2 = length - 2; i2 >= 0; i2 -= 2) {
          sum += s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        for (let i2 = length - 1; i2 >= 0; i2 -= 2) {
          sum += s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        return sum % 10;
      }
      determineCheckDigit(lgPatternFound) {
        for (let d = 0; d < 10; d++) {
          if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
            return d;
          }
        }
        throw new NotFoundException();
      }
      static parseExtensionString(raw) {
        if (raw.length !== 5) {
          return null;
        }
        let value = UPCEANExtension5Support.parseExtension5String(raw);
        if (value == null) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);
      }
      static parseExtension5String(raw) {
        let currency;
        switch (raw.charAt(0)) {
          case "0":
            currency = "\xA3";
            break;
          case "5":
            currency = "$";
            break;
          case "9":
            switch (raw) {
              case "90000":
                return null;
              case "99991":
                return "0.00";
              case "99990":
                return "Used";
            }
            currency = "";
            break;
          default:
            currency = "";
            break;
        }
        let rawAmount = parseInt(raw.substring(1));
        let unitsString = (rawAmount / 100).toString();
        let hundredths = rawAmount % 100;
        let hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
        return currency + unitsString + "." + hundredthsString;
      }
    }
    class UPCEANExtension2Support {
      constructor() {
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, new Date().getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let checkParity = 0;
        for (let x = 0; x < 2 && rowOffset < end; x++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            checkParity |= 1 << 1 - x;
          }
          if (x !== 1) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 2) {
          throw new NotFoundException();
        }
        if (parseInt(resultString.toString()) % 4 !== checkParity) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static parseExtensionString(raw) {
        if (raw.length !== 2) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);
      }
    }
    class UPCEANExtensionSupport {
      static decodeRow(rowNumber, row, rowOffset) {
        let extensionStartRange = AbstractUPCEANReader.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
        try {
          let fiveSupport = new UPCEANExtension5Support();
          return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
        } catch (err) {
          let twoSupport = new UPCEANExtension2Support();
          return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
      }
    }
    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
    class UPCEANReader extends AbstractUPCEANReader {
      constructor() {
        super();
        this.decodeRowStringBuffer = "";
        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr) => Int32Array.from(arr));
        for (let i2 = 10; i2 < 20; i2++) {
          let widths = UPCEANReader.L_PATTERNS[i2 - 10];
          let reversedWidths = new Int32Array(widths.length);
          for (let j = 0; j < widths.length; j++) {
            reversedWidths[j] = widths[widths.length - j - 1];
          }
          UPCEANReader.L_AND_G_PATTERNS[i2] = reversedWidths;
        }
      }
      decodeRow(rowNumber, row, hints) {
        let startGuardRange = UPCEANReader.findStartGuardPattern(row);
        let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
        let endStart = budello.rowOffset;
        let result = budello.resultString;
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint(endStart, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let endRange = UPCEANReader.decodeEnd(row, endStart);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((endRange[0] + endRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let end = endRange[1];
        let quietEnd = end + (end - endRange[0]);
        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
          throw new NotFoundException();
        }
        let resultString = result.toString();
        if (resultString.length < 8) {
          throw new FormatException();
        }
        if (!UPCEANReader.checkChecksum(resultString)) {
          throw new ChecksumException();
        }
        let left = (startGuardRange[1] + startGuardRange[0]) / 2;
        let right = (endRange[1] + endRange[0]) / 2;
        let format = this.getBarcodeFormat();
        let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        let decodeResult = new Result(resultString, null, 0, resultPoint, format, new Date().getTime());
        let extensionLength = 0;
        try {
          let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
          decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
          decodeResult.putAllMetadata(extensionResult.getResultMetadata());
          decodeResult.addResultPoints(extensionResult.getResultPoints());
          extensionLength = extensionResult.getText().length;
        } catch (err) {
        }
        let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
        if (allowedExtensions != null) {
          let valid = false;
          for (let length in allowedExtensions) {
            if (extensionLength.toString() === length) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            throw new NotFoundException();
          }
        }
        if (format === BarcodeFormat$1.EAN_13 || format === BarcodeFormat$1.UPC_A)
          ;
        return decodeResult;
      }
      static checkChecksum(s2) {
        return UPCEANReader.checkStandardUPCEANChecksum(s2);
      }
      static checkStandardUPCEANChecksum(s2) {
        let length = s2.length;
        if (length === 0)
          return false;
        let check = parseInt(s2.charAt(length - 1), 10);
        return UPCEANReader.getStandardUPCEANChecksum(s2.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s2) {
        let length = s2.length;
        let sum = 0;
        for (let i2 = length - 1; i2 >= 0; i2 -= 2) {
          let digit = s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i2 = length - 2; i2 >= 0; i2 -= 2) {
          let digit = s2.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
      static decodeEnd(row, endStart) {
        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0));
      }
    }
    class EAN13Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
        let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_13;
      }
      static determineFirstDigit(resultString, lgPatternFound) {
        for (let d = 0; d < 10; d++) {
          if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
            resultString = String.fromCharCode("0".charCodeAt(0) + d) + resultString;
            return resultString;
          }
        }
        throw new NotFoundException();
      }
    }
    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
    class EAN8Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        const counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        for (let x = 0; x < 4 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (let x = 0; x < 4 && rowOffset < end; x++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_8;
      }
    }
    class UPCAReader extends UPCEANReader {
      constructor() {
        super(...arguments);
        this.ean13Reader = new EAN13Reader();
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_A;
      }
      decode(image, hints) {
        return this.maybeReturnResult(this.ean13Reader.decode(image));
      }
      decodeRow(rowNumber, row, hints) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
      }
      decodeMiddle(row, startRange, resultString) {
        return this.ean13Reader.decodeMiddle(row, startRange, resultString);
      }
      maybeReturnResult(result) {
        let text = result.getText();
        if (text.charAt(0) === "0") {
          let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
          if (result.getResultMetadata() != null) {
            upcaResult.putAllMetadata(result.getResultMetadata());
          }
          return upcaResult;
        } else {
          throw new NotFoundException();
        }
      }
      reset() {
        this.ean13Reader.reset();
      }
    }
    class UPCEReader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = new Int32Array(4);
      }
      decodeMiddle(row, startRange, result) {
        const counters = this.decodeMiddleCounters.map((x) => x);
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        const end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x = 0; x < 6 && rowOffset < end; x++) {
          const bestMatch = UPCEReader.decodeDigit(row, counters, rowOffset, UPCEReader.L_AND_G_PATTERNS);
          result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x;
          }
        }
        UPCEReader.determineNumSysAndCheckDigit(new StringBuilder(result), lgPatternFound);
        return rowOffset;
      }
      decodeEnd(row, endStart) {
        return UPCEReader.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader.MIDDLE_END_PATTERN);
      }
      checkChecksum(s2) {
        return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s2));
      }
      static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
        for (let numSys = 0; numSys <= 1; numSys++) {
          for (let d = 0; d < 10; d++) {
            if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
              resultString.insert(0, "0" + numSys);
              resultString.append("0" + d);
              return;
            }
          }
        }
        throw NotFoundException.getNotFoundInstance();
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_E;
      }
      static convertUPCEtoUPCA(upce) {
        const upceChars = upce.slice(1, 7).split("").map((x) => x.charCodeAt(0));
        const result = new StringBuilder();
        result.append(upce.charAt(0));
        let lastChar = upceChars[5];
        switch (lastChar) {
          case 0:
          case 1:
          case 2:
            result.appendChars(upceChars, 0, 2);
            result.append(lastChar);
            result.append("0000");
            result.appendChars(upceChars, 2, 3);
            break;
          case 3:
            result.appendChars(upceChars, 0, 3);
            result.append("00000");
            result.appendChars(upceChars, 3, 2);
            break;
          case 4:
            result.appendChars(upceChars, 0, 4);
            result.append("00000");
            result.append(upceChars[4]);
            break;
          default:
            result.appendChars(upceChars, 0, 5);
            result.append("0000");
            result.append(lastChar);
            break;
        }
        if (upce.length >= 8) {
          result.append(upce.charAt(7));
        }
        return result.toString();
      }
    }
    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
      Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
      Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 1])
    ];
    class MultiFormatUPCEANReader extends OneDReader {
      constructor(hints) {
        super();
        let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        let readers = [];
        if (possibleFormats != null) {
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
            readers.push(new EAN13Reader());
          } else if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
            readers.push(new UPCAReader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
            readers.push(new EAN8Reader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
            readers.push(new UPCEReader());
          }
        }
        if (readers.length === 0) {
          readers.push(new EAN13Reader());
          readers.push(new EAN8Reader());
          readers.push(new UPCEReader());
        }
        this.readers = readers;
      }
      decodeRow(rowNumber, row, hints) {
        for (let reader of this.readers) {
          try {
            const result = reader.decodeRow(rowNumber, row, hints);
            const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === "0";
            const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
            if (ean13MayBeUPCA && canReturnUPCA) {
              const rawBytes = result.getRawBytes();
              const resultUPCA = new Result(result.getText().substring(1), rawBytes, rawBytes.length, result.getResultPoints(), BarcodeFormat$1.UPC_A);
              resultUPCA.putAllMetadata(result.getResultMetadata());
              return resultUPCA;
            }
            return result;
          } catch (err) {
          }
        }
        throw new NotFoundException();
      }
      reset() {
        for (let reader of this.readers) {
          reader.reset();
        }
      }
    }
    class AbstractRSSReader extends OneDReader {
      constructor() {
        super();
        this.decodeFinderCounters = new Int32Array(4);
        this.dataCharacterCounters = new Int32Array(8);
        this.oddRoundingErrors = new Array(4);
        this.evenRoundingErrors = new Array(4);
        this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
        this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
      }
      getDecodeFinderCounters() {
        return this.decodeFinderCounters;
      }
      getDataCharacterCounters() {
        return this.dataCharacterCounters;
      }
      getOddRoundingErrors() {
        return this.oddRoundingErrors;
      }
      getEvenRoundingErrors() {
        return this.evenRoundingErrors;
      }
      getOddCounts() {
        return this.oddCounts;
      }
      getEvenCounts() {
        return this.evenCounts;
      }
      parseFinderValue(counters, finderPatterns) {
        for (let value = 0; value < finderPatterns.length; value++) {
          if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
            return value;
          }
        }
        throw new NotFoundException();
      }
      static count(array) {
        return MathUtils.sum(new Int32Array(array));
      }
      static increment(array, errors) {
        let index = 0;
        let biggestError = errors[0];
        for (let i2 = 1; i2 < array.length; i2++) {
          if (errors[i2] > biggestError) {
            biggestError = errors[i2];
            index = i2;
          }
        }
        array[index]++;
      }
      static decrement(array, errors) {
        let index = 0;
        let biggestError = errors[0];
        for (let i2 = 1; i2 < array.length; i2++) {
          if (errors[i2] < biggestError) {
            biggestError = errors[i2];
            index = i2;
          }
        }
        array[index]--;
      }
      static isFinderPattern(counters) {
        let firstTwoSum = counters[0] + counters[1];
        let sum = firstTwoSum + counters[2] + counters[3];
        let ratio = firstTwoSum / sum;
        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
          let minCounter = Number.MAX_SAFE_INTEGER;
          let maxCounter = Number.MIN_SAFE_INTEGER;
          for (let counter of counters) {
            if (counter > maxCounter) {
              maxCounter = counter;
            }
            if (counter < minCounter) {
              minCounter = counter;
            }
          }
          return maxCounter < 10 * minCounter;
        }
        return false;
      }
    }
    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
    class DataCharacter {
      constructor(value, checksumPortion) {
        this.value = value;
        this.checksumPortion = checksumPortion;
      }
      getValue() {
        return this.value;
      }
      getChecksumPortion() {
        return this.checksumPortion;
      }
      toString() {
        return this.value + "(" + this.checksumPortion + ")";
      }
      equals(o2) {
        if (!(o2 instanceof DataCharacter)) {
          return false;
        }
        const that = o2;
        return this.value === that.value && this.checksumPortion === that.checksumPortion;
      }
      hashCode() {
        return this.value ^ this.checksumPortion;
      }
    }
    class FinderPattern {
      constructor(value, startEnd, start, end, rowNumber) {
        this.value = value;
        this.startEnd = startEnd;
        this.value = value;
        this.startEnd = startEnd;
        this.resultPoints = new Array();
        this.resultPoints.push(new ResultPoint(start, rowNumber));
        this.resultPoints.push(new ResultPoint(end, rowNumber));
      }
      getValue() {
        return this.value;
      }
      getStartEnd() {
        return this.startEnd;
      }
      getResultPoints() {
        return this.resultPoints;
      }
      equals(o2) {
        if (!(o2 instanceof FinderPattern)) {
          return false;
        }
        const that = o2;
        return this.value === that.value;
      }
      hashCode() {
        return this.value;
      }
    }
    class RSSUtils {
      constructor() {
      }
      static getRSSvalue(widths, maxWidth, noNarrow) {
        let n2 = 0;
        for (let width of widths) {
          n2 += width;
        }
        let val = 0;
        let narrowMask = 0;
        let elements = widths.length;
        for (let bar = 0; bar < elements - 1; bar++) {
          let elmWidth;
          for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
            let subVal = RSSUtils.combins(n2 - elmWidth - 1, elements - bar - 2);
            if (noNarrow && narrowMask === 0 && n2 - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
              subVal -= RSSUtils.combins(n2 - elmWidth - (elements - bar), elements - bar - 2);
            }
            if (elements - bar - 1 > 1) {
              let lessVal = 0;
              for (let mxwElement = n2 - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                lessVal += RSSUtils.combins(n2 - elmWidth - mxwElement - 1, elements - bar - 3);
              }
              subVal -= lessVal * (elements - 1 - bar);
            } else if (n2 - elmWidth > maxWidth) {
              subVal--;
            }
            val += subVal;
          }
          n2 -= elmWidth;
        }
        return val;
      }
      static combins(n2, r2) {
        let maxDenom;
        let minDenom;
        if (n2 - r2 > r2) {
          minDenom = r2;
          maxDenom = n2 - r2;
        } else {
          minDenom = n2 - r2;
          maxDenom = r2;
        }
        let val = 1;
        let j = 1;
        for (let i2 = n2; i2 > maxDenom; i2--) {
          val *= i2;
          if (j <= minDenom) {
            val /= j;
            j++;
          }
        }
        while (j <= minDenom) {
          val /= j;
          j++;
        }
        return val;
      }
    }
    class BitArrayBuilder {
      static buildBitArray(pairs) {
        let charNumber = pairs.length * 2 - 1;
        if (pairs[pairs.length - 1].getRightChar() == null) {
          charNumber -= 1;
        }
        let size2 = 12 * charNumber;
        let binary = new BitArray(size2);
        let accPos = 0;
        let firstPair = pairs[0];
        let firstValue = firstPair.getRightChar().getValue();
        for (let i2 = 11; i2 >= 0; --i2) {
          if ((firstValue & 1 << i2) != 0) {
            binary.set(accPos);
          }
          accPos++;
        }
        for (let i2 = 1; i2 < pairs.length; ++i2) {
          let currentPair = pairs[i2];
          let leftValue = currentPair.getLeftChar().getValue();
          for (let j = 11; j >= 0; --j) {
            if ((leftValue & 1 << j) != 0) {
              binary.set(accPos);
            }
            accPos++;
          }
          if (currentPair.getRightChar() != null) {
            let rightValue = currentPair.getRightChar().getValue();
            for (let j = 11; j >= 0; --j) {
              if ((rightValue & 1 << j) != 0) {
                binary.set(accPos);
              }
              accPos++;
            }
          }
        }
        return binary;
      }
    }
    class BlockParsedResult {
      constructor(finished, decodedInformation) {
        if (decodedInformation) {
          this.decodedInformation = null;
        } else {
          this.finished = finished;
          this.decodedInformation = decodedInformation;
        }
      }
      getDecodedInformation() {
        return this.decodedInformation;
      }
      isFinished() {
        return this.finished;
      }
    }
    class DecodedObject {
      constructor(newPosition) {
        this.newPosition = newPosition;
      }
      getNewPosition() {
        return this.newPosition;
      }
    }
    class DecodedChar extends DecodedObject {
      constructor(newPosition, value) {
        super(newPosition);
        this.value = value;
      }
      getValue() {
        return this.value;
      }
      isFNC1() {
        return this.value === DecodedChar.FNC1;
      }
    }
    DecodedChar.FNC1 = "$";
    class DecodedInformation extends DecodedObject {
      constructor(newPosition, newString, remainingValue) {
        super(newPosition);
        if (remainingValue) {
          this.remaining = true;
          this.remainingValue = this.remainingValue;
        } else {
          this.remaining = false;
          this.remainingValue = 0;
        }
        this.newString = newString;
      }
      getNewString() {
        return this.newString;
      }
      isRemaining() {
        return this.remaining;
      }
      getRemainingValue() {
        return this.remainingValue;
      }
    }
    class DecodedNumeric extends DecodedObject {
      constructor(newPosition, firstDigit, secondDigit) {
        super(newPosition);
        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
          throw new FormatException();
        }
        this.firstDigit = firstDigit;
        this.secondDigit = secondDigit;
      }
      getFirstDigit() {
        return this.firstDigit;
      }
      getSecondDigit() {
        return this.secondDigit;
      }
      getValue() {
        return this.firstDigit * 10 + this.secondDigit;
      }
      isFirstDigitFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1;
      }
      isSecondDigitFNC1() {
        return this.secondDigit === DecodedNumeric.FNC1;
      }
      isAnyFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
      }
    }
    DecodedNumeric.FNC1 = 10;
    class FieldParser {
      constructor() {
      }
      static parseFieldsInGeneralPurpose(rawInformation) {
        if (!rawInformation) {
          return null;
        }
        if (rawInformation.length < 2) {
          throw new NotFoundException();
        }
        let firstTwoDigits = rawInformation.substring(0, 2);
        for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstTwoDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 3) {
          throw new NotFoundException();
        }
        let firstThreeDigits = rawInformation.substring(0, 3);
        for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
          }
        }
        for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 4) {
          throw new NotFoundException();
        }
        let firstFourDigits = rawInformation.substring(0, 4);
        for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstFourDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        throw new NotFoundException();
      }
      static processFixedAI(aiSize, fieldSize, rawInformation) {
        if (rawInformation.length < aiSize) {
          throw new NotFoundException();
        }
        let ai = rawInformation.substring(0, aiSize);
        if (rawInformation.length < aiSize + fieldSize) {
          throw new NotFoundException();
        }
        let field = rawInformation.substring(aiSize, aiSize + fieldSize);
        let remaining = rawInformation.substring(aiSize + fieldSize);
        let result = "(" + ai + ")" + field;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
      static processVariableAI(aiSize, variableFieldSize, rawInformation) {
        let ai = rawInformation.substring(0, aiSize);
        let maxSize;
        if (rawInformation.length < aiSize + variableFieldSize) {
          maxSize = rawInformation.length;
        } else {
          maxSize = aiSize + variableFieldSize;
        }
        let field = rawInformation.substring(aiSize, maxSize);
        let remaining = rawInformation.substring(maxSize);
        let result = "(" + ai + ")" + field;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
    }
    FieldParser.VARIABLE_LENGTH = [];
    FieldParser.TWO_DIGIT_DATA_LENGTH = [
      ["00", 18],
      ["01", 14],
      ["02", 14],
      ["10", FieldParser.VARIABLE_LENGTH, 20],
      ["11", 6],
      ["12", 6],
      ["13", 6],
      ["15", 6],
      ["17", 6],
      ["20", 2],
      ["21", FieldParser.VARIABLE_LENGTH, 20],
      ["22", FieldParser.VARIABLE_LENGTH, 29],
      ["30", FieldParser.VARIABLE_LENGTH, 8],
      ["37", FieldParser.VARIABLE_LENGTH, 8],
      ["90", FieldParser.VARIABLE_LENGTH, 30],
      ["91", FieldParser.VARIABLE_LENGTH, 30],
      ["92", FieldParser.VARIABLE_LENGTH, 30],
      ["93", FieldParser.VARIABLE_LENGTH, 30],
      ["94", FieldParser.VARIABLE_LENGTH, 30],
      ["95", FieldParser.VARIABLE_LENGTH, 30],
      ["96", FieldParser.VARIABLE_LENGTH, 30],
      ["97", FieldParser.VARIABLE_LENGTH, 3],
      ["98", FieldParser.VARIABLE_LENGTH, 30],
      ["99", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH = [
      ["240", FieldParser.VARIABLE_LENGTH, 30],
      ["241", FieldParser.VARIABLE_LENGTH, 30],
      ["242", FieldParser.VARIABLE_LENGTH, 6],
      ["250", FieldParser.VARIABLE_LENGTH, 30],
      ["251", FieldParser.VARIABLE_LENGTH, 30],
      ["253", FieldParser.VARIABLE_LENGTH, 17],
      ["254", FieldParser.VARIABLE_LENGTH, 20],
      ["400", FieldParser.VARIABLE_LENGTH, 30],
      ["401", FieldParser.VARIABLE_LENGTH, 30],
      ["402", 17],
      ["403", FieldParser.VARIABLE_LENGTH, 30],
      ["410", 13],
      ["411", 13],
      ["412", 13],
      ["413", 13],
      ["414", 13],
      ["420", FieldParser.VARIABLE_LENGTH, 20],
      ["421", FieldParser.VARIABLE_LENGTH, 15],
      ["422", 3],
      ["423", FieldParser.VARIABLE_LENGTH, 15],
      ["424", 3],
      ["425", 3],
      ["426", 3]
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
      ["310", 6],
      ["311", 6],
      ["312", 6],
      ["313", 6],
      ["314", 6],
      ["315", 6],
      ["316", 6],
      ["320", 6],
      ["321", 6],
      ["322", 6],
      ["323", 6],
      ["324", 6],
      ["325", 6],
      ["326", 6],
      ["327", 6],
      ["328", 6],
      ["329", 6],
      ["330", 6],
      ["331", 6],
      ["332", 6],
      ["333", 6],
      ["334", 6],
      ["335", 6],
      ["336", 6],
      ["340", 6],
      ["341", 6],
      ["342", 6],
      ["343", 6],
      ["344", 6],
      ["345", 6],
      ["346", 6],
      ["347", 6],
      ["348", 6],
      ["349", 6],
      ["350", 6],
      ["351", 6],
      ["352", 6],
      ["353", 6],
      ["354", 6],
      ["355", 6],
      ["356", 6],
      ["357", 6],
      ["360", 6],
      ["361", 6],
      ["362", 6],
      ["363", 6],
      ["364", 6],
      ["365", 6],
      ["366", 6],
      ["367", 6],
      ["368", 6],
      ["369", 6],
      ["390", FieldParser.VARIABLE_LENGTH, 15],
      ["391", FieldParser.VARIABLE_LENGTH, 18],
      ["392", FieldParser.VARIABLE_LENGTH, 15],
      ["393", FieldParser.VARIABLE_LENGTH, 18],
      ["703", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH = [
      ["7001", 13],
      ["7002", FieldParser.VARIABLE_LENGTH, 30],
      ["7003", 10],
      ["8001", 14],
      ["8002", FieldParser.VARIABLE_LENGTH, 20],
      ["8003", FieldParser.VARIABLE_LENGTH, 30],
      ["8004", FieldParser.VARIABLE_LENGTH, 30],
      ["8005", 6],
      ["8006", 18],
      ["8007", FieldParser.VARIABLE_LENGTH, 30],
      ["8008", FieldParser.VARIABLE_LENGTH, 12],
      ["8018", 18],
      ["8020", FieldParser.VARIABLE_LENGTH, 25],
      ["8100", 6],
      ["8101", 10],
      ["8102", 2],
      ["8110", FieldParser.VARIABLE_LENGTH, 70],
      ["8200", FieldParser.VARIABLE_LENGTH, 70]
    ];
    class GeneralAppIdDecoder {
      constructor(information) {
        this.buffer = new StringBuilder();
        this.information = information;
      }
      decodeAllCodes(buff, initialPosition) {
        let currentPosition = initialPosition;
        let remaining = null;
        do {
          let info = this.decodeGeneralPurposeField(currentPosition, remaining);
          let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
          if (parsedFields != null) {
            buff.append(parsedFields);
          }
          if (info.isRemaining()) {
            remaining = "" + info.getRemainingValue();
          } else {
            remaining = null;
          }
          if (currentPosition === info.getNewPosition()) {
            break;
          }
          currentPosition = info.getNewPosition();
        } while (true);
        return buff.toString();
      }
      isStillNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          return pos + 4 <= this.information.getSize();
        }
        for (let i2 = pos; i2 < pos + 3; ++i2) {
          if (this.information.get(i2)) {
            return true;
          }
        }
        return this.information.get(pos + 3);
      }
      decodeNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          let numeric2 = this.extractNumericValueFromBitArray(pos, 4);
          if (numeric2 === 0) {
            return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
          }
          return new DecodedNumeric(this.information.getSize(), numeric2 - 1, DecodedNumeric.FNC1);
        }
        let numeric = this.extractNumericValueFromBitArray(pos, 7);
        let digit1 = (numeric - 8) / 11;
        let digit2 = (numeric - 8) % 11;
        return new DecodedNumeric(pos + 7, digit1, digit2);
      }
      extractNumericValueFromBitArray(pos, bits) {
        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
      }
      static extractNumericValueFromBitArray(information, pos, bits) {
        let value = 0;
        for (let i2 = 0; i2 < bits; ++i2) {
          if (information.get(pos + i2)) {
            value |= 1 << bits - i2 - 1;
          }
        }
        return value;
      }
      decodeGeneralPurposeField(pos, remaining) {
        this.buffer.setLengthToZero();
        if (remaining != null) {
          this.buffer.append(remaining);
        }
        this.current.setPosition(pos);
        let lastDecoded = this.parseBlocks();
        if (lastDecoded != null && lastDecoded.isRemaining()) {
          return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
        }
        return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
      }
      parseBlocks() {
        let isFinished;
        let result;
        do {
          let initialPosition = this.current.getPosition();
          if (this.current.isAlpha()) {
            result = this.parseAlphaBlock();
            isFinished = result.isFinished();
          } else if (this.current.isIsoIec646()) {
            result = this.parseIsoIec646Block();
            isFinished = result.isFinished();
          } else {
            result = this.parseNumericBlock();
            isFinished = result.isFinished();
          }
          let positionChanged = initialPosition !== this.current.getPosition();
          if (!positionChanged && !isFinished) {
            break;
          }
        } while (!isFinished);
        return result.getDecodedInformation();
      }
      parseNumericBlock() {
        while (this.isStillNumeric(this.current.getPosition())) {
          let numeric = this.decodeNumeric(this.current.getPosition());
          this.current.setPosition(numeric.getNewPosition());
          if (numeric.isFirstDigitFNC1()) {
            let information;
            if (numeric.isSecondDigitFNC1()) {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            } else {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
            }
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getFirstDigit());
          if (numeric.isSecondDigitFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getSecondDigit());
        }
        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
          this.current.setAlpha();
          this.current.incrementPosition(4);
        }
        return new BlockParsedResult(false);
      }
      parseIsoIec646Block() {
        while (this.isStillIsoIec646(this.current.getPosition())) {
          let iso = this.decodeIsoIec646(this.current.getPosition());
          this.current.setPosition(iso.getNewPosition());
          if (iso.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(iso.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setAlpha();
        }
        return new BlockParsedResult(false);
      }
      parseAlphaBlock() {
        while (this.isStillAlpha(this.current.getPosition())) {
          let alpha = this.decodeAlphanumeric(this.current.getPosition());
          this.current.setPosition(alpha.getNewPosition());
          if (alpha.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(alpha.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setIsoIec646();
        }
        return new BlockParsedResult(false);
      }
      isStillIsoIec646(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 7 > this.information.getSize()) {
          return false;
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 116) {
          return true;
        }
        if (pos + 8 > this.information.getSize()) {
          return false;
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        return eightBitValue >= 232 && eightBitValue < 253;
      }
      decodeIsoIec646(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 90) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 1));
        }
        if (sevenBitValue >= 90 && sevenBitValue < 116) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 7));
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        let c2;
        switch (eightBitValue) {
          case 232:
            c2 = "!";
            break;
          case 233:
            c2 = '"';
            break;
          case 234:
            c2 = "%";
            break;
          case 235:
            c2 = "&";
            break;
          case 236:
            c2 = "'";
            break;
          case 237:
            c2 = "(";
            break;
          case 238:
            c2 = ")";
            break;
          case 239:
            c2 = "*";
            break;
          case 240:
            c2 = "+";
            break;
          case 241:
            c2 = ",";
            break;
          case 242:
            c2 = "-";
            break;
          case 243:
            c2 = ".";
            break;
          case 244:
            c2 = "/";
            break;
          case 245:
            c2 = ":";
            break;
          case 246:
            c2 = ";";
            break;
          case 247:
            c2 = "<";
            break;
          case 248:
            c2 = "=";
            break;
          case 249:
            c2 = ">";
            break;
          case 250:
            c2 = "?";
            break;
          case 251:
            c2 = "_";
            break;
          case 252:
            c2 = " ";
            break;
          default:
            throw new FormatException();
        }
        return new DecodedChar(pos + 8, c2);
      }
      isStillAlpha(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 6 > this.information.getSize()) {
          return false;
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        return sixBitValue >= 16 && sixBitValue < 63;
      }
      decodeAlphanumeric(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        if (sixBitValue >= 32 && sixBitValue < 58) {
          return new DecodedChar(pos + 6, "" + (sixBitValue + 33));
        }
        let c2;
        switch (sixBitValue) {
          case 58:
            c2 = "*";
            break;
          case 59:
            c2 = ",";
            break;
          case 60:
            c2 = "-";
            break;
          case 61:
            c2 = ".";
            break;
          case 62:
            c2 = "/";
            break;
          default:
            throw new IllegalStateException("Decoding invalid alphanumeric value: " + sixBitValue);
        }
        return new DecodedChar(pos + 6, c2);
      }
      isAlphaTo646ToAlphaLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i2 = 0; i2 < 5 && i2 + pos < this.information.getSize(); ++i2) {
          if (i2 === 2) {
            if (!this.information.get(pos + 2)) {
              return false;
            }
          } else if (this.information.get(pos + i2)) {
            return false;
          }
        }
        return true;
      }
      isAlphaOr646ToNumericLatch(pos) {
        if (pos + 3 > this.information.getSize()) {
          return false;
        }
        for (let i2 = pos; i2 < pos + 3; ++i2) {
          if (this.information.get(i2)) {
            return false;
          }
        }
        return true;
      }
      isNumericToAlphaNumericLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i2 = 0; i2 < 4 && i2 + pos < this.information.getSize(); ++i2) {
          if (this.information.get(pos + i2)) {
            return false;
          }
        }
        return true;
      }
    }
    class AbstractExpandedDecoder {
      constructor(information) {
        this.information = information;
        this.generalDecoder = new GeneralAppIdDecoder(information);
      }
      getInformation() {
        return this.information;
      }
      getGeneralDecoder() {
        return this.generalDecoder;
      }
    }
    class AI01decoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedGtin(buf, currentPos) {
        buf.append("(01)");
        let initialPosition = buf.length();
        buf.append("9");
        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
      }
      encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
        for (let i2 = 0; i2 < 4; ++i2) {
          let currentBlock2 = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i2, 10);
          if (currentBlock2 / 100 === 0) {
            buf.append("0");
          }
          if (currentBlock2 / 10 === 0) {
            buf.append("0");
          }
          buf.append(currentBlock2);
        }
        AI01decoder.appendCheckDigit(buf, initialBufferPosition);
      }
      static appendCheckDigit(buf, currentPos) {
        let checkDigit = 0;
        for (let i2 = 0; i2 < 13; i2++) {
          let digit = buf.charAt(i2 + currentPos).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i2 & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buf.append(checkDigit);
      }
    }
    AI01decoder.GTIN_SIZE = 40;
    class AI01AndOtherAIs extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buff = new StringBuilder();
        buff.append("(01)");
        let initialGtinPosition = buff.length();
        let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
        buff.append(firstGtinDigit);
        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
      }
    }
    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2;
    class AnyAIDecoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buf = new StringBuilder();
        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
      }
    }
    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
    class AI01weightDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedWeight(buf, currentPos, weightSize) {
        let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
        this.addWeightCode(buf, originalWeightNumeric);
        let weightNumeric = this.checkWeight(originalWeightNumeric);
        let currentDivisor = 1e5;
        for (let i2 = 0; i2 < 5; ++i2) {
          if (weightNumeric / currentDivisor === 0) {
            buf.append("0");
          }
          currentDivisor /= 10;
        }
        buf.append(weightNumeric);
      }
    }
    class AI013x0xDecoder extends AI01weightDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
    }
    AI013x0xDecoder.HEADER_SIZE = 4 + 1;
    AI013x0xDecoder.WEIGHT_SIZE = 15;
    class AI013103decoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        buf.append("(3103)");
      }
      checkWeight(weight) {
        return weight;
      }
    }
    class AI01320xDecoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        if (weight < 1e4) {
          buf.append("(3202)");
        } else {
          buf.append("(3203)");
        }
      }
      checkWeight(weight) {
        if (weight < 1e4) {
          return weight;
        }
        return weight - 1e4;
      }
    }
    class AI01392xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
        buf.append("(392");
        buf.append(lastAIdigit);
        buf.append(")");
        let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
        buf.append(decodedInformation.getNewString());
        return buf.toString();
      }
    }
    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01392xDecoder.LAST_DIGIT_SIZE = 2;
    class AI01393xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
        buf.append("(393");
        buf.append(lastAIdigit);
        buf.append(")");
        let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
        if (firstThreeDigits / 100 == 0) {
          buf.append("0");
        }
        if (firstThreeDigits / 10 == 0) {
          buf.append("0");
        }
        buf.append(firstThreeDigits);
        let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
        buf.append(generalInformation.getNewString());
        return buf.toString();
      }
    }
    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01393xDecoder.LAST_DIGIT_SIZE = 2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
    class AI013x0x1xDecoder extends AI01weightDecoder {
      constructor(information, firstAIdigits, dateCode) {
        super(information);
        this.dateCode = dateCode;
        this.firstAIdigits = firstAIdigits;
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
      encodeCompressedDate(buf, currentPos) {
        let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
        if (numericDate == 38400) {
          return;
        }
        buf.append("(");
        buf.append(this.dateCode);
        buf.append(")");
        let day = numericDate % 32;
        numericDate /= 32;
        let month = numericDate % 12 + 1;
        numericDate /= 12;
        let year = numericDate;
        if (year / 10 == 0) {
          buf.append("0");
        }
        buf.append(year);
        if (month / 10 == 0) {
          buf.append("0");
        }
        buf.append(month);
        if (day / 10 == 0) {
          buf.append("0");
        }
        buf.append(day);
      }
      addWeightCode(buf, weight) {
        buf.append("(");
        buf.append(this.firstAIdigits);
        buf.append(weight / 1e5);
        buf.append(")");
      }
      checkWeight(weight) {
        return weight % 1e5;
      }
    }
    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
    AI013x0x1xDecoder.WEIGHT_SIZE = 20;
    AI013x0x1xDecoder.DATE_SIZE = 16;
    function createDecoder(information) {
      try {
        if (information.get(1)) {
          return new AI01AndOtherAIs(information);
        }
        if (!information.get(2)) {
          return new AnyAIDecoder(information);
        }
        let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
        switch (fourBitEncodationMethod) {
          case 4:
            return new AI013103decoder(information);
          case 5:
            return new AI01320xDecoder(information);
        }
        let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
        switch (fiveBitEncodationMethod) {
          case 12:
            return new AI01392xDecoder(information);
          case 13:
            return new AI01393xDecoder(information);
        }
        let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
        switch (sevenBitEncodationMethod) {
          case 56:
            return new AI013x0x1xDecoder(information, "310", "11");
          case 57:
            return new AI013x0x1xDecoder(information, "320", "11");
          case 58:
            return new AI013x0x1xDecoder(information, "310", "13");
          case 59:
            return new AI013x0x1xDecoder(information, "320", "13");
          case 60:
            return new AI013x0x1xDecoder(information, "310", "15");
          case 61:
            return new AI013x0x1xDecoder(information, "320", "15");
          case 62:
            return new AI013x0x1xDecoder(information, "310", "17");
          case 63:
            return new AI013x0x1xDecoder(information, "320", "17");
        }
      } catch (e2) {
        console.log(e2);
        throw new IllegalStateException("unknown decoder: " + information);
      }
    }
    class ExpandedPair {
      constructor(leftChar, rightChar, finderPatter, mayBeLast) {
        this.leftchar = leftChar;
        this.rightchar = rightChar;
        this.finderpattern = finderPatter;
        this.maybeLast = mayBeLast;
      }
      mayBeLast() {
        return this.maybeLast;
      }
      getLeftChar() {
        return this.leftchar;
      }
      getRightChar() {
        return this.rightchar;
      }
      getFinderPattern() {
        return this.finderpattern;
      }
      mustBeLast() {
        return this.rightchar == null;
      }
      toString() {
        return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
      }
      static equals(o1, o2) {
        if (!(o1 instanceof ExpandedPair)) {
          return false;
        }
        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
      }
      static equalsOrNull(o1, o2) {
        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
      }
      hashCode() {
        let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
        return value;
      }
    }
    class ExpandedRow {
      constructor(pairs, rowNumber, wasReversed) {
        this.pairs = pairs;
        this.rowNumber = rowNumber;
        this.wasReversed = wasReversed;
      }
      getPairs() {
        return this.pairs;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      isReversed() {
        return this.wasReversed;
      }
      isEquivalent(otherPairs) {
        return this.checkEqualitity(this, otherPairs);
      }
      toString() {
        return "{ " + this.pairs + " }";
      }
      equals(o1, o2) {
        if (!(o1 instanceof ExpandedRow)) {
          return false;
        }
        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
      }
      checkEqualitity(pair1, pair2) {
        if (!pair1 || !pair2)
          return;
        let result;
        pair1.forEach((e1, i2) => {
          pair2.forEach((e2) => {
            if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
              result = true;
            }
          });
        });
        return result;
      }
    }
    class RSSExpandedReader extends AbstractRSSReader {
      constructor(verbose) {
        super(...arguments);
        this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
        this.rows = new Array();
        this.startEnd = [2];
        this.verbose = verbose === true;
      }
      decodeRow(rowNumber, row, hints) {
        this.pairs.length = 0;
        this.startFromEven = false;
        try {
          return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        } catch (e2) {
          if (this.verbose) {
            console.log(e2);
          }
        }
        this.pairs.length = 0;
        this.startFromEven = true;
        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
      }
      reset() {
        this.pairs.length = 0;
        this.rows.length = 0;
      }
      decodeRow2pairs(rowNumber, row) {
        let done = false;
        while (!done) {
          try {
            this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
          } catch (error) {
            if (error instanceof NotFoundException) {
              if (!this.pairs.length) {
                throw new NotFoundException();
              }
              done = true;
            }
          }
        }
        if (this.checkChecksum()) {
          return this.pairs;
        }
        let tryStackedDecode;
        if (this.rows.length) {
          tryStackedDecode = true;
        } else {
          tryStackedDecode = false;
        }
        this.storeRow(rowNumber, false);
        if (tryStackedDecode) {
          let ps = this.checkRowsBoolean(false);
          if (ps != null) {
            return ps;
          }
          ps = this.checkRowsBoolean(true);
          if (ps != null) {
            return ps;
          }
        }
        throw new NotFoundException();
      }
      checkRowsBoolean(reverse) {
        if (this.rows.length > 25) {
          this.rows.length = 0;
          return null;
        }
        this.pairs.length = 0;
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        let ps = null;
        try {
          ps = this.checkRows(new Array(), 0);
        } catch (e2) {
          if (this.verbose) {
            console.log(e2);
          }
        }
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        return ps;
      }
      checkRows(collectedRows, currentRow) {
        for (let i2 = currentRow; i2 < this.rows.length; i2++) {
          let row = this.rows[i2];
          this.pairs.length = 0;
          for (let collectedRow of collectedRows) {
            this.pairs.push(collectedRow.getPairs());
          }
          this.pairs.push(row.getPairs());
          if (!RSSExpandedReader.isValidSequence(this.pairs)) {
            continue;
          }
          if (this.checkChecksum()) {
            return this.pairs;
          }
          let rs = new Array(collectedRows);
          rs.push(row);
          try {
            return this.checkRows(rs, i2 + 1);
          } catch (e2) {
            if (this.verbose) {
              console.log(e2);
            }
          }
        }
        throw new NotFoundException();
      }
      static isValidSequence(pairs) {
        for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
          if (pairs.length > sequence.length) {
            continue;
          }
          let stop = true;
          for (let j = 0; j < pairs.length; j++) {
            if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
              stop = false;
              break;
            }
          }
          if (stop) {
            return true;
          }
        }
        return false;
      }
      storeRow(rowNumber, wasReversed) {
        let insertPos = 0;
        let prevIsSame = false;
        let nextIsSame = false;
        while (insertPos < this.rows.length) {
          let erow = this.rows[insertPos];
          if (erow.getRowNumber() > rowNumber) {
            nextIsSame = erow.isEquivalent(this.pairs);
            break;
          }
          prevIsSame = erow.isEquivalent(this.pairs);
          insertPos++;
        }
        if (nextIsSame || prevIsSame) {
          return;
        }
        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
          return;
        }
        this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
        this.removePartialRows(this.pairs, this.rows);
      }
      removePartialRows(pairs, rows) {
        for (let row of rows) {
          if (row.getPairs().length === pairs.length) {
            continue;
          }
          for (let p2 of row.getPairs()) {
            for (let pp of pairs) {
              if (ExpandedPair.equals(p2, pp)) {
                break;
              }
            }
          }
        }
      }
      static isPartialRow(pairs, rows) {
        for (let r2 of rows) {
          let allFound = true;
          for (let p2 of pairs) {
            let found = false;
            for (let pp of r2.getPairs()) {
              if (p2.equals(pp)) {
                found = true;
                break;
              }
            }
            if (!found) {
              allFound = false;
              break;
            }
          }
          if (allFound) {
            return true;
          }
        }
        return false;
      }
      getRows() {
        return this.rows;
      }
      static constructResult(pairs) {
        let binary = BitArrayBuilder.buildBitArray(pairs);
        let decoder = createDecoder(binary);
        let resultingString = decoder.parseInformation();
        let firstPoints = pairs[0].getFinderPattern().getResultPoints();
        let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
        let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
        return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
      }
      checkChecksum() {
        let firstPair = this.pairs.get(0);
        let checkCharacter = firstPair.getLeftChar();
        let firstCharacter = firstPair.getRightChar();
        if (firstCharacter == null) {
          return false;
        }
        let checksum = firstCharacter.getChecksumPortion();
        let s2 = 2;
        for (let i2 = 1; i2 < this.pairs.size(); ++i2) {
          let currentPair = this.pairs.get(i2);
          checksum += currentPair.getLeftChar().getChecksumPortion();
          s2++;
          let currentRightChar = currentPair.getRightChar();
          if (currentRightChar != null) {
            checksum += currentRightChar.getChecksumPortion();
            s2++;
          }
        }
        checksum %= 211;
        let checkCharacterValue = 211 * (s2 - 4) + checksum;
        return checkCharacterValue == checkCharacter.getValue();
      }
      static getNextSecondBar(row, initialPos) {
        let currentPos;
        if (row.get(initialPos)) {
          currentPos = row.getNextUnset(initialPos);
          currentPos = row.getNextSet(currentPos);
        } else {
          currentPos = row.getNextSet(initialPos);
          currentPos = row.getNextUnset(currentPos);
        }
        return currentPos;
      }
      retrieveNextPair(row, previousPairs, rowNumber) {
        let isOddPattern = previousPairs.length % 2 == 0;
        if (this.startFromEven) {
          isOddPattern = !isOddPattern;
        }
        let pattern;
        let keepFinding = true;
        let forcedOffset = -1;
        do {
          this.findNextPair(row, previousPairs, forcedOffset);
          pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
          if (pattern == null) {
            forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
          } else {
            keepFinding = false;
          }
        } while (keepFinding);
        let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
        if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
          throw new NotFoundException();
        }
        let rightChar;
        try {
          rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
        } catch (e2) {
          rightChar = null;
          if (this.verbose) {
            console.log(e2);
          }
        }
        return new ExpandedPair(leftChar, rightChar, pattern, true);
      }
      isEmptyPair(pairs) {
        if (pairs.length === 0) {
          return true;
        }
        return false;
      }
      findNextPair(row, previousPairs, forcedOffset) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let rowOffset;
        if (forcedOffset >= 0) {
          rowOffset = forcedOffset;
        } else if (this.isEmptyPair(previousPairs)) {
          rowOffset = 0;
        } else {
          let lastPair = previousPairs[previousPairs.length - 1];
          rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
        }
        let searchingEvenPair = previousPairs.length % 2 != 0;
        if (this.startFromEven) {
          searchingEvenPair = !searchingEvenPair;
        }
        let isWhite = false;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (!isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) != isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition == 3) {
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              if (RSSExpandedReader.isFinderPattern(counters)) {
                this.startEnd[0] = patternStart;
                this.startEnd[1] = x;
                return;
              }
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static reverseCounters(counters) {
        let length = counters.length;
        for (let i2 = 0; i2 < length / 2; ++i2) {
          let tmp = counters[i2];
          counters[i2] = counters[length - i2 - 1];
          counters[length - i2 - 1] = tmp;
        }
      }
      parseFoundFinderPattern(row, rowNumber, oddPattern) {
        let firstCounter;
        let start;
        let end;
        if (oddPattern) {
          let firstElementStart = this.startEnd[0] - 1;
          while (firstElementStart >= 0 && !row.get(firstElementStart)) {
            firstElementStart--;
          }
          firstElementStart++;
          firstCounter = this.startEnd[0] - firstElementStart;
          start = firstElementStart;
          end = this.startEnd[1];
        } else {
          start = this.startEnd[0];
          end = row.getNextUnset(this.startEnd[1] + 1);
          firstCounter = end - this.startEnd[1];
        }
        let counters = this.getDecodeFinderCounters();
        System.arraycopy(counters, 0, counters, 1, counters.length - 1);
        counters[0] = firstCounter;
        let value;
        try {
          value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
        } catch (e2) {
          return null;
        }
        return new FinderPattern(value, [start, end], start, end, rowNumber);
      }
      decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
        let counters = this.getDataCharacterCounters();
        for (let x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (leftChar) {
          RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
          for (let i2 = 0, j = counters.length - 1; i2 < j; i2++, j--) {
            let temp = counters[i2];
            counters[i2] = counters[j];
            counters[j] = temp;
          }
        }
        let numModules = 17;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
          throw new NotFoundException();
        }
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i2 = 0; i2 < counters.length; i2++) {
          let value2 = 1 * counters[i2] / elementWidth;
          let count = value2 + 0.5;
          if (count < 1) {
            if (value2 < 0.3) {
              throw new NotFoundException();
            }
            count = 1;
          } else if (count > 8) {
            if (value2 > 8.7) {
              throw new NotFoundException();
            }
            count = 8;
          }
          let offset = i2 / 2;
          if ((i2 & 1) == 0) {
            oddCounts[offset] = count;
            oddRoundingErrors[offset] = value2 - count;
          } else {
            evenCounts[offset] = count;
            evenRoundingErrors[offset] = value2 - count;
          }
        }
        this.adjustOddEvenCounts(numModules);
        let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i2 = oddCounts.length - 1; i2 >= 0; i2--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i2];
            oddChecksumPortion += oddCounts[i2] * weight;
          }
          oddSum += oddCounts[i2];
        }
        let evenChecksumPortion = 0;
        for (let i2 = evenCounts.length - 1; i2 >= 0; i2--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i2 + 1];
            evenChecksumPortion += evenCounts[i2] * weight;
          }
        }
        let checksumPortion = oddChecksumPortion + evenChecksumPortion;
        if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
          throw new NotFoundException();
        }
        let group = (13 - oddSum) / 2;
        let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
        let evenWidest = 9 - oddWidest;
        let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
        let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
        let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
        let gSum = RSSExpandedReader.GSUM[group];
        let value = vOdd * tEven + vEven + gSum;
        return new DataCharacter(value, checksumPortion);
      }
      static isNotA1left(pattern, isOddPattern, leftChar) {
        return !(pattern.getValue() == 0 && isOddPattern && leftChar);
      }
      adjustOddEvenCounts(numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        if (oddSum > 13) {
          decrementOdd = true;
        } else if (oddSum < 4) {
          incrementOdd = true;
        }
        let incrementEven = false;
        let decrementEven = false;
        if (evenSum > 13) {
          decrementEven = true;
        } else if (evenSum < 4) {
          incrementEven = true;
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) == 1;
        let evenParityBad = (evenSum & 1) == 0;
        if (mismatch == 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch == -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch == 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
    RSSExpandedReader.FINDER_PATTERNS = [
      Int32Array.from([1, 8, 4, 1]),
      Int32Array.from([3, 6, 4, 1]),
      Int32Array.from([3, 4, 6, 1]),
      Int32Array.from([3, 2, 8, 1]),
      Int32Array.from([2, 6, 5, 1]),
      Int32Array.from([2, 2, 9, 1])
    ];
    RSSExpandedReader.WEIGHTS = [
      [1, 3, 9, 27, 81, 32, 96, 77],
      [20, 60, 180, 118, 143, 7, 21, 63],
      [189, 145, 13, 39, 117, 140, 209, 205],
      [193, 157, 49, 147, 19, 57, 171, 91],
      [62, 186, 136, 197, 169, 85, 44, 132],
      [185, 133, 188, 142, 4, 12, 36, 108],
      [113, 128, 173, 97, 80, 29, 87, 50],
      [150, 28, 84, 41, 123, 158, 52, 156],
      [46, 138, 203, 187, 139, 206, 196, 166],
      [76, 17, 51, 153, 37, 111, 122, 155],
      [43, 129, 176, 106, 107, 110, 119, 146],
      [16, 48, 144, 10, 30, 90, 59, 177],
      [109, 116, 137, 200, 178, 112, 125, 164],
      [70, 210, 208, 202, 184, 130, 179, 115],
      [134, 191, 151, 31, 93, 68, 204, 190],
      [148, 22, 66, 198, 172, 94, 71, 2],
      [6, 18, 54, 162, 64, 192, 154, 40],
      [120, 149, 25, 75, 14, 42, 126, 167],
      [79, 26, 78, 23, 69, 207, 199, 175],
      [103, 98, 83, 38, 114, 131, 182, 124],
      [161, 61, 183, 127, 170, 88, 53, 159],
      [55, 165, 73, 8, 24, 72, 5, 15],
      [45, 135, 194, 160, 58, 174, 100, 89]
    ];
    RSSExpandedReader.FINDER_PAT_A = 0;
    RSSExpandedReader.FINDER_PAT_B = 1;
    RSSExpandedReader.FINDER_PAT_C = 2;
    RSSExpandedReader.FINDER_PAT_D = 3;
    RSSExpandedReader.FINDER_PAT_E = 4;
    RSSExpandedReader.FINDER_PAT_F = 5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F]
    ];
    RSSExpandedReader.MAX_PAIRS = 11;
    class Pair extends DataCharacter {
      constructor(value, checksumPortion, finderPattern) {
        super(value, checksumPortion);
        this.count = 0;
        this.finderPattern = finderPattern;
      }
      getFinderPattern() {
        return this.finderPattern;
      }
      getCount() {
        return this.count;
      }
      incrementCount() {
        this.count++;
      }
    }
    class RSS14Reader extends AbstractRSSReader {
      constructor() {
        super(...arguments);
        this.possibleLeftPairs = [];
        this.possibleRightPairs = [];
      }
      decodeRow(rowNumber, row, hints) {
        const leftPair = this.decodePair(row, false, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
        row.reverse();
        let rightPair = this.decodePair(row, true, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
        row.reverse();
        for (let left of this.possibleLeftPairs) {
          if (left.getCount() > 1) {
            for (let right of this.possibleRightPairs) {
              if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                return RSS14Reader.constructResult(left, right);
              }
            }
          }
        }
        throw new NotFoundException();
      }
      static addOrTally(possiblePairs, pair) {
        if (pair == null) {
          return;
        }
        let found = false;
        for (let other of possiblePairs) {
          if (other.getValue() === pair.getValue()) {
            other.incrementCount();
            found = true;
            break;
          }
        }
        if (!found) {
          possiblePairs.push(pair);
        }
      }
      reset() {
        this.possibleLeftPairs.length = 0;
        this.possibleRightPairs.length = 0;
      }
      static constructResult(leftPair, rightPair) {
        let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
        let text = new String(symbolValue).toString();
        let buffer = new StringBuilder();
        for (let i2 = 13 - text.length; i2 > 0; i2--) {
          buffer.append("0");
        }
        buffer.append(text);
        let checkDigit = 0;
        for (let i2 = 0; i2 < 13; i2++) {
          let digit = buffer.charAt(i2).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i2 & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buffer.append(checkDigit.toString());
        let leftPoints = leftPair.getFinderPattern().getResultPoints();
        let rightPoints = rightPair.getFinderPattern().getResultPoints();
        return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, new Date().getTime());
      }
      static checkChecksum(leftPair, rightPair) {
        let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
        let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
        if (targetCheckValue > 72) {
          targetCheckValue--;
        }
        if (targetCheckValue > 8) {
          targetCheckValue--;
        }
        return checkValue === targetCheckValue;
      }
      decodePair(row, right, rowNumber, hints) {
        try {
          let startEnd = this.findFinderPattern(row, right);
          let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
          let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (resultPointCallback != null) {
            let center = (startEnd[0] + startEnd[1]) / 2;
            if (right) {
              center = row.getSize() - 1 - center;
            }
            resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
          }
          let outside = this.decodeDataCharacter(row, pattern, true);
          let inside = this.decodeDataCharacter(row, pattern, false);
          return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
        } catch (err) {
          return null;
        }
      }
      decodeDataCharacter(row, pattern, outsideChar) {
        let counters = this.getDataCharacterCounters();
        for (let x = 0; x < counters.length; x++) {
          counters[x] = 0;
        }
        if (outsideChar) {
          OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
          for (let i2 = 0, j = counters.length - 1; i2 < j; i2++, j--) {
            let temp = counters[i2];
            counters[i2] = counters[j];
            counters[j] = temp;
          }
        }
        let numModules = outsideChar ? 16 : 15;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i2 = 0; i2 < counters.length; i2++) {
          let value = counters[i2] / elementWidth;
          let count = Math.floor(value + 0.5);
          if (count < 1) {
            count = 1;
          } else if (count > 8) {
            count = 8;
          }
          let offset = Math.floor(i2 / 2);
          if ((i2 & 1) === 0) {
            oddCounts[offset] = count;
            oddRoundingErrors[offset] = value - count;
          } else {
            evenCounts[offset] = count;
            evenRoundingErrors[offset] = value - count;
          }
        }
        this.adjustOddEvenCounts(outsideChar, numModules);
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i2 = oddCounts.length - 1; i2 >= 0; i2--) {
          oddChecksumPortion *= 9;
          oddChecksumPortion += oddCounts[i2];
          oddSum += oddCounts[i2];
        }
        let evenChecksumPortion = 0;
        let evenSum = 0;
        for (let i2 = evenCounts.length - 1; i2 >= 0; i2--) {
          evenChecksumPortion *= 9;
          evenChecksumPortion += evenCounts[i2];
          evenSum += evenCounts[i2];
        }
        let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
        if (outsideChar) {
          if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
            throw new NotFoundException();
          }
          let group = (12 - oddSum) / 2;
          let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
          let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.OUTSIDE_GSUM[group];
          return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
        } else {
          if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
            throw new NotFoundException();
          }
          let group = (10 - evenSum) / 2;
          let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
          let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.INSIDE_GSUM[group];
          return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
        }
      }
      findFinderPattern(row, rightFinderPattern) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let isWhite = false;
        let rowOffset = 0;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (rightFinderPattern === isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x = rowOffset; x < width; x++) {
          if (row.get(x) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === 3) {
              if (AbstractRSSReader.isFinderPattern(counters)) {
                return [patternStart, x];
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      parseFoundFinderPattern(row, rowNumber, right, startEnd) {
        let firstIsBlack = row.get(startEnd[0]);
        let firstElementStart = startEnd[0] - 1;
        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
          firstElementStart--;
        }
        firstElementStart++;
        const firstCounter = startEnd[0] - firstElementStart;
        const counters = this.getDecodeFinderCounters();
        const copy = new Int32Array(counters.length);
        System.arraycopy(counters, 0, copy, 1, counters.length - 1);
        copy[0] = firstCounter;
        const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
        let start = firstElementStart;
        let end = startEnd[1];
        if (right) {
          start = row.getSize() - 1 - start;
          end = row.getSize() - 1 - end;
        }
        return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
      }
      adjustOddEvenCounts(outsideChar, numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        let incrementEven = false;
        let decrementEven = false;
        if (outsideChar) {
          if (oddSum > 12) {
            decrementOdd = true;
          } else if (oddSum < 4) {
            incrementOdd = true;
          }
          if (evenSum > 12) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        } else {
          if (oddSum > 11) {
            decrementOdd = true;
          } else if (oddSum < 5) {
            incrementOdd = true;
          }
          if (evenSum > 10) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
        let evenParityBad = (evenSum & 1) === 1;
        if (mismatch === 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch === -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch === 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
    RSS14Reader.FINDER_PATTERNS = [
      Int32Array.from([3, 8, 2, 1]),
      Int32Array.from([3, 5, 5, 1]),
      Int32Array.from([3, 3, 7, 1]),
      Int32Array.from([3, 1, 9, 1]),
      Int32Array.from([2, 7, 4, 1]),
      Int32Array.from([2, 5, 6, 1]),
      Int32Array.from([2, 3, 8, 1]),
      Int32Array.from([1, 5, 7, 1]),
      Int32Array.from([1, 3, 9, 1])
    ];
    class MultiFormatOneDReader extends OneDReader {
      constructor(hints, verbose) {
        super();
        this.readers = [];
        this.verbose = verbose === true;
        const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
        if (possibleFormats) {
          if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
            this.readers.push(new MultiFormatUPCEANReader(hints));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
            this.readers.push(new Code39Reader(useCode39CheckDigit));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
            this.readers.push(new Code128Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
            this.readers.push(new ITFReader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
            this.readers.push(new RSS14Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
            this.readers.push(new RSSExpandedReader(this.verbose));
          }
        }
        if (this.readers.length === 0) {
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code39Reader());
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code128Reader());
          this.readers.push(new ITFReader());
          this.readers.push(new RSS14Reader());
          this.readers.push(new RSSExpandedReader(this.verbose));
        }
      }
      decodeRow(rowNumber, row, hints) {
        for (let i2 = 0; i2 < this.readers.length; i2++) {
          try {
            return this.readers[i2].decodeRow(rowNumber, row, hints);
          } catch (re) {
          }
        }
        throw new NotFoundException();
      }
      reset() {
        this.readers.forEach((reader) => reader.reset());
      }
    }
    class BrowserBarcodeReader extends BrowserCodeReader {
      constructor(timeBetweenScansMillis = 500, hints) {
        super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
      }
    }
    class ECBlocks {
      constructor(ecCodewords, ecBlocks1, ecBlocks2) {
        this.ecCodewords = ecCodewords;
        this.ecBlocks = [ecBlocks1];
        ecBlocks2 && this.ecBlocks.push(ecBlocks2);
      }
      getECCodewords() {
        return this.ecCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB {
      constructor(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version {
      constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
        this.versionNumber = versionNumber;
        this.symbolSizeRows = symbolSizeRows;
        this.symbolSizeColumns = symbolSizeColumns;
        this.dataRegionSizeRows = dataRegionSizeRows;
        this.dataRegionSizeColumns = dataRegionSizeColumns;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks.getECCodewords();
        const ecbArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getSymbolSizeRows() {
        return this.symbolSizeRows;
      }
      getSymbolSizeColumns() {
        return this.symbolSizeColumns;
      }
      getDataRegionSizeRows() {
        return this.dataRegionSizeRows;
      }
      getDataRegionSizeColumns() {
        return this.dataRegionSizeColumns;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
      static getVersionForDimensions(numRows, numColumns) {
        if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
          throw new FormatException();
        }
        for (let version2 of Version.VERSIONS) {
          if (version2.symbolSizeRows === numRows && version2.symbolSizeColumns === numColumns) {
            return version2;
          }
        }
        throw new FormatException();
      }
      toString() {
        return "" + this.versionNumber;
      }
      static buildVersions() {
        return [
          new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
          new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
          new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
          new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
          new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
          new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
          new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
          new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
          new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
          new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
          new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
          new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
          new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
          new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
          new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
          new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
          new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
          new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
          new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
          new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
          new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
          new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
          new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
          new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
          new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
          new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
          new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
          new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
          new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
          new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
        ];
      }
    }
    Version.VERSIONS = Version.buildVersions();
    class BitMatrixParser {
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
          throw new FormatException();
        }
        this.version = BitMatrixParser.readVersion(bitMatrix);
        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
        this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
      }
      getVersion() {
        return this.version;
      }
      static readVersion(bitMatrix) {
        const numRows = bitMatrix.getHeight();
        const numColumns = bitMatrix.getWidth();
        return Version.getVersionForDimensions(numRows, numColumns);
      }
      readCodewords() {
        const result = new Int8Array(this.version.getTotalCodewords());
        let resultOffset = 0;
        let row = 4;
        let column = 0;
        const numRows = this.mappingBitMatrix.getHeight();
        const numColumns = this.mappingBitMatrix.getWidth();
        let corner1Read = false;
        let corner2Read = false;
        let corner3Read = false;
        let corner4Read = false;
        do {
          if (row === numRows && column === 0 && !corner1Read) {
            result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner1Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
            result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner2Read = true;
          } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
            result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner3Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
            result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner4Read = true;
          } else {
            do {
              if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row -= 2;
              column += 2;
            } while (row >= 0 && column < numColumns);
            row += 1;
            column += 3;
            do {
              if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row += 2;
              column -= 2;
            } while (row < numRows && column >= 0);
            row += 3;
            column += 1;
          }
        } while (row < numRows || column < numColumns);
        if (resultOffset !== this.version.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      readModule(row, column, numRows, numColumns) {
        if (row < 0) {
          row += numRows;
          column += 4 - (numRows + 4 & 7);
        }
        if (column < 0) {
          column += numColumns;
          row += 4 - (numColumns + 4 & 7);
        }
        this.readMappingMatrix.set(column, row);
        return this.mappingBitMatrix.get(column, row);
      }
      readUtah(row, column, numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      readCorner1(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      readCorner2(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      readCorner3(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      readCorner4(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      extractDataRegion(bitMatrix) {
        const symbolSizeRows = this.version.getSymbolSizeRows();
        const symbolSizeColumns = this.version.getSymbolSizeColumns();
        if (bitMatrix.getHeight() !== symbolSizeRows) {
          throw new IllegalArgumentException("Dimension of bitMatrix must match the version size");
        }
        const dataRegionSizeRows = this.version.getDataRegionSizeRows();
        const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
        const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
        const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
        const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
        const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
        const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
        for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
          const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
          for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
            const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
            for (let i2 = 0; i2 < dataRegionSizeRows; ++i2) {
              const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i2;
              const writeRowOffset = dataRegionRowOffset + i2;
              for (let j = 0; j < dataRegionSizeColumns; ++j) {
                const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                  const writeColumnOffset = dataRegionColumnOffset + j;
                  bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                }
              }
            }
          }
        }
        return bitMatrixWithoutAlignment;
      }
    }
    class DataBlock {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      static getDataBlocks(rawCodewords, version2) {
        const ecBlocks = version2.getECBlocks();
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (let ecBlock of ecBlockArray) {
          for (let i2 = 0; i2 < ecBlock.getCount(); i2++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const longerBlocksTotalCodewords = result[0].codewords.length;
        const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
        const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
        let rawCodewordsOffset = 0;
        for (let i2 = 0; i2 < shorterBlocksNumDataCodewords; i2++) {
          for (let j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i2] = rawCodewords[rawCodewordsOffset++];
          }
        }
        const specialVersion = version2.getVersionNumber() === 24;
        const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
        for (let j = 0; j < numLongerBlocks; j++) {
          result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
        }
        const max = result[0].codewords.length;
        for (let i2 = longerBlocksNumDataCodewords; i2 < max; i2++) {
          for (let j = 0; j < numResultBlocks; j++) {
            const jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
            const iOffset = specialVersion && jOffset > 7 ? i2 - 1 : i2;
            result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        if (rawCodewordsOffset !== rawCodewords.length) {
          throw new IllegalArgumentException();
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    class BitSource {
      constructor(bytes) {
        this.bytes = bytes;
        this.byteOffset = 0;
        this.bitOffset = 0;
      }
      getBitOffset() {
        return this.bitOffset;
      }
      getByteOffset() {
        return this.byteOffset;
      }
      readBits(numBits) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
          throw new IllegalArgumentException("" + numBits);
        }
        let result = 0;
        let bitOffset = this.bitOffset;
        let byteOffset = this.byteOffset;
        const bytes = this.bytes;
        if (bitOffset > 0) {
          const bitsLeft = 8 - bitOffset;
          const toRead = numBits < bitsLeft ? numBits : bitsLeft;
          const bitsToNotRead = bitsLeft - toRead;
          const mask = 255 >> 8 - toRead << bitsToNotRead;
          result = (bytes[byteOffset] & mask) >> bitsToNotRead;
          numBits -= toRead;
          bitOffset += toRead;
          if (bitOffset === 8) {
            bitOffset = 0;
            byteOffset++;
          }
        }
        if (numBits > 0) {
          while (numBits >= 8) {
            result = result << 8 | bytes[byteOffset] & 255;
            byteOffset++;
            numBits -= 8;
          }
          if (numBits > 0) {
            const bitsToNotRead = 8 - numBits;
            const mask = 255 >> bitsToNotRead << bitsToNotRead;
            result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
            bitOffset += numBits;
          }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
      }
      available() {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
      }
    }
    var Mode;
    (function(Mode2) {
      Mode2[Mode2["PAD_ENCODE"] = 0] = "PAD_ENCODE";
      Mode2[Mode2["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
      Mode2[Mode2["C40_ENCODE"] = 2] = "C40_ENCODE";
      Mode2[Mode2["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
      Mode2[Mode2["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
      Mode2[Mode2["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
      Mode2[Mode2["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
    })(Mode || (Mode = {}));
    class DecodedBitStreamParser {
      static decode(bytes) {
        const bits = new BitSource(bytes);
        const result = new StringBuilder();
        const resultTrailer = new StringBuilder();
        const byteSegments = new Array();
        let mode = Mode.ASCII_ENCODE;
        do {
          if (mode === Mode.ASCII_ENCODE) {
            mode = this.decodeAsciiSegment(bits, result, resultTrailer);
          } else {
            switch (mode) {
              case Mode.C40_ENCODE:
                this.decodeC40Segment(bits, result);
                break;
              case Mode.TEXT_ENCODE:
                this.decodeTextSegment(bits, result);
                break;
              case Mode.ANSIX12_ENCODE:
                this.decodeAnsiX12Segment(bits, result);
                break;
              case Mode.EDIFACT_ENCODE:
                this.decodeEdifactSegment(bits, result);
                break;
              case Mode.BASE256_ENCODE:
                this.decodeBase256Segment(bits, result, byteSegments);
                break;
              default:
                throw new FormatException();
            }
            mode = Mode.ASCII_ENCODE;
          }
        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
        if (resultTrailer.length() > 0) {
          result.append(resultTrailer.toString());
        }
        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
      }
      static decodeAsciiSegment(bits, result, resultTrailer) {
        let upperShift = false;
        do {
          let oneByte = bits.readBits(8);
          if (oneByte === 0) {
            throw new FormatException();
          } else if (oneByte <= 128) {
            if (upperShift) {
              oneByte += 128;
            }
            result.append(String.fromCharCode(oneByte - 1));
            return Mode.ASCII_ENCODE;
          } else if (oneByte === 129) {
            return Mode.PAD_ENCODE;
          } else if (oneByte <= 229) {
            const value = oneByte - 130;
            if (value < 10) {
              result.append("0");
            }
            result.append("" + value);
          } else {
            switch (oneByte) {
              case 230:
                return Mode.C40_ENCODE;
              case 231:
                return Mode.BASE256_ENCODE;
              case 232:
                result.append(String.fromCharCode(29));
                break;
              case 233:
              case 234:
                break;
              case 235:
                upperShift = true;
                break;
              case 236:
                result.append("[)>05");
                resultTrailer.insert(0, "");
                break;
              case 237:
                result.append("[)>06");
                resultTrailer.insert(0, "");
                break;
              case 238:
                return Mode.ANSIX12_ENCODE;
              case 239:
                return Mode.TEXT_ENCODE;
              case 240:
                return Mode.EDIFACT_ENCODE;
              case 241:
                break;
              default:
                if (oneByte !== 254 || bits.available() !== 0) {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
        return Mode.ASCII_ENCODE;
      }
      static decodeC40Segment(bits, result) {
        let upperShift = false;
        const cValues = [];
        let shift = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i2 = 0; i2 < 3; i2++) {
            const cValue = cValues[i2];
            switch (shift) {
              case 0:
                if (cValue < 3) {
                  shift = cValue + 1;
                } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                  const c40char = this.C40_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift = 0;
                break;
              case 2:
                if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                  const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift = 0;
                break;
              case 3:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 224));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue + 96));
                }
                shift = 0;
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      static decodeTextSegment(bits, result) {
        let upperShift = false;
        let cValues = [];
        let shift = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i2 = 0; i2 < 3; i2++) {
            const cValue = cValues[i2];
            switch (shift) {
              case 0:
                if (cValue < 3) {
                  shift = cValue + 1;
                } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                  const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift = 0;
                break;
              case 2:
                if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift = 0;
                break;
              case 3:
                if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                  shift = 0;
                } else {
                  throw new FormatException();
                }
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      static decodeAnsiX12Segment(bits, result) {
        const cValues = [];
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i2 = 0; i2 < 3; i2++) {
            const cValue = cValues[i2];
            switch (cValue) {
              case 0:
                result.append("\r");
                break;
              case 1:
                result.append("*");
                break;
              case 2:
                result.append(">");
                break;
              case 3:
                result.append(" ");
                break;
              default:
                if (cValue < 14) {
                  result.append(String.fromCharCode(cValue + 44));
                } else if (cValue < 40) {
                  result.append(String.fromCharCode(cValue + 51));
                } else {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
      }
      static parseTwoBytes(firstByte, secondByte, result) {
        let fullBitValue = (firstByte << 8) + secondByte - 1;
        let temp = Math.floor(fullBitValue / 1600);
        result[0] = temp;
        fullBitValue -= temp * 1600;
        temp = Math.floor(fullBitValue / 40);
        result[1] = temp;
        result[2] = fullBitValue - temp * 40;
      }
      static decodeEdifactSegment(bits, result) {
        do {
          if (bits.available() <= 16) {
            return;
          }
          for (let i2 = 0; i2 < 4; i2++) {
            let edifactValue = bits.readBits(6);
            if (edifactValue === 31) {
              const bitsLeft = 8 - bits.getBitOffset();
              if (bitsLeft !== 8) {
                bits.readBits(bitsLeft);
              }
              return;
            }
            if ((edifactValue & 32) === 0) {
              edifactValue |= 64;
            }
            result.append(String.fromCharCode(edifactValue));
          }
        } while (bits.available() > 0);
      }
      static decodeBase256Segment(bits, result, byteSegments) {
        let codewordPosition = 1 + bits.getByteOffset();
        const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        let count;
        if (d1 === 0) {
          count = bits.available() / 8 | 0;
        } else if (d1 < 250) {
          count = d1;
        } else {
          count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        if (count < 0) {
          throw new FormatException();
        }
        const bytes = new Uint8Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          if (bits.available() < 8) {
            throw new FormatException();
          }
          bytes[i2] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        byteSegments.push(bytes);
        try {
          result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));
        } catch (uee) {
          throw new IllegalStateException("Platform does not support required encoding: " + uee.message);
        }
      }
      static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
        const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
        const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
        return tempVariable >= 0 ? tempVariable : tempVariable + 256;
      }
    }
    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_"
    ];
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z"
    ];
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
      "`",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "{",
      "|",
      "}",
      "~",
      String.fromCharCode(127)
    ];
    class Decoder$1 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
      }
      decode(bits) {
        const parser = new BitMatrixParser(bits);
        const version2 = parser.getVersion();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock.getDataBlocks(codewords, version2);
        let totalBytes = 0;
        for (let db of dataBlocks) {
          totalBytes += db.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        const dataBlocksCount = dataBlocks.length;
        for (let j = 0; j < dataBlocksCount; j++) {
          const dataBlock = dataBlocks[j];
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i2 = 0; i2 < numDataCodewords; i2++) {
            resultBytes[i2 * dataBlocksCount + j] = codewordBytes[i2];
          }
        }
        return DecodedBitStreamParser.decode(resultBytes);
      }
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i2 = 0; i2 < numDataCodewords; i2++) {
          codewordBytes[i2] = codewordsInts[i2];
        }
      }
    }
    class Detector$1 {
      constructor(image) {
        this.image = image;
        this.rectangleDetector = new WhiteRectangleDetector(this.image);
      }
      detect() {
        const cornerPoints = this.rectangleDetector.detect();
        let points = this.detectSolid1(cornerPoints);
        points = this.detectSolid2(points);
        points[3] = this.correctTopRight(points);
        if (!points[3]) {
          throw new NotFoundException();
        }
        points = this.shiftToModuleCenter(points);
        const topLeft = points[0];
        const bottomLeft = points[1];
        const bottomRight = points[2];
        const topRight = points[3];
        let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
        let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
        if ((dimensionTop & 1) === 1) {
          dimensionTop += 1;
        }
        if ((dimensionRight & 1) === 1) {
          dimensionRight += 1;
        }
        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
          dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
        }
        let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
        return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);
      }
      static shiftPoint(point, to, div) {
        let x = (to.getX() - point.getX()) / (div + 1);
        let y = (to.getY() - point.getY()) / (div + 1);
        return new ResultPoint(point.getX() + x, point.getY() + y);
      }
      static moveAway(point, fromX, fromY) {
        let x = point.getX();
        let y = point.getY();
        if (x < fromX) {
          x -= 1;
        } else {
          x += 1;
        }
        if (y < fromY) {
          y -= 1;
        } else {
          y += 1;
        }
        return new ResultPoint(x, y);
      }
      detectSolid1(cornerPoints) {
        let pointA = cornerPoints[0];
        let pointB = cornerPoints[1];
        let pointC = cornerPoints[3];
        let pointD = cornerPoints[2];
        let trAB = this.transitionsBetween(pointA, pointB);
        let trBC = this.transitionsBetween(pointB, pointC);
        let trCD = this.transitionsBetween(pointC, pointD);
        let trDA = this.transitionsBetween(pointD, pointA);
        let min = trAB;
        let points = [pointD, pointA, pointB, pointC];
        if (min > trBC) {
          min = trBC;
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        }
        if (min > trCD) {
          min = trCD;
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        if (min > trDA) {
          points[0] = pointC;
          points[1] = pointD;
          points[2] = pointA;
          points[3] = pointB;
        }
        return points;
      }
      detectSolid2(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let tr = this.transitionsBetween(pointA, pointD);
        let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
        let trBA = this.transitionsBetween(pointBs, pointA);
        let trCD = this.transitionsBetween(pointCs, pointD);
        if (trBA < trCD) {
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        } else {
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        return points;
      }
      correctTopRight(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let trTop = this.transitionsBetween(pointA, pointD);
        let trRight = this.transitionsBetween(pointB, pointD);
        let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
        trTop = this.transitionsBetween(pointAs, pointD);
        trRight = this.transitionsBetween(pointCs, pointD);
        let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
        let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
        if (!this.isValid(candidate1)) {
          if (this.isValid(candidate2)) {
            return candidate2;
          }
          return null;
        }
        if (!this.isValid(candidate2)) {
          return candidate1;
        }
        let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
        let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
        if (sumc1 > sumc2) {
          return candidate1;
        } else {
          return candidate2;
        }
      }
      shiftToModuleCenter(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let dimH = this.transitionsBetween(pointA, pointD) + 1;
        let dimV = this.transitionsBetween(pointC, pointD) + 1;
        let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
        dimH = this.transitionsBetween(pointAs, pointD) + 1;
        dimV = this.transitionsBetween(pointCs, pointD) + 1;
        if ((dimH & 1) === 1) {
          dimH += 1;
        }
        if ((dimV & 1) === 1) {
          dimV += 1;
        }
        let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
        let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
        pointA = Detector$1.moveAway(pointA, centerX, centerY);
        pointB = Detector$1.moveAway(pointB, centerX, centerY);
        pointC = Detector$1.moveAway(pointC, centerX, centerY);
        pointD = Detector$1.moveAway(pointD, centerX, centerY);
        let pointBs;
        let pointDs;
        pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
        pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
        pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
        pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
        pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
        pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
        pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
        return [pointAs, pointBs, pointCs, pointDs];
      }
      isValid(p2) {
        return p2.getX() >= 0 && p2.getX() < this.image.getWidth() && p2.getY() > 0 && p2.getY() < this.image.getHeight();
      }
      static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
      }
      transitionsBetween(from, to) {
        let fromX = Math.trunc(from.getX());
        let fromY = Math.trunc(from.getY());
        let toX = Math.trunc(to.getX());
        let toY = Math.trunc(to.getY());
        let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        let dx = Math.abs(toX - fromX);
        let dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        let ystep = fromY < toY ? 1 : -1;
        let xstep = fromX < toX ? 1 : -1;
        let transitions = 0;
        let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
        for (let x = fromX, y = fromY; x !== toX; x += xstep) {
          let isBlack = this.image.get(steep ? y : x, steep ? x : y);
          if (isBlack !== inBlack) {
            transitions++;
            inBlack = isBlack;
          }
          error += dy;
          if (error > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error -= dx;
          }
        }
        return transitions;
      }
    }
    class DataMatrixReader {
      constructor() {
        this.decoder = new Decoder$1();
      }
      decode(image, hints = null) {
        let decoderResult;
        let points;
        if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
          const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decode(bits);
          points = DataMatrixReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
          decoderResult = this.decoder.decode(detectorResult.getBits());
          points = detectorResult.getPoints();
        }
        const rawBytes = decoderResult.getRawBytes();
        const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      reset() {
      }
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack == null || rightBottomBlack == null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        const bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        const right = rightBottomBlack[0];
        const matrixWidth = (right - left + 1) / moduleSize;
        const matrixHeight = (bottom - top + 1) / moduleSize;
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        const nudge = moduleSize / 2;
        top += nudge;
        left += nudge;
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y = 0; y < matrixHeight; y++) {
          const iOffset = top + y * moduleSize;
          for (let x = 0; x < matrixWidth; x++) {
            if (image.get(left + x * moduleSize, iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const width = image.getWidth();
        let x = leftTopBlack[0];
        const y = leftTopBlack[1];
        while (x < width && image.get(x, y)) {
          x++;
        }
        if (x === width) {
          throw new NotFoundException();
        }
        const moduleSize = x - leftTopBlack[0];
        if (moduleSize === 0) {
          throw new NotFoundException();
        }
        return moduleSize;
      }
    }
    DataMatrixReader.NO_POINTS = [];
    class BrowserDatamatrixCodeReader extends BrowserCodeReader {
      constructor(timeBetweenScansMillis = 500) {
        super(new DataMatrixReader(), timeBetweenScansMillis);
      }
    }
    var ErrorCorrectionLevelValues;
    (function(ErrorCorrectionLevelValues2) {
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
    class ErrorCorrectionLevel {
      constructor(value, stringValue, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits;
        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      static fromString(s2) {
        switch (s2) {
          case "L":
            return ErrorCorrectionLevel.L;
          case "M":
            return ErrorCorrectionLevel.M;
          case "Q":
            return ErrorCorrectionLevel.Q;
          case "H":
            return ErrorCorrectionLevel.H;
          default:
            throw new ArgumentException(s2 + "not available");
        }
      }
      toString() {
        return this.stringValue;
      }
      equals(o2) {
        if (!(o2 instanceof ErrorCorrectionLevel)) {
          return false;
        }
        const other = o2;
        return this.value === other.value;
      }
      static forBits(bits) {
        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
          throw new IllegalArgumentException();
        }
        return ErrorCorrectionLevel.FOR_BITS.get(bits);
      }
    }
    ErrorCorrectionLevel.FOR_BITS = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.FOR_VALUE = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, "L", 1);
    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, "M", 0);
    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, "Q", 3);
    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, "H", 2);
    class FormatInformation {
      constructor(formatInfo) {
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
        this.dataMask = formatInfo & 7;
      }
      static numBitsDiffering(a2, b) {
        return Integer.bitCount(a2 ^ b);
      }
      static decodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
          return formatInfo;
        }
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
      }
      static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestFormatInfo = 0;
        for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
          const targetInfo = decodeInfo[0];
          if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
            return new FormatInformation(decodeInfo[1]);
          }
          let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
          if (bitsDifference < bestDifference) {
            bestFormatInfo = decodeInfo[1];
            bestDifference = bitsDifference;
          }
          if (maskedFormatInfo1 !== maskedFormatInfo2) {
            bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
            if (bitsDifference < bestDifference) {
              bestFormatInfo = decodeInfo[1];
              bestDifference = bitsDifference;
            }
          }
        }
        if (bestDifference <= 3) {
          return new FormatInformation(bestFormatInfo);
        }
        return null;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getDataMask() {
        return this.dataMask;
      }
      hashCode() {
        return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
      }
      equals(o2) {
        if (!(o2 instanceof FormatInformation)) {
          return false;
        }
        const other = o2;
        return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
      }
    }
    FormatInformation.FORMAT_INFO_MASK_QR = 21522;
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
      Int32Array.from([21522, 0]),
      Int32Array.from([20773, 1]),
      Int32Array.from([24188, 2]),
      Int32Array.from([23371, 3]),
      Int32Array.from([17913, 4]),
      Int32Array.from([16590, 5]),
      Int32Array.from([20375, 6]),
      Int32Array.from([19104, 7]),
      Int32Array.from([30660, 8]),
      Int32Array.from([29427, 9]),
      Int32Array.from([32170, 10]),
      Int32Array.from([30877, 11]),
      Int32Array.from([26159, 12]),
      Int32Array.from([25368, 13]),
      Int32Array.from([27713, 14]),
      Int32Array.from([26998, 15]),
      Int32Array.from([5769, 16]),
      Int32Array.from([5054, 17]),
      Int32Array.from([7399, 18]),
      Int32Array.from([6608, 19]),
      Int32Array.from([1890, 20]),
      Int32Array.from([597, 21]),
      Int32Array.from([3340, 22]),
      Int32Array.from([2107, 23]),
      Int32Array.from([13663, 24]),
      Int32Array.from([12392, 25]),
      Int32Array.from([16177, 26]),
      Int32Array.from([14854, 27]),
      Int32Array.from([9396, 28]),
      Int32Array.from([8579, 29]),
      Int32Array.from([11994, 30]),
      Int32Array.from([11245, 31])
    ];
    class ECBlocks$1 {
      constructor(ecCodewordsPerBlock, ...ecBlocks) {
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        this.ecBlocks = ecBlocks;
      }
      getECCodewordsPerBlock() {
        return this.ecCodewordsPerBlock;
      }
      getNumBlocks() {
        let total = 0;
        const ecBlocks = this.ecBlocks;
        for (const ecBlock of ecBlocks) {
          total += ecBlock.getCount();
        }
        return total;
      }
      getTotalECCodewords() {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB$1 {
      constructor(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version$1 {
      constructor(versionNumber, alignmentPatternCenters, ...ecBlocks) {
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        const ecbArray = ecBlocks[0].getECBlocks();
        for (const ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getAlignmentPatternCenters() {
        return this.alignmentPatternCenters;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getDimensionForVersion() {
        return 17 + 4 * this.versionNumber;
      }
      getECBlocksForLevel(ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
      }
      static getProvisionalVersionForDimension(dimension) {
        if (dimension % 4 !== 1) {
          throw new FormatException();
        }
        try {
          return this.getVersionForNumber((dimension - 17) / 4);
        } catch (ignored) {
          throw new FormatException();
        }
      }
      static getVersionForNumber(versionNumber) {
        if (versionNumber < 1 || versionNumber > 40) {
          throw new IllegalArgumentException();
        }
        return Version$1.VERSIONS[versionNumber - 1];
      }
      static decodeVersionInformation(versionBits) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestVersion = 0;
        for (let i2 = 0; i2 < Version$1.VERSION_DECODE_INFO.length; i2++) {
          const targetVersion = Version$1.VERSION_DECODE_INFO[i2];
          if (targetVersion === versionBits) {
            return Version$1.getVersionForNumber(i2 + 7);
          }
          const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
          if (bitsDifference < bestDifference) {
            bestVersion = i2 + 7;
            bestDifference = bitsDifference;
          }
        }
        if (bestDifference <= 3) {
          return Version$1.getVersionForNumber(bestVersion);
        }
        return null;
      }
      buildFunctionPattern() {
        const dimension = this.getDimensionForVersion();
        const bitMatrix = new BitMatrix(dimension);
        bitMatrix.setRegion(0, 0, 9, 9);
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        const max = this.alignmentPatternCenters.length;
        for (let x = 0; x < max; x++) {
          const i2 = this.alignmentPatternCenters[x] - 2;
          for (let y = 0; y < max; y++) {
            if (x === 0 && (y === 0 || y === max - 1) || x === max - 1 && y === 0) {
              continue;
            }
            bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i2, 5, 5);
          }
        }
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
          bitMatrix.setRegion(dimension - 11, 0, 3, 6);
          bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
      }
      toString() {
        return "" + this.versionNumber;
      }
    }
    Version$1.VERSION_DECODE_INFO = Int32Array.from([
      31892,
      34236,
      39577,
      42195,
      48118,
      51042,
      55367,
      58893,
      63784,
      68472,
      70749,
      76311,
      79154,
      84390,
      87683,
      92361,
      96236,
      102084,
      102881,
      110507,
      110734,
      117786,
      119615,
      126325,
      127568,
      133589,
      136944,
      141498,
      145311,
      150283,
      152622,
      158308,
      161089,
      167017
    ]);
    Version$1.VERSIONS = [
      new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
      new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
      new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
      new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
      new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
      new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
      new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
      new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
      new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
      new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
      new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
      new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
      new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
      new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
      new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
      new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
      new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
      new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
      new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
      new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
      new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
      new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
      new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
      new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
      new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
      new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
      new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
      new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
      new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
      new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
      new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
      new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
      new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
      new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
      new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
      new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
      new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
      new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
      new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
      new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
    ];
    var DataMaskValues;
    (function(DataMaskValues2) {
      DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
      DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
      DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
      DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
      DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
      DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
      DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
      DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
    })(DataMaskValues || (DataMaskValues = {}));
    class DataMask {
      constructor(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
      }
      unmaskBitMatrix(bits, dimension) {
        for (let i2 = 0; i2 < dimension; i2++) {
          for (let j = 0; j < dimension; j++) {
            if (this.isMasked(i2, j)) {
              bits.flip(j, i2);
            }
          }
        }
      }
    }
    DataMask.values = /* @__PURE__ */ new Map([
      [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i2, j) => {
        return (i2 + j & 1) === 0;
      })],
      [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i2, j) => {
        return (i2 & 1) === 0;
      })],
      [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i2, j) => {
        return j % 3 === 0;
      })],
      [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i2, j) => {
        return (i2 + j) % 3 === 0;
      })],
      [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i2, j) => {
        return (Math.floor(i2 / 2) + Math.floor(j / 3) & 1) === 0;
      })],
      [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i2, j) => {
        return i2 * j % 6 === 0;
      })],
      [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i2, j) => {
        return i2 * j % 6 < 3;
      })],
      [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i2, j) => {
        return (i2 + j + i2 * j % 3 & 1) === 0;
      })]
    ]);
    class BitMatrixParser$1 {
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 3) !== 1) {
          throw new FormatException();
        }
        this.bitMatrix = bitMatrix;
      }
      readFormatInformation() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
          return this.parsedFormatInfo;
        }
        let formatInfoBits1 = 0;
        for (let i2 = 0; i2 < 6; i2++) {
          formatInfoBits1 = this.copyBit(i2, 8, formatInfoBits1);
        }
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        for (let j = 5; j >= 0; j--) {
          formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
        }
        const dimension = this.bitMatrix.getHeight();
        let formatInfoBits2 = 0;
        const jMin = dimension - 7;
        for (let j = dimension - 1; j >= jMin; j--) {
          formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
        }
        for (let i2 = dimension - 8; i2 < dimension; i2++) {
          formatInfoBits2 = this.copyBit(i2, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
          return this.parsedFormatInfo;
        }
        throw new FormatException();
      }
      readVersion() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
          return this.parsedVersion;
        }
        const dimension = this.bitMatrix.getHeight();
        const provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
          return Version$1.getVersionForNumber(provisionalVersion);
        }
        let versionBits = 0;
        const ijMin = dimension - 11;
        for (let j = 5; j >= 0; j--) {
          for (let i2 = dimension - 9; i2 >= ijMin; i2--) {
            versionBits = this.copyBit(i2, j, versionBits);
          }
        }
        let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        versionBits = 0;
        for (let i2 = 5; i2 >= 0; i2--) {
          for (let j = dimension - 9; j >= ijMin; j--) {
            versionBits = this.copyBit(i2, j, versionBits);
          }
        }
        theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        throw new FormatException();
      }
      copyBit(i2, j, versionBits) {
        const bit = this.isMirror ? this.bitMatrix.get(j, i2) : this.bitMatrix.get(i2, j);
        return bit ? versionBits << 1 | 1 : versionBits << 1;
      }
      readCodewords() {
        const formatInfo = this.readFormatInformation();
        const version2 = this.readVersion();
        const dataMask = DataMask.values.get(formatInfo.getDataMask());
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        const functionPattern = version2.buildFunctionPattern();
        let readingUp = true;
        const result = new Uint8Array(version2.getTotalCodewords());
        let resultOffset = 0;
        let currentByte = 0;
        let bitsRead = 0;
        for (let j = dimension - 1; j > 0; j -= 2) {
          if (j === 6) {
            j--;
          }
          for (let count = 0; count < dimension; count++) {
            const i2 = readingUp ? dimension - 1 - count : count;
            for (let col = 0; col < 2; col++) {
              if (!functionPattern.get(j - col, i2)) {
                bitsRead++;
                currentByte <<= 1;
                if (this.bitMatrix.get(j - col, i2)) {
                  currentByte |= 1;
                }
                if (bitsRead === 8) {
                  result[resultOffset++] = currentByte;
                  bitsRead = 0;
                  currentByte = 0;
                }
              }
            }
          }
          readingUp = !readingUp;
        }
        if (resultOffset !== version2.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      remask() {
        if (this.parsedFormatInfo === null) {
          return;
        }
        const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
      }
      setMirror(isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
      }
      mirror() {
        const bitMatrix = this.bitMatrix;
        for (let x = 0, width = bitMatrix.getWidth(); x < width; x++) {
          for (let y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
            if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
              bitMatrix.flip(y, x);
              bitMatrix.flip(x, y);
            }
          }
        }
      }
    }
    class DataBlock$1 {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      static getDataBlocks(rawCodewords, version2, ecLevel) {
        if (rawCodewords.length !== version2.getTotalCodewords()) {
          throw new IllegalArgumentException();
        }
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (const ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (const ecBlock of ecBlockArray) {
          for (let i2 = 0; i2 < ecBlock.getCount(); i2++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const shorterBlocksTotalCodewords = result[0].codewords.length;
        let longerBlocksStartAt = result.length - 1;
        while (longerBlocksStartAt >= 0) {
          const numCodewords = result[longerBlocksStartAt].codewords.length;
          if (numCodewords === shorterBlocksTotalCodewords) {
            break;
          }
          longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        let rawCodewordsOffset = 0;
        for (let i2 = 0; i2 < shorterBlocksNumDataCodewords; i2++) {
          for (let j = 0; j < numResultBlocks; j++) {
            result[j].codewords[i2] = rawCodewords[rawCodewordsOffset++];
          }
        }
        for (let j = longerBlocksStartAt; j < numResultBlocks; j++) {
          result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        const max = result[0].codewords.length;
        for (let i2 = shorterBlocksNumDataCodewords; i2 < max; i2++) {
          for (let j = 0; j < numResultBlocks; j++) {
            const iOffset = j < longerBlocksStartAt ? i2 : i2 + 1;
            result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    var ModeValues;
    (function(ModeValues2) {
      ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
      ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
      ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
      ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
      ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
      ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
      ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
      ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
      ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
      ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
    })(ModeValues || (ModeValues = {}));
    class Mode$1 {
      constructor(value, stringValue, characterCountBitsForVersions, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits;
        Mode$1.FOR_BITS.set(bits, this);
        Mode$1.FOR_VALUE.set(value, this);
      }
      static forBits(bits) {
        const mode = Mode$1.FOR_BITS.get(bits);
        if (void 0 === mode) {
          throw new IllegalArgumentException();
        }
        return mode;
      }
      getCharacterCountBits(version2) {
        const versionNumber = version2.getVersionNumber();
        let offset;
        if (versionNumber <= 9) {
          offset = 0;
        } else if (versionNumber <= 26) {
          offset = 1;
        } else {
          offset = 2;
        }
        return this.characterCountBitsForVersions[offset];
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      equals(o2) {
        if (!(o2 instanceof Mode$1)) {
          return false;
        }
        const other = o2;
        return this.value === other.value;
      }
      toString() {
        return this.stringValue;
      }
    }
    Mode$1.FOR_BITS = /* @__PURE__ */ new Map();
    Mode$1.FOR_VALUE = /* @__PURE__ */ new Map();
    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
    Mode$1.ECI = new Mode$1(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
    class DecodedBitStreamParser$1 {
      static decode(bytes, version2, ecLevel, hints) {
        const bits = new BitSource(bytes);
        let result = new StringBuilder();
        const byteSegments = new Array();
        let symbolSequence = -1;
        let parityData = -1;
        try {
          let currentCharacterSetECI = null;
          let fc1InEffect = false;
          let mode;
          do {
            if (bits.available() < 4) {
              mode = Mode$1.TERMINATOR;
            } else {
              const modeBits = bits.readBits(4);
              mode = Mode$1.forBits(modeBits);
            }
            switch (mode) {
              case Mode$1.TERMINATOR:
                break;
              case Mode$1.FNC1_FIRST_POSITION:
              case Mode$1.FNC1_SECOND_POSITION:
                fc1InEffect = true;
                break;
              case Mode$1.STRUCTURED_APPEND:
                if (bits.available() < 16) {
                  throw new FormatException();
                }
                symbolSequence = bits.readBits(8);
                parityData = bits.readBits(8);
                break;
              case Mode$1.ECI:
                const value = DecodedBitStreamParser$1.parseECIValue(bits);
                currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                if (currentCharacterSetECI === null) {
                  throw new FormatException();
                }
                break;
              case Mode$1.HANZI:
                const subset = bits.readBits(4);
                const countHanzi = bits.readBits(mode.getCharacterCountBits(version2));
                if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                  DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);
                }
                break;
              default:
                const count = bits.readBits(mode.getCharacterCountBits(version2));
                switch (mode) {
                  case Mode$1.NUMERIC:
                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count);
                    break;
                  case Mode$1.ALPHANUMERIC:
                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                    break;
                  case Mode$1.BYTE:
                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                    break;
                  case Mode$1.KANJI:
                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count);
                    break;
                  default:
                    throw new FormatException();
                }
                break;
            }
          } while (mode !== Mode$1.TERMINATOR);
        } catch (iae) {
          throw new FormatException();
        }
        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
      }
      static decodeHanziSegment(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count);
        let offset = 0;
        while (count > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
          if (assembledTwoBytes < 959) {
            assembledTwoBytes += 41377;
          } else {
            assembledTwoBytes += 42657;
          }
          buffer[offset] = assembledTwoBytes >> 8 & 255;
          buffer[offset + 1] = assembledTwoBytes & 255;
          offset += 2;
          count--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeKanjiSegment(bits, result, count) {
        if (count * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count);
        let offset = 0;
        while (count > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
          if (assembledTwoBytes < 7936) {
            assembledTwoBytes += 33088;
          } else {
            assembledTwoBytes += 49472;
          }
          buffer[offset] = assembledTwoBytes >> 8;
          buffer[offset + 1] = assembledTwoBytes;
          offset += 2;
          count--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints) {
        if (8 * count > bits.available()) {
          throw new FormatException();
        }
        const readBytes = new Uint8Array(count);
        for (let i2 = 0; i2 < count; i2++) {
          readBytes[i2] = bits.readBits(8);
        }
        let encoding;
        if (currentCharacterSetECI === null) {
          encoding = StringUtils.guessEncoding(readBytes, hints);
        } else {
          encoding = currentCharacterSetECI.getName();
        }
        try {
          result.append(StringEncoding.decode(readBytes, encoding));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
        byteSegments.push(readBytes);
      }
      static toAlphaNumericChar(value) {
        if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
          throw new FormatException();
        }
        return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
      }
      static decodeAlphanumericSegment(bits, result, count, fc1InEffect) {
        const start = result.length();
        while (count > 1) {
          if (bits.available() < 11) {
            throw new FormatException();
          }
          const nextTwoCharsBits = bits.readBits(11);
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
          count -= 2;
        }
        if (count === 1) {
          if (bits.available() < 6) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
        }
        if (fc1InEffect) {
          for (let i2 = start; i2 < result.length(); i2++) {
            if (result.charAt(i2) === "%") {
              if (i2 < result.length() - 1 && result.charAt(i2 + 1) === "%") {
                result.deleteCharAt(i2 + 1);
              } else {
                result.setCharAt(i2, String.fromCharCode(29));
              }
            }
          }
        }
      }
      static decodeNumericSegment(bits, result, count) {
        while (count >= 3) {
          if (bits.available() < 10) {
            throw new FormatException();
          }
          const threeDigitsBits = bits.readBits(10);
          if (threeDigitsBits >= 1e3) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
          count -= 3;
        }
        if (count === 2) {
          if (bits.available() < 7) {
            throw new FormatException();
          }
          const twoDigitsBits = bits.readBits(7);
          if (twoDigitsBits >= 100) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
        } else if (count === 1) {
          if (bits.available() < 4) {
            throw new FormatException();
          }
          const digitBits = bits.readBits(4);
          if (digitBits >= 10) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
        }
      }
      static parseECIValue(bits) {
        const firstByte = bits.readBits(8);
        if ((firstByte & 128) === 0) {
          return firstByte & 127;
        }
        if ((firstByte & 192) === 128) {
          const secondByte = bits.readBits(8);
          return (firstByte & 63) << 8 & 4294967295 | secondByte;
        }
        if ((firstByte & 224) === 192) {
          const secondThirdBytes = bits.readBits(16);
          return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
        }
        throw new FormatException();
      }
    }
    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    DecodedBitStreamParser$1.GB2312_SUBSET = 1;
    class QRCodeDecoderMetaData {
      constructor(mirrored) {
        this.mirrored = mirrored;
      }
      isMirrored() {
        return this.mirrored;
      }
      applyMirroredCorrection(points) {
        if (!this.mirrored || points === null || points.length < 3) {
          return;
        }
        const bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
      }
    }
    class Decoder$2 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
      }
      decodeBooleanArray(image, hints) {
        return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
      }
      decodeBitMatrix(bits, hints) {
        const parser = new BitMatrixParser$1(bits);
        let ex = null;
        try {
          return this.decodeBitMatrixParser(parser, hints);
        } catch (e2) {
          ex = e2;
        }
        try {
          parser.remask();
          parser.setMirror(true);
          parser.readVersion();
          parser.readFormatInformation();
          parser.mirror();
          const result = this.decodeBitMatrixParser(parser, hints);
          result.setOther(new QRCodeDecoderMetaData(true));
          return result;
        } catch (e2) {
          if (ex !== null) {
            throw ex;
          }
          throw e2;
        }
      }
      decodeBitMatrixParser(parser, hints) {
        const version2 = parser.readVersion();
        const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock$1.getDataBlocks(codewords, version2, ecLevel);
        let totalBytes = 0;
        for (const dataBlock of dataBlocks) {
          totalBytes += dataBlock.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        let resultOffset = 0;
        for (const dataBlock of dataBlocks) {
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i2 = 0; i2 < numDataCodewords; i2++) {
            resultBytes[resultOffset++] = codewordBytes[i2];
          }
        }
        return DecodedBitStreamParser$1.decode(resultBytes, version2, ecLevel, hints);
      }
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i2 = 0; i2 < numDataCodewords; i2++) {
          codewordBytes[i2] = codewordsInts[i2];
        }
      }
    }
    class AlignmentPattern extends ResultPoint {
      constructor(posX, posY, estimatedModuleSize) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
      }
      aboutEquals(moduleSize, i2, j) {
        if (Math.abs(i2 - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      combineEstimate(i2, j, newModuleSize) {
        const combinedX = (this.getX() + j) / 2;
        const combinedY = (this.getY() + i2) / 2;
        const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
      }
    }
    class AlignmentPatternFinder {
      constructor(image, startX, startY, width, height, moduleSize, resultPointCallback) {
        this.image = image;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(3);
      }
      find() {
        const startX = this.startX;
        const height = this.height;
        const width = this.width;
        const maxJ = startX + width;
        const middleI = this.startY + height / 2;
        const stateCount = new Int32Array(3);
        const image = this.image;
        for (let iGen = 0; iGen < height; iGen++) {
          const i2 = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          let j = startX;
          while (j < maxJ && !image.get(j, i2)) {
            j++;
          }
          let currentState = 0;
          while (j < maxJ) {
            if (image.get(j, i2)) {
              if (currentState === 1) {
                stateCount[1]++;
              } else {
                if (currentState === 2) {
                  if (this.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i2, j);
                    if (confirmed !== null) {
                      return confirmed;
                    }
                  }
                  stateCount[0] = stateCount[2];
                  stateCount[1] = 1;
                  stateCount[2] = 0;
                  currentState = 1;
                } else {
                  stateCount[++currentState]++;
                }
              }
            } else {
              if (currentState === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            }
            j++;
          }
          if (this.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i2, maxJ);
            if (confirmed !== null) {
              return confirmed;
            }
          }
        }
        if (this.possibleCenters.length !== 0) {
          return this.possibleCenters[0];
        }
        throw new NotFoundException();
      }
      static centerFromEnd(stateCount, end) {
        return end - stateCount[2] - stateCount[1] / 2;
      }
      foundPatternCross(stateCount) {
        const moduleSize = this.moduleSize;
        const maxVariance = moduleSize / 2;
        for (let i2 = 0; i2 < 3; i2++) {
          if (Math.abs(moduleSize - stateCount[i2]) >= maxVariance) {
            return false;
          }
        }
        return true;
      }
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        let i2 = startI;
        while (i2 >= 0 && image.get(centerJ, i2) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i2--;
        }
        if (i2 < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i2 >= 0 && !image.get(centerJ, i2) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i2--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i2 = startI + 1;
        while (i2 < maxI && image.get(centerJ, i2) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i2++;
        }
        if (i2 === maxI || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i2 < maxI && !image.get(centerJ, i2) && stateCount[2] <= maxCount) {
          stateCount[2]++;
          i2++;
        }
        if (stateCount[2] > maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i2) : NaN;
      }
      handlePossibleCenter(stateCount, i2, j) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
        const centerI = this.crossCheckVertical(i2, centerJ, 2 * stateCount[1], stateCountTotal);
        if (!isNaN(centerI)) {
          const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
          for (const center of this.possibleCenters) {
            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
              return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
            }
          }
          const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
          this.possibleCenters.push(point);
          if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
            this.resultPointCallback.foundPossibleResultPoint(point);
          }
        }
        return null;
      }
    }
    class FinderPattern$1 extends ResultPoint {
      constructor(posX, posY, estimatedModuleSize, count) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
        this.count = count;
        if (void 0 === count) {
          this.count = 1;
        }
      }
      getEstimatedModuleSize() {
        return this.estimatedModuleSize;
      }
      getCount() {
        return this.count;
      }
      aboutEquals(moduleSize, i2, j) {
        if (Math.abs(i2 - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      combineEstimate(i2, j, newModuleSize) {
        const combinedCount = this.count + 1;
        const combinedX = (this.count * this.getX() + j) / combinedCount;
        const combinedY = (this.count * this.getY() + i2) / combinedCount;
        const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
      }
    }
    class FinderPatternInfo {
      constructor(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
    }
    class FinderPatternFinder {
      constructor(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
      }
      getImage() {
        return this.image;
      }
      getPossibleCenters() {
        return this.possibleCenters;
      }
      find(hints) {
        const tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.TRY_HARDER);
        const pureBarcode = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE);
        const image = this.image;
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));
        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
          iSkip = FinderPatternFinder.MIN_SKIP;
        }
        let done = false;
        const stateCount = new Int32Array(5);
        for (let i2 = iSkip - 1; i2 < maxI && !done; i2 += iSkip) {
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          stateCount[3] = 0;
          stateCount[4] = 0;
          let currentState = 0;
          for (let j = 0; j < maxJ; j++) {
            if (image.get(j, i2)) {
              if ((currentState & 1) === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            } else {
              if ((currentState & 1) === 0) {
                if (currentState === 4) {
                  if (FinderPatternFinder.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i2, j, pureBarcode);
                    if (confirmed === true) {
                      iSkip = 2;
                      if (this.hasSkipped === true) {
                        done = this.haveMultiplyConfirmedCenters();
                      } else {
                        const rowSkip = this.findRowSkip();
                        if (rowSkip > stateCount[2]) {
                          i2 += rowSkip - stateCount[2] - iSkip;
                          j = maxJ - 1;
                        }
                      }
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3;
                      continue;
                    }
                    currentState = 0;
                    stateCount[0] = 0;
                    stateCount[1] = 0;
                    stateCount[2] = 0;
                    stateCount[3] = 0;
                    stateCount[4] = 0;
                  } else {
                    stateCount[0] = stateCount[2];
                    stateCount[1] = stateCount[3];
                    stateCount[2] = stateCount[4];
                    stateCount[3] = 1;
                    stateCount[4] = 0;
                    currentState = 3;
                  }
                } else {
                  stateCount[++currentState]++;
                }
              } else {
                stateCount[currentState]++;
              }
            }
          }
          if (FinderPatternFinder.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i2, maxJ, pureBarcode);
            if (confirmed === true) {
              iSkip = stateCount[0];
              if (this.hasSkipped) {
                done = this.haveMultiplyConfirmedCenters();
              }
            }
          }
        }
        const patternInfo = this.selectBestPatterns();
        ResultPoint.orderBestPatterns(patternInfo);
        return new FinderPatternInfo(patternInfo);
      }
      static centerFromEnd(stateCount, end) {
        return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
      }
      static foundPatternCross(stateCount) {
        let totalModuleSize = 0;
        for (let i2 = 0; i2 < 5; i2++) {
          const count = stateCount[i2];
          if (count === 0) {
            return false;
          }
          totalModuleSize += count;
        }
        if (totalModuleSize < 7) {
          return false;
        }
        const moduleSize = totalModuleSize / 7;
        const maxVariance = moduleSize / 2;
        return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
      }
      getCrossCheckStateCount() {
        const crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
      }
      crossCheckDiagonal(startI, centerJ, maxCount, originalStateCountTotal) {
        const stateCount = this.getCrossCheckStateCount();
        let i2 = 0;
        const image = this.image;
        while (startI >= i2 && centerJ >= i2 && image.get(centerJ - i2, startI - i2)) {
          stateCount[2]++;
          i2++;
        }
        if (startI < i2 || centerJ < i2) {
          return false;
        }
        while (startI >= i2 && centerJ >= i2 && !image.get(centerJ - i2, startI - i2) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i2++;
        }
        if (startI < i2 || centerJ < i2 || stateCount[1] > maxCount) {
          return false;
        }
        while (startI >= i2 && centerJ >= i2 && image.get(centerJ - i2, startI - i2) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i2++;
        }
        if (stateCount[0] > maxCount) {
          return false;
        }
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        i2 = 1;
        while (startI + i2 < maxI && centerJ + i2 < maxJ && image.get(centerJ + i2, startI + i2)) {
          stateCount[2]++;
          i2++;
        }
        if (startI + i2 >= maxI || centerJ + i2 >= maxJ) {
          return false;
        }
        while (startI + i2 < maxI && centerJ + i2 < maxJ && !image.get(centerJ + i2, startI + i2) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i2++;
        }
        if (startI + i2 >= maxI || centerJ + i2 >= maxJ || stateCount[3] >= maxCount) {
          return false;
        }
        while (startI + i2 < maxI && centerJ + i2 < maxJ && image.get(centerJ + i2, startI + i2) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i2++;
        }
        if (stateCount[4] >= maxCount) {
          return false;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);
      }
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.getCrossCheckStateCount();
        let i2 = startI;
        while (i2 >= 0 && image.get(centerJ, i2)) {
          stateCount[2]++;
          i2--;
        }
        if (i2 < 0) {
          return NaN;
        }
        while (i2 >= 0 && !image.get(centerJ, i2) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i2--;
        }
        if (i2 < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i2 >= 0 && image.get(centerJ, i2) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i2--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i2 = startI + 1;
        while (i2 < maxI && image.get(centerJ, i2)) {
          stateCount[2]++;
          i2++;
        }
        if (i2 === maxI) {
          return NaN;
        }
        while (i2 < maxI && !image.get(centerJ, i2) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i2++;
        }
        if (i2 === maxI || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (i2 < maxI && image.get(centerJ, i2) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i2++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i2) : NaN;
      }
      crossCheckHorizontal(startJ, centerI, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxJ = image.getWidth();
        const stateCount = this.getCrossCheckStateCount();
        let j = startJ;
        while (j >= 0 && image.get(j, centerI)) {
          stateCount[2]++;
          j--;
        }
        if (j < 0) {
          return NaN;
        }
        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          j--;
        }
        if (j < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          j--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        j = startJ + 1;
        while (j < maxJ && image.get(j, centerI)) {
          stateCount[2]++;
          j++;
        }
        if (j === maxJ) {
          return NaN;
        }
        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
          stateCount[3]++;
          j++;
        }
        if (j === maxJ || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
          stateCount[4]++;
          j++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
      }
      handlePossibleCenter(stateCount, i2, j, pureBarcode) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
        let centerI = this.crossCheckVertical(i2, Math.floor(centerJ), stateCount[2], stateCountTotal);
        if (!isNaN(centerI)) {
          centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);
          if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(Math.floor(centerI), Math.floor(centerJ), stateCount[2], stateCountTotal))) {
            const estimatedModuleSize = stateCountTotal / 7;
            let found = false;
            const possibleCenters = this.possibleCenters;
            for (let index = 0, length = possibleCenters.length; index < length; index++) {
              const center = possibleCenters[index];
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                found = true;
                break;
              }
            }
            if (!found) {
              const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
              possibleCenters.push(point);
              if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                this.resultPointCallback.foundPossibleResultPoint(point);
              }
            }
            return true;
          }
        }
        return false;
      }
      findRowSkip() {
        const max = this.possibleCenters.length;
        if (max <= 1) {
          return 0;
        }
        let firstConfirmedCenter = null;
        for (const center of this.possibleCenters) {
          if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            if (firstConfirmedCenter == null) {
              firstConfirmedCenter = center;
            } else {
              this.hasSkipped = true;
              return Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
            }
          }
        }
        return 0;
      }
      haveMultiplyConfirmedCenters() {
        let confirmedCount = 0;
        let totalModuleSize = 0;
        const max = this.possibleCenters.length;
        for (const pattern of this.possibleCenters) {
          if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            confirmedCount++;
            totalModuleSize += pattern.getEstimatedModuleSize();
          }
        }
        if (confirmedCount < 3) {
          return false;
        }
        const average = totalModuleSize / max;
        let totalDeviation = 0;
        for (const pattern of this.possibleCenters) {
          totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
        }
        return totalDeviation <= 0.05 * totalModuleSize;
      }
      selectBestPatterns() {
        const startSize = this.possibleCenters.length;
        if (startSize < 3) {
          throw new NotFoundException();
        }
        const possibleCenters = this.possibleCenters;
        let average;
        if (startSize > 3) {
          let totalModuleSize = 0;
          let square = 0;
          for (const center of this.possibleCenters) {
            const size2 = center.getEstimatedModuleSize();
            totalModuleSize += size2;
            square += size2 * size2;
          }
          average = totalModuleSize / startSize;
          let stdDev = Math.sqrt(square / startSize - average * average);
          possibleCenters.sort(
            (center1, center2) => {
              const dA = Math.abs(center2.getEstimatedModuleSize() - average);
              const dB = Math.abs(center1.getEstimatedModuleSize() - average);
              return dA < dB ? -1 : dA > dB ? 1 : 0;
            }
          );
          const limit = Math.max(0.2 * average, stdDev);
          for (let i2 = 0; i2 < possibleCenters.length && possibleCenters.length > 3; i2++) {
            const pattern = possibleCenters[i2];
            if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
              possibleCenters.splice(i2, 1);
              i2--;
            }
          }
        }
        if (possibleCenters.length > 3) {
          let totalModuleSize = 0;
          for (const possibleCenter of possibleCenters) {
            totalModuleSize += possibleCenter.getEstimatedModuleSize();
          }
          average = totalModuleSize / possibleCenters.length;
          possibleCenters.sort(
            (center1, center2) => {
              if (center2.getCount() === center1.getCount()) {
                const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? 1 : dA > dB ? -1 : 0;
              } else {
                return center2.getCount() - center1.getCount();
              }
            }
          );
          possibleCenters.splice(3);
        }
        return [
          possibleCenters[0],
          possibleCenters[1],
          possibleCenters[2]
        ];
      }
    }
    FinderPatternFinder.CENTER_QUORUM = 2;
    FinderPatternFinder.MIN_SKIP = 3;
    FinderPatternFinder.MAX_MODULES = 57;
    class Detector$2 {
      constructor(image) {
        this.image = image;
      }
      getImage() {
        return this.image;
      }
      getResultPointCallback() {
        return this.resultPointCallback;
      }
      detect(hints) {
        this.resultPointCallback = hints === null || hints === void 0 ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
        const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
        const info = finder.find(hints);
        return this.processFinderPatternInfo(info);
      }
      processFinderPatternInfo(info) {
        const topLeft = info.getTopLeft();
        const topRight = info.getTopRight();
        const bottomLeft = info.getBottomLeft();
        const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1) {
          throw new NotFoundException("No pattern found in proccess finder.");
        }
        const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
        const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        let alignmentPattern = null;
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
          const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          const correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
          const estAlignmentX = Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
          const estAlignmentY = Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
          for (let i2 = 4; i2 <= 16; i2 <<= 1) {
            try {
              alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i2);
              break;
            } catch (re) {
              if (!(re instanceof NotFoundException)) {
                throw re;
              }
            }
          }
        }
        const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        const bits = Detector$2.sampleGrid(this.image, transform, dimension);
        let points;
        if (alignmentPattern === null) {
          points = [bottomLeft, topLeft, topRight];
        } else {
          points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult(bits, points);
      }
      static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
        const dimMinusThree = dimension - 3.5;
        let bottomRightX;
        let bottomRightY;
        let sourceBottomRightX;
        let sourceBottomRightY;
        if (alignmentPattern !== null) {
          bottomRightX = alignmentPattern.getX();
          bottomRightY = alignmentPattern.getY();
          sourceBottomRightX = dimMinusThree - 3;
          sourceBottomRightY = sourceBottomRightX;
        } else {
          bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          sourceBottomRightX = dimMinusThree;
          sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
      }
      static sampleGrid(image, transform, dimension) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
      }
      static computeDimension(topLeft, topRight, bottomLeft, moduleSize) {
        const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
        const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
        let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 3) {
          case 0:
            dimension++;
            break;
          case 2:
            dimension--;
            break;
          case 3:
            throw new NotFoundException("Dimensions could be not found.");
        }
        return dimension;
      }
      calculateModuleSize(topLeft, topRight, bottomLeft) {
        return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
      }
      calculateModuleSizeOneWay(pattern, otherPattern) {
        const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
          Math.floor(pattern.getX()),
          Math.floor(pattern.getY()),
          Math.floor(otherPattern.getX()),
          Math.floor(otherPattern.getY())
        );
        const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
          Math.floor(otherPattern.getX()),
          Math.floor(otherPattern.getY()),
          Math.floor(pattern.getX()),
          Math.floor(pattern.getY())
        );
        if (isNaN(moduleSizeEst1)) {
          return moduleSizeEst2 / 7;
        }
        if (isNaN(moduleSizeEst2)) {
          return moduleSizeEst1 / 7;
        }
        return (moduleSizeEst1 + moduleSizeEst2) / 14;
      }
      sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {
        let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        let scale = 1;
        let otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
          scale = fromX / (fromX - otherToX);
          otherToX = 0;
        } else if (otherToX >= this.image.getWidth()) {
          scale = (this.image.getWidth() - 1 - fromX) / (otherToX - fromX);
          otherToX = this.image.getWidth() - 1;
        }
        let otherToY = Math.floor(fromY - (toY - fromY) * scale);
        scale = 1;
        if (otherToY < 0) {
          scale = fromY / (fromY - otherToY);
          otherToY = 0;
        } else if (otherToY >= this.image.getHeight()) {
          scale = (this.image.getHeight() - 1 - fromY) / (otherToY - fromY);
          otherToY = this.image.getHeight() - 1;
        }
        otherToX = Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        return result - 1;
      }
      sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {
        const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        const dx = Math.abs(toX - fromX);
        const dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        const xstep = fromX < toX ? 1 : -1;
        const ystep = fromY < toY ? 1 : -1;
        let state = 0;
        const xLimit = toX + xstep;
        for (let x = fromX, y = fromY; x !== xLimit; x += xstep) {
          const realX = steep ? y : x;
          const realY = steep ? x : y;
          if (state === 1 === this.image.get(realX, realY)) {
            if (state === 2) {
              return MathUtils.distance(x, y, fromX, fromY);
            }
            state++;
          }
          error += dy;
          if (error > 0) {
            if (y === toY) {
              break;
            }
            y += ystep;
            error -= dx;
          }
        }
        if (state === 2) {
          return MathUtils.distance(toX + xstep, toY, fromX, fromY);
        }
        return NaN;
      }
      findAlignmentInRegion(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
        const allowance = Math.floor(allowanceFactor * overallEstModuleSize);
        const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment top exceeds estimated module size.");
        }
        const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment bottom exceeds estimated module size.");
        }
        const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
      }
    }
    class QRCodeReader {
      constructor() {
        this.decoder = new Decoder$2();
      }
      getDecoder() {
        return this.decoder;
      }
      decode(image, hints) {
        let decoderResult;
        let points;
        if (hints !== void 0 && hints !== null && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE)) {
          const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decodeBitMatrix(bits, hints);
          points = QRCodeReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
          decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
          points = detectorResult.getPoints();
        }
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
          decoderResult.getOther().applyMirroredCorrection(points);
        }
        const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.QR_CODE, void 0);
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
      }
      reset() {
      }
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        let bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        let right = rightBottomBlack[0];
        if (left >= right || top >= bottom) {
          throw new NotFoundException();
        }
        if (bottom - top !== right - left) {
          right = left + (bottom - top);
          if (right >= image.getWidth()) {
            throw new NotFoundException();
          }
        }
        const matrixWidth = Math.round((right - left + 1) / moduleSize);
        const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        if (matrixHeight !== matrixWidth) {
          throw new NotFoundException();
        }
        const nudge = Math.floor(moduleSize / 2);
        top += nudge;
        left += nudge;
        const nudgedTooFarRight = left + Math.floor((matrixWidth - 1) * moduleSize) - right;
        if (nudgedTooFarRight > 0) {
          if (nudgedTooFarRight > nudge) {
            throw new NotFoundException();
          }
          left -= nudgedTooFarRight;
        }
        const nudgedTooFarDown = top + Math.floor((matrixHeight - 1) * moduleSize) - bottom;
        if (nudgedTooFarDown > 0) {
          if (nudgedTooFarDown > nudge) {
            throw new NotFoundException();
          }
          top -= nudgedTooFarDown;
        }
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y = 0; y < matrixHeight; y++) {
          const iOffset = top + Math.floor(y * moduleSize);
          for (let x = 0; x < matrixWidth; x++) {
            if (image.get(left + Math.floor(x * moduleSize), iOffset)) {
              bits.set(x, y);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const height = image.getHeight();
        const width = image.getWidth();
        let x = leftTopBlack[0];
        let y = leftTopBlack[1];
        let inBlack = true;
        let transitions = 0;
        while (x < width && y < height) {
          if (inBlack !== image.get(x, y)) {
            if (++transitions === 5) {
              break;
            }
            inBlack = !inBlack;
          }
          x++;
          y++;
        }
        if (x === width || y === height) {
          throw new NotFoundException();
        }
        return (x - leftTopBlack[0]) / 7;
      }
    }
    QRCodeReader.NO_POINTS = new Array();
    class PDF417Common {
      PDF417Common() {
      }
      static getBitCountSum(moduleBitCount) {
        return MathUtils.sum(moduleBitCount);
      }
      static toIntArray(list) {
        if (list == null || !list.length) {
          return PDF417Common.EMPTY_INT_ARRAY;
        }
        const result = new Int32Array(list.length);
        let i2 = 0;
        for (const integer of list) {
          result[i2++] = integer;
        }
        return result;
      }
      static getCodeword(symbol) {
        const i2 = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 262143);
        if (i2 < 0) {
          return -1;
        }
        return (PDF417Common.CODEWORD_TABLE[i2] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
      }
    }
    PDF417Common.NUMBER_OF_CODEWORDS = 929;
    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
    PDF417Common.MIN_ROWS_IN_BARCODE = 3;
    PDF417Common.MAX_ROWS_IN_BARCODE = 90;
    PDF417Common.MODULES_IN_CODEWORD = 17;
    PDF417Common.MODULES_IN_STOP_PATTERN = 18;
    PDF417Common.BARS_IN_MODULE = 8;
    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
    PDF417Common.SYMBOL_TABLE = Int32Array.from([
      66142,
      66170,
      66206,
      66236,
      66290,
      66292,
      66350,
      66382,
      66396,
      66454,
      66470,
      66476,
      66594,
      66600,
      66614,
      66626,
      66628,
      66632,
      66640,
      66654,
      66662,
      66668,
      66682,
      66690,
      66718,
      66720,
      66748,
      66758,
      66776,
      66798,
      66802,
      66804,
      66820,
      66824,
      66832,
      66846,
      66848,
      66876,
      66880,
      66936,
      66950,
      66956,
      66968,
      66992,
      67006,
      67022,
      67036,
      67042,
      67044,
      67048,
      67062,
      67118,
      67150,
      67164,
      67214,
      67228,
      67256,
      67294,
      67322,
      67350,
      67366,
      67372,
      67398,
      67404,
      67416,
      67438,
      67474,
      67476,
      67490,
      67492,
      67496,
      67510,
      67618,
      67624,
      67650,
      67656,
      67664,
      67678,
      67686,
      67692,
      67706,
      67714,
      67716,
      67728,
      67742,
      67744,
      67772,
      67782,
      67788,
      67800,
      67822,
      67826,
      67828,
      67842,
      67848,
      67870,
      67872,
      67900,
      67904,
      67960,
      67974,
      67992,
      68016,
      68030,
      68046,
      68060,
      68066,
      68068,
      68072,
      68086,
      68104,
      68112,
      68126,
      68128,
      68156,
      68160,
      68216,
      68336,
      68358,
      68364,
      68376,
      68400,
      68414,
      68448,
      68476,
      68494,
      68508,
      68536,
      68546,
      68548,
      68552,
      68560,
      68574,
      68582,
      68588,
      68654,
      68686,
      68700,
      68706,
      68708,
      68712,
      68726,
      68750,
      68764,
      68792,
      68802,
      68804,
      68808,
      68816,
      68830,
      68838,
      68844,
      68858,
      68878,
      68892,
      68920,
      68976,
      68990,
      68994,
      68996,
      69e3,
      69008,
      69022,
      69024,
      69052,
      69062,
      69068,
      69080,
      69102,
      69106,
      69108,
      69142,
      69158,
      69164,
      69190,
      69208,
      69230,
      69254,
      69260,
      69272,
      69296,
      69310,
      69326,
      69340,
      69386,
      69394,
      69396,
      69410,
      69416,
      69430,
      69442,
      69444,
      69448,
      69456,
      69470,
      69478,
      69484,
      69554,
      69556,
      69666,
      69672,
      69698,
      69704,
      69712,
      69726,
      69754,
      69762,
      69764,
      69776,
      69790,
      69792,
      69820,
      69830,
      69836,
      69848,
      69870,
      69874,
      69876,
      69890,
      69918,
      69920,
      69948,
      69952,
      70008,
      70022,
      70040,
      70064,
      70078,
      70094,
      70108,
      70114,
      70116,
      70120,
      70134,
      70152,
      70174,
      70176,
      70264,
      70384,
      70412,
      70448,
      70462,
      70496,
      70524,
      70542,
      70556,
      70584,
      70594,
      70600,
      70608,
      70622,
      70630,
      70636,
      70664,
      70672,
      70686,
      70688,
      70716,
      70720,
      70776,
      70896,
      71136,
      71180,
      71192,
      71216,
      71230,
      71264,
      71292,
      71360,
      71416,
      71452,
      71480,
      71536,
      71550,
      71554,
      71556,
      71560,
      71568,
      71582,
      71584,
      71612,
      71622,
      71628,
      71640,
      71662,
      71726,
      71732,
      71758,
      71772,
      71778,
      71780,
      71784,
      71798,
      71822,
      71836,
      71864,
      71874,
      71880,
      71888,
      71902,
      71910,
      71916,
      71930,
      71950,
      71964,
      71992,
      72048,
      72062,
      72066,
      72068,
      72080,
      72094,
      72096,
      72124,
      72134,
      72140,
      72152,
      72174,
      72178,
      72180,
      72206,
      72220,
      72248,
      72304,
      72318,
      72416,
      72444,
      72456,
      72464,
      72478,
      72480,
      72508,
      72512,
      72568,
      72588,
      72600,
      72624,
      72638,
      72654,
      72668,
      72674,
      72676,
      72680,
      72694,
      72726,
      72742,
      72748,
      72774,
      72780,
      72792,
      72814,
      72838,
      72856,
      72880,
      72894,
      72910,
      72924,
      72930,
      72932,
      72936,
      72950,
      72966,
      72972,
      72984,
      73008,
      73022,
      73056,
      73084,
      73102,
      73116,
      73144,
      73156,
      73160,
      73168,
      73182,
      73190,
      73196,
      73210,
      73226,
      73234,
      73236,
      73250,
      73252,
      73256,
      73270,
      73282,
      73284,
      73296,
      73310,
      73318,
      73324,
      73346,
      73348,
      73352,
      73360,
      73374,
      73376,
      73404,
      73414,
      73420,
      73432,
      73454,
      73498,
      73518,
      73522,
      73524,
      73550,
      73564,
      73570,
      73572,
      73576,
      73590,
      73800,
      73822,
      73858,
      73860,
      73872,
      73886,
      73888,
      73916,
      73944,
      73970,
      73972,
      73992,
      74014,
      74016,
      74044,
      74048,
      74104,
      74118,
      74136,
      74160,
      74174,
      74210,
      74212,
      74216,
      74230,
      74244,
      74256,
      74270,
      74272,
      74360,
      74480,
      74502,
      74508,
      74544,
      74558,
      74592,
      74620,
      74638,
      74652,
      74680,
      74690,
      74696,
      74704,
      74726,
      74732,
      74782,
      74784,
      74812,
      74992,
      75232,
      75288,
      75326,
      75360,
      75388,
      75456,
      75512,
      75576,
      75632,
      75646,
      75650,
      75652,
      75664,
      75678,
      75680,
      75708,
      75718,
      75724,
      75736,
      75758,
      75808,
      75836,
      75840,
      75896,
      76016,
      76256,
      76736,
      76824,
      76848,
      76862,
      76896,
      76924,
      76992,
      77048,
      77296,
      77340,
      77368,
      77424,
      77438,
      77536,
      77564,
      77572,
      77576,
      77584,
      77600,
      77628,
      77632,
      77688,
      77702,
      77708,
      77720,
      77744,
      77758,
      77774,
      77788,
      77870,
      77902,
      77916,
      77922,
      77928,
      77966,
      77980,
      78008,
      78018,
      78024,
      78032,
      78046,
      78060,
      78074,
      78094,
      78136,
      78192,
      78206,
      78210,
      78212,
      78224,
      78238,
      78240,
      78268,
      78278,
      78284,
      78296,
      78322,
      78324,
      78350,
      78364,
      78448,
      78462,
      78560,
      78588,
      78600,
      78622,
      78624,
      78652,
      78656,
      78712,
      78726,
      78744,
      78768,
      78782,
      78798,
      78812,
      78818,
      78820,
      78824,
      78838,
      78862,
      78876,
      78904,
      78960,
      78974,
      79072,
      79100,
      79296,
      79352,
      79368,
      79376,
      79390,
      79392,
      79420,
      79424,
      79480,
      79600,
      79628,
      79640,
      79664,
      79678,
      79712,
      79740,
      79772,
      79800,
      79810,
      79812,
      79816,
      79824,
      79838,
      79846,
      79852,
      79894,
      79910,
      79916,
      79942,
      79948,
      79960,
      79982,
      79988,
      80006,
      80024,
      80048,
      80062,
      80078,
      80092,
      80098,
      80100,
      80104,
      80134,
      80140,
      80176,
      80190,
      80224,
      80252,
      80270,
      80284,
      80312,
      80328,
      80336,
      80350,
      80358,
      80364,
      80378,
      80390,
      80396,
      80408,
      80432,
      80446,
      80480,
      80508,
      80576,
      80632,
      80654,
      80668,
      80696,
      80752,
      80766,
      80776,
      80784,
      80798,
      80800,
      80828,
      80844,
      80856,
      80878,
      80882,
      80884,
      80914,
      80916,
      80930,
      80932,
      80936,
      80950,
      80962,
      80968,
      80976,
      80990,
      80998,
      81004,
      81026,
      81028,
      81040,
      81054,
      81056,
      81084,
      81094,
      81100,
      81112,
      81134,
      81154,
      81156,
      81160,
      81168,
      81182,
      81184,
      81212,
      81216,
      81272,
      81286,
      81292,
      81304,
      81328,
      81342,
      81358,
      81372,
      81380,
      81384,
      81398,
      81434,
      81454,
      81458,
      81460,
      81486,
      81500,
      81506,
      81508,
      81512,
      81526,
      81550,
      81564,
      81592,
      81602,
      81604,
      81608,
      81616,
      81630,
      81638,
      81644,
      81702,
      81708,
      81722,
      81734,
      81740,
      81752,
      81774,
      81778,
      81780,
      82050,
      82078,
      82080,
      82108,
      82180,
      82184,
      82192,
      82206,
      82208,
      82236,
      82240,
      82296,
      82316,
      82328,
      82352,
      82366,
      82402,
      82404,
      82408,
      82440,
      82448,
      82462,
      82464,
      82492,
      82496,
      82552,
      82672,
      82694,
      82700,
      82712,
      82736,
      82750,
      82784,
      82812,
      82830,
      82882,
      82884,
      82888,
      82896,
      82918,
      82924,
      82952,
      82960,
      82974,
      82976,
      83004,
      83008,
      83064,
      83184,
      83424,
      83468,
      83480,
      83504,
      83518,
      83552,
      83580,
      83648,
      83704,
      83740,
      83768,
      83824,
      83838,
      83842,
      83844,
      83848,
      83856,
      83872,
      83900,
      83910,
      83916,
      83928,
      83950,
      83984,
      84e3,
      84028,
      84032,
      84088,
      84208,
      84448,
      84928,
      85040,
      85054,
      85088,
      85116,
      85184,
      85240,
      85488,
      85560,
      85616,
      85630,
      85728,
      85756,
      85764,
      85768,
      85776,
      85790,
      85792,
      85820,
      85824,
      85880,
      85894,
      85900,
      85912,
      85936,
      85966,
      85980,
      86048,
      86080,
      86136,
      86256,
      86496,
      86976,
      88160,
      88188,
      88256,
      88312,
      88560,
      89056,
      89200,
      89214,
      89312,
      89340,
      89536,
      89592,
      89608,
      89616,
      89632,
      89664,
      89720,
      89840,
      89868,
      89880,
      89904,
      89952,
      89980,
      89998,
      90012,
      90040,
      90190,
      90204,
      90254,
      90268,
      90296,
      90306,
      90308,
      90312,
      90334,
      90382,
      90396,
      90424,
      90480,
      90494,
      90500,
      90504,
      90512,
      90526,
      90528,
      90556,
      90566,
      90572,
      90584,
      90610,
      90612,
      90638,
      90652,
      90680,
      90736,
      90750,
      90848,
      90876,
      90884,
      90888,
      90896,
      90910,
      90912,
      90940,
      90944,
      91e3,
      91014,
      91020,
      91032,
      91056,
      91070,
      91086,
      91100,
      91106,
      91108,
      91112,
      91126,
      91150,
      91164,
      91192,
      91248,
      91262,
      91360,
      91388,
      91584,
      91640,
      91664,
      91678,
      91680,
      91708,
      91712,
      91768,
      91888,
      91928,
      91952,
      91966,
      92e3,
      92028,
      92046,
      92060,
      92088,
      92098,
      92100,
      92104,
      92112,
      92126,
      92134,
      92140,
      92188,
      92216,
      92272,
      92384,
      92412,
      92608,
      92664,
      93168,
      93200,
      93214,
      93216,
      93244,
      93248,
      93304,
      93424,
      93664,
      93720,
      93744,
      93758,
      93792,
      93820,
      93888,
      93944,
      93980,
      94008,
      94064,
      94078,
      94084,
      94088,
      94096,
      94110,
      94112,
      94140,
      94150,
      94156,
      94168,
      94246,
      94252,
      94278,
      94284,
      94296,
      94318,
      94342,
      94348,
      94360,
      94384,
      94398,
      94414,
      94428,
      94440,
      94470,
      94476,
      94488,
      94512,
      94526,
      94560,
      94588,
      94606,
      94620,
      94648,
      94658,
      94660,
      94664,
      94672,
      94686,
      94694,
      94700,
      94714,
      94726,
      94732,
      94744,
      94768,
      94782,
      94816,
      94844,
      94912,
      94968,
      94990,
      95004,
      95032,
      95088,
      95102,
      95112,
      95120,
      95134,
      95136,
      95164,
      95180,
      95192,
      95214,
      95218,
      95220,
      95244,
      95256,
      95280,
      95294,
      95328,
      95356,
      95424,
      95480,
      95728,
      95758,
      95772,
      95800,
      95856,
      95870,
      95968,
      95996,
      96008,
      96016,
      96030,
      96032,
      96060,
      96064,
      96120,
      96152,
      96176,
      96190,
      96220,
      96226,
      96228,
      96232,
      96290,
      96292,
      96296,
      96310,
      96322,
      96324,
      96328,
      96336,
      96350,
      96358,
      96364,
      96386,
      96388,
      96392,
      96400,
      96414,
      96416,
      96444,
      96454,
      96460,
      96472,
      96494,
      96498,
      96500,
      96514,
      96516,
      96520,
      96528,
      96542,
      96544,
      96572,
      96576,
      96632,
      96646,
      96652,
      96664,
      96688,
      96702,
      96718,
      96732,
      96738,
      96740,
      96744,
      96758,
      96772,
      96776,
      96784,
      96798,
      96800,
      96828,
      96832,
      96888,
      97008,
      97030,
      97036,
      97048,
      97072,
      97086,
      97120,
      97148,
      97166,
      97180,
      97208,
      97220,
      97224,
      97232,
      97246,
      97254,
      97260,
      97326,
      97330,
      97332,
      97358,
      97372,
      97378,
      97380,
      97384,
      97398,
      97422,
      97436,
      97464,
      97474,
      97476,
      97480,
      97488,
      97502,
      97510,
      97516,
      97550,
      97564,
      97592,
      97648,
      97666,
      97668,
      97672,
      97680,
      97694,
      97696,
      97724,
      97734,
      97740,
      97752,
      97774,
      97830,
      97836,
      97850,
      97862,
      97868,
      97880,
      97902,
      97906,
      97908,
      97926,
      97932,
      97944,
      97968,
      97998,
      98012,
      98018,
      98020,
      98024,
      98038,
      98618,
      98674,
      98676,
      98838,
      98854,
      98874,
      98892,
      98904,
      98926,
      98930,
      98932,
      98968,
      99006,
      99042,
      99044,
      99048,
      99062,
      99166,
      99194,
      99246,
      99286,
      99350,
      99366,
      99372,
      99386,
      99398,
      99416,
      99438,
      99442,
      99444,
      99462,
      99504,
      99518,
      99534,
      99548,
      99554,
      99556,
      99560,
      99574,
      99590,
      99596,
      99608,
      99632,
      99646,
      99680,
      99708,
      99726,
      99740,
      99768,
      99778,
      99780,
      99784,
      99792,
      99806,
      99814,
      99820,
      99834,
      99858,
      99860,
      99874,
      99880,
      99894,
      99906,
      99920,
      99934,
      99962,
      99970,
      99972,
      99976,
      99984,
      99998,
      1e5,
      100028,
      100038,
      100044,
      100056,
      100078,
      100082,
      100084,
      100142,
      100174,
      100188,
      100246,
      100262,
      100268,
      100306,
      100308,
      100390,
      100396,
      100410,
      100422,
      100428,
      100440,
      100462,
      100466,
      100468,
      100486,
      100504,
      100528,
      100542,
      100558,
      100572,
      100578,
      100580,
      100584,
      100598,
      100620,
      100656,
      100670,
      100704,
      100732,
      100750,
      100792,
      100802,
      100808,
      100816,
      100830,
      100838,
      100844,
      100858,
      100888,
      100912,
      100926,
      100960,
      100988,
      101056,
      101112,
      101148,
      101176,
      101232,
      101246,
      101250,
      101252,
      101256,
      101264,
      101278,
      101280,
      101308,
      101318,
      101324,
      101336,
      101358,
      101362,
      101364,
      101410,
      101412,
      101416,
      101430,
      101442,
      101448,
      101456,
      101470,
      101478,
      101498,
      101506,
      101508,
      101520,
      101534,
      101536,
      101564,
      101580,
      101618,
      101620,
      101636,
      101640,
      101648,
      101662,
      101664,
      101692,
      101696,
      101752,
      101766,
      101784,
      101838,
      101858,
      101860,
      101864,
      101934,
      101938,
      101940,
      101966,
      101980,
      101986,
      101988,
      101992,
      102030,
      102044,
      102072,
      102082,
      102084,
      102088,
      102096,
      102138,
      102166,
      102182,
      102188,
      102214,
      102220,
      102232,
      102254,
      102282,
      102290,
      102292,
      102306,
      102308,
      102312,
      102326,
      102444,
      102458,
      102470,
      102476,
      102488,
      102514,
      102516,
      102534,
      102552,
      102576,
      102590,
      102606,
      102620,
      102626,
      102632,
      102646,
      102662,
      102668,
      102704,
      102718,
      102752,
      102780,
      102798,
      102812,
      102840,
      102850,
      102856,
      102864,
      102878,
      102886,
      102892,
      102906,
      102936,
      102974,
      103008,
      103036,
      103104,
      103160,
      103224,
      103280,
      103294,
      103298,
      103300,
      103312,
      103326,
      103328,
      103356,
      103366,
      103372,
      103384,
      103406,
      103410,
      103412,
      103472,
      103486,
      103520,
      103548,
      103616,
      103672,
      103920,
      103992,
      104048,
      104062,
      104160,
      104188,
      104194,
      104196,
      104200,
      104208,
      104224,
      104252,
      104256,
      104312,
      104326,
      104332,
      104344,
      104368,
      104382,
      104398,
      104412,
      104418,
      104420,
      104424,
      104482,
      104484,
      104514,
      104520,
      104528,
      104542,
      104550,
      104570,
      104578,
      104580,
      104592,
      104606,
      104608,
      104636,
      104652,
      104690,
      104692,
      104706,
      104712,
      104734,
      104736,
      104764,
      104768,
      104824,
      104838,
      104856,
      104910,
      104930,
      104932,
      104936,
      104968,
      104976,
      104990,
      104992,
      105020,
      105024,
      105080,
      105200,
      105240,
      105278,
      105312,
      105372,
      105410,
      105412,
      105416,
      105424,
      105446,
      105518,
      105524,
      105550,
      105564,
      105570,
      105572,
      105576,
      105614,
      105628,
      105656,
      105666,
      105672,
      105680,
      105702,
      105722,
      105742,
      105756,
      105784,
      105840,
      105854,
      105858,
      105860,
      105864,
      105872,
      105888,
      105932,
      105970,
      105972,
      106006,
      106022,
      106028,
      106054,
      106060,
      106072,
      106100,
      106118,
      106124,
      106136,
      106160,
      106174,
      106190,
      106210,
      106212,
      106216,
      106250,
      106258,
      106260,
      106274,
      106276,
      106280,
      106306,
      106308,
      106312,
      106320,
      106334,
      106348,
      106394,
      106414,
      106418,
      106420,
      106566,
      106572,
      106610,
      106612,
      106630,
      106636,
      106648,
      106672,
      106686,
      106722,
      106724,
      106728,
      106742,
      106758,
      106764,
      106776,
      106800,
      106814,
      106848,
      106876,
      106894,
      106908,
      106936,
      106946,
      106948,
      106952,
      106960,
      106974,
      106982,
      106988,
      107032,
      107056,
      107070,
      107104,
      107132,
      107200,
      107256,
      107292,
      107320,
      107376,
      107390,
      107394,
      107396,
      107400,
      107408,
      107422,
      107424,
      107452,
      107462,
      107468,
      107480,
      107502,
      107506,
      107508,
      107544,
      107568,
      107582,
      107616,
      107644,
      107712,
      107768,
      108016,
      108060,
      108088,
      108144,
      108158,
      108256,
      108284,
      108290,
      108292,
      108296,
      108304,
      108318,
      108320,
      108348,
      108352,
      108408,
      108422,
      108428,
      108440,
      108464,
      108478,
      108494,
      108508,
      108514,
      108516,
      108520,
      108592,
      108640,
      108668,
      108736,
      108792,
      109040,
      109536,
      109680,
      109694,
      109792,
      109820,
      110016,
      110072,
      110084,
      110088,
      110096,
      110112,
      110140,
      110144,
      110200,
      110320,
      110342,
      110348,
      110360,
      110384,
      110398,
      110432,
      110460,
      110478,
      110492,
      110520,
      110532,
      110536,
      110544,
      110558,
      110658,
      110686,
      110714,
      110722,
      110724,
      110728,
      110736,
      110750,
      110752,
      110780,
      110796,
      110834,
      110836,
      110850,
      110852,
      110856,
      110864,
      110878,
      110880,
      110908,
      110912,
      110968,
      110982,
      111e3,
      111054,
      111074,
      111076,
      111080,
      111108,
      111112,
      111120,
      111134,
      111136,
      111164,
      111168,
      111224,
      111344,
      111372,
      111422,
      111456,
      111516,
      111554,
      111556,
      111560,
      111568,
      111590,
      111632,
      111646,
      111648,
      111676,
      111680,
      111736,
      111856,
      112096,
      112152,
      112224,
      112252,
      112320,
      112440,
      112514,
      112516,
      112520,
      112528,
      112542,
      112544,
      112588,
      112686,
      112718,
      112732,
      112782,
      112796,
      112824,
      112834,
      112836,
      112840,
      112848,
      112870,
      112890,
      112910,
      112924,
      112952,
      113008,
      113022,
      113026,
      113028,
      113032,
      113040,
      113054,
      113056,
      113100,
      113138,
      113140,
      113166,
      113180,
      113208,
      113264,
      113278,
      113376,
      113404,
      113416,
      113424,
      113440,
      113468,
      113472,
      113560,
      113614,
      113634,
      113636,
      113640,
      113686,
      113702,
      113708,
      113734,
      113740,
      113752,
      113778,
      113780,
      113798,
      113804,
      113816,
      113840,
      113854,
      113870,
      113890,
      113892,
      113896,
      113926,
      113932,
      113944,
      113968,
      113982,
      114016,
      114044,
      114076,
      114114,
      114116,
      114120,
      114128,
      114150,
      114170,
      114194,
      114196,
      114210,
      114212,
      114216,
      114242,
      114244,
      114248,
      114256,
      114270,
      114278,
      114306,
      114308,
      114312,
      114320,
      114334,
      114336,
      114364,
      114380,
      114420,
      114458,
      114478,
      114482,
      114484,
      114510,
      114524,
      114530,
      114532,
      114536,
      114842,
      114866,
      114868,
      114970,
      114994,
      114996,
      115042,
      115044,
      115048,
      115062,
      115130,
      115226,
      115250,
      115252,
      115278,
      115292,
      115298,
      115300,
      115304,
      115318,
      115342,
      115394,
      115396,
      115400,
      115408,
      115422,
      115430,
      115436,
      115450,
      115478,
      115494,
      115514,
      115526,
      115532,
      115570,
      115572,
      115738,
      115758,
      115762,
      115764,
      115790,
      115804,
      115810,
      115812,
      115816,
      115830,
      115854,
      115868,
      115896,
      115906,
      115912,
      115920,
      115934,
      115942,
      115948,
      115962,
      115996,
      116024,
      116080,
      116094,
      116098,
      116100,
      116104,
      116112,
      116126,
      116128,
      116156,
      116166,
      116172,
      116184,
      116206,
      116210,
      116212,
      116246,
      116262,
      116268,
      116282,
      116294,
      116300,
      116312,
      116334,
      116338,
      116340,
      116358,
      116364,
      116376,
      116400,
      116414,
      116430,
      116444,
      116450,
      116452,
      116456,
      116498,
      116500,
      116514,
      116520,
      116534,
      116546,
      116548,
      116552,
      116560,
      116574,
      116582,
      116588,
      116602,
      116654,
      116694,
      116714,
      116762,
      116782,
      116786,
      116788,
      116814,
      116828,
      116834,
      116836,
      116840,
      116854,
      116878,
      116892,
      116920,
      116930,
      116936,
      116944,
      116958,
      116966,
      116972,
      116986,
      117006,
      117048,
      117104,
      117118,
      117122,
      117124,
      117136,
      117150,
      117152,
      117180,
      117190,
      117196,
      117208,
      117230,
      117234,
      117236,
      117304,
      117360,
      117374,
      117472,
      117500,
      117506,
      117508,
      117512,
      117520,
      117536,
      117564,
      117568,
      117624,
      117638,
      117644,
      117656,
      117680,
      117694,
      117710,
      117724,
      117730,
      117732,
      117736,
      117750,
      117782,
      117798,
      117804,
      117818,
      117830,
      117848,
      117874,
      117876,
      117894,
      117936,
      117950,
      117966,
      117986,
      117988,
      117992,
      118022,
      118028,
      118040,
      118064,
      118078,
      118112,
      118140,
      118172,
      118210,
      118212,
      118216,
      118224,
      118238,
      118246,
      118266,
      118306,
      118312,
      118338,
      118352,
      118366,
      118374,
      118394,
      118402,
      118404,
      118408,
      118416,
      118430,
      118432,
      118460,
      118476,
      118514,
      118516,
      118574,
      118578,
      118580,
      118606,
      118620,
      118626,
      118628,
      118632,
      118678,
      118694,
      118700,
      118730,
      118738,
      118740,
      118830,
      118834,
      118836,
      118862,
      118876,
      118882,
      118884,
      118888,
      118902,
      118926,
      118940,
      118968,
      118978,
      118980,
      118984,
      118992,
      119006,
      119014,
      119020,
      119034,
      119068,
      119096,
      119152,
      119166,
      119170,
      119172,
      119176,
      119184,
      119198,
      119200,
      119228,
      119238,
      119244,
      119256,
      119278,
      119282,
      119284,
      119324,
      119352,
      119408,
      119422,
      119520,
      119548,
      119554,
      119556,
      119560,
      119568,
      119582,
      119584,
      119612,
      119616,
      119672,
      119686,
      119692,
      119704,
      119728,
      119742,
      119758,
      119772,
      119778,
      119780,
      119784,
      119798,
      119920,
      119934,
      120032,
      120060,
      120256,
      120312,
      120324,
      120328,
      120336,
      120352,
      120384,
      120440,
      120560,
      120582,
      120588,
      120600,
      120624,
      120638,
      120672,
      120700,
      120718,
      120732,
      120760,
      120770,
      120772,
      120776,
      120784,
      120798,
      120806,
      120812,
      120870,
      120876,
      120890,
      120902,
      120908,
      120920,
      120946,
      120948,
      120966,
      120972,
      120984,
      121008,
      121022,
      121038,
      121058,
      121060,
      121064,
      121078,
      121100,
      121112,
      121136,
      121150,
      121184,
      121212,
      121244,
      121282,
      121284,
      121288,
      121296,
      121318,
      121338,
      121356,
      121368,
      121392,
      121406,
      121440,
      121468,
      121536,
      121592,
      121656,
      121730,
      121732,
      121736,
      121744,
      121758,
      121760,
      121804,
      121842,
      121844,
      121890,
      121922,
      121924,
      121928,
      121936,
      121950,
      121958,
      121978,
      121986,
      121988,
      121992,
      122e3,
      122014,
      122016,
      122044,
      122060,
      122098,
      122100,
      122116,
      122120,
      122128,
      122142,
      122144,
      122172,
      122176,
      122232,
      122246,
      122264,
      122318,
      122338,
      122340,
      122344,
      122414,
      122418,
      122420,
      122446,
      122460,
      122466,
      122468,
      122472,
      122510,
      122524,
      122552,
      122562,
      122564,
      122568,
      122576,
      122598,
      122618,
      122646,
      122662,
      122668,
      122694,
      122700,
      122712,
      122738,
      122740,
      122762,
      122770,
      122772,
      122786,
      122788,
      122792,
      123018,
      123026,
      123028,
      123042,
      123044,
      123048,
      123062,
      123098,
      123146,
      123154,
      123156,
      123170,
      123172,
      123176,
      123190,
      123202,
      123204,
      123208,
      123216,
      123238,
      123244,
      123258,
      123290,
      123314,
      123316,
      123402,
      123410,
      123412,
      123426,
      123428,
      123432,
      123446,
      123458,
      123464,
      123472,
      123486,
      123494,
      123500,
      123514,
      123522,
      123524,
      123528,
      123536,
      123552,
      123580,
      123590,
      123596,
      123608,
      123630,
      123634,
      123636,
      123674,
      123698,
      123700,
      123740,
      123746,
      123748,
      123752,
      123834,
      123914,
      123922,
      123924,
      123938,
      123944,
      123958,
      123970,
      123976,
      123984,
      123998,
      124006,
      124012,
      124026,
      124034,
      124036,
      124048,
      124062,
      124064,
      124092,
      124102,
      124108,
      124120,
      124142,
      124146,
      124148,
      124162,
      124164,
      124168,
      124176,
      124190,
      124192,
      124220,
      124224,
      124280,
      124294,
      124300,
      124312,
      124336,
      124350,
      124366,
      124380,
      124386,
      124388,
      124392,
      124406,
      124442,
      124462,
      124466,
      124468,
      124494,
      124508,
      124514,
      124520,
      124558,
      124572,
      124600,
      124610,
      124612,
      124616,
      124624,
      124646,
      124666,
      124694,
      124710,
      124716,
      124730,
      124742,
      124748,
      124760,
      124786,
      124788,
      124818,
      124820,
      124834,
      124836,
      124840,
      124854,
      124946,
      124948,
      124962,
      124964,
      124968,
      124982,
      124994,
      124996,
      125e3,
      125008,
      125022,
      125030,
      125036,
      125050,
      125058,
      125060,
      125064,
      125072,
      125086,
      125088,
      125116,
      125126,
      125132,
      125144,
      125166,
      125170,
      125172,
      125186,
      125188,
      125192,
      125200,
      125216,
      125244,
      125248,
      125304,
      125318,
      125324,
      125336,
      125360,
      125374,
      125390,
      125404,
      125410,
      125412,
      125416,
      125430,
      125444,
      125448,
      125456,
      125472,
      125504,
      125560,
      125680,
      125702,
      125708,
      125720,
      125744,
      125758,
      125792,
      125820,
      125838,
      125852,
      125880,
      125890,
      125892,
      125896,
      125904,
      125918,
      125926,
      125932,
      125978,
      125998,
      126002,
      126004,
      126030,
      126044,
      126050,
      126052,
      126056,
      126094,
      126108,
      126136,
      126146,
      126148,
      126152,
      126160,
      126182,
      126202,
      126222,
      126236,
      126264,
      126320,
      126334,
      126338,
      126340,
      126344,
      126352,
      126366,
      126368,
      126412,
      126450,
      126452,
      126486,
      126502,
      126508,
      126522,
      126534,
      126540,
      126552,
      126574,
      126578,
      126580,
      126598,
      126604,
      126616,
      126640,
      126654,
      126670,
      126684,
      126690,
      126692,
      126696,
      126738,
      126754,
      126756,
      126760,
      126774,
      126786,
      126788,
      126792,
      126800,
      126814,
      126822,
      126828,
      126842,
      126894,
      126898,
      126900,
      126934,
      127126,
      127142,
      127148,
      127162,
      127178,
      127186,
      127188,
      127254,
      127270,
      127276,
      127290,
      127302,
      127308,
      127320,
      127342,
      127346,
      127348,
      127370,
      127378,
      127380,
      127394,
      127396,
      127400,
      127450,
      127510,
      127526,
      127532,
      127546,
      127558,
      127576,
      127598,
      127602,
      127604,
      127622,
      127628,
      127640,
      127664,
      127678,
      127694,
      127708,
      127714,
      127716,
      127720,
      127734,
      127754,
      127762,
      127764,
      127778,
      127784,
      127810,
      127812,
      127816,
      127824,
      127838,
      127846,
      127866,
      127898,
      127918,
      127922,
      127924,
      128022,
      128038,
      128044,
      128058,
      128070,
      128076,
      128088,
      128110,
      128114,
      128116,
      128134,
      128140,
      128152,
      128176,
      128190,
      128206,
      128220,
      128226,
      128228,
      128232,
      128246,
      128262,
      128268,
      128280,
      128304,
      128318,
      128352,
      128380,
      128398,
      128412,
      128440,
      128450,
      128452,
      128456,
      128464,
      128478,
      128486,
      128492,
      128506,
      128522,
      128530,
      128532,
      128546,
      128548,
      128552,
      128566,
      128578,
      128580,
      128584,
      128592,
      128606,
      128614,
      128634,
      128642,
      128644,
      128648,
      128656,
      128670,
      128672,
      128700,
      128716,
      128754,
      128756,
      128794,
      128814,
      128818,
      128820,
      128846,
      128860,
      128866,
      128868,
      128872,
      128886,
      128918,
      128934,
      128940,
      128954,
      128978,
      128980,
      129178,
      129198,
      129202,
      129204,
      129238,
      129258,
      129306,
      129326,
      129330,
      129332,
      129358,
      129372,
      129378,
      129380,
      129384,
      129398,
      129430,
      129446,
      129452,
      129466,
      129482,
      129490,
      129492,
      129562,
      129582,
      129586,
      129588,
      129614,
      129628,
      129634,
      129636,
      129640,
      129654,
      129678,
      129692,
      129720,
      129730,
      129732,
      129736,
      129744,
      129758,
      129766,
      129772,
      129814,
      129830,
      129836,
      129850,
      129862,
      129868,
      129880,
      129902,
      129906,
      129908,
      129930,
      129938,
      129940,
      129954,
      129956,
      129960,
      129974,
      130010
    ]);
    PDF417Common.CODEWORD_TABLE = Int32Array.from([
      2627,
      1819,
      2622,
      2621,
      1813,
      1812,
      2729,
      2724,
      2723,
      2779,
      2774,
      2773,
      902,
      896,
      908,
      868,
      865,
      861,
      859,
      2511,
      873,
      871,
      1780,
      835,
      2493,
      825,
      2491,
      842,
      837,
      844,
      1764,
      1762,
      811,
      810,
      809,
      2483,
      807,
      2482,
      806,
      2480,
      815,
      814,
      813,
      812,
      2484,
      817,
      816,
      1745,
      1744,
      1742,
      1746,
      2655,
      2637,
      2635,
      2626,
      2625,
      2623,
      2628,
      1820,
      2752,
      2739,
      2737,
      2728,
      2727,
      2725,
      2730,
      2785,
      2783,
      2778,
      2777,
      2775,
      2780,
      787,
      781,
      747,
      739,
      736,
      2413,
      754,
      752,
      1719,
      692,
      689,
      681,
      2371,
      678,
      2369,
      700,
      697,
      694,
      703,
      1688,
      1686,
      642,
      638,
      2343,
      631,
      2341,
      627,
      2338,
      651,
      646,
      643,
      2345,
      654,
      652,
      1652,
      1650,
      1647,
      1654,
      601,
      599,
      2322,
      596,
      2321,
      594,
      2319,
      2317,
      611,
      610,
      608,
      606,
      2324,
      603,
      2323,
      615,
      614,
      612,
      1617,
      1616,
      1614,
      1612,
      616,
      1619,
      1618,
      2575,
      2538,
      2536,
      905,
      901,
      898,
      909,
      2509,
      2507,
      2504,
      870,
      867,
      864,
      860,
      2512,
      875,
      872,
      1781,
      2490,
      2489,
      2487,
      2485,
      1748,
      836,
      834,
      832,
      830,
      2494,
      827,
      2492,
      843,
      841,
      839,
      845,
      1765,
      1763,
      2701,
      2676,
      2674,
      2653,
      2648,
      2656,
      2634,
      2633,
      2631,
      2629,
      1821,
      2638,
      2636,
      2770,
      2763,
      2761,
      2750,
      2745,
      2753,
      2736,
      2735,
      2733,
      2731,
      1848,
      2740,
      2738,
      2786,
      2784,
      591,
      588,
      576,
      569,
      566,
      2296,
      1590,
      537,
      534,
      526,
      2276,
      522,
      2274,
      545,
      542,
      539,
      548,
      1572,
      1570,
      481,
      2245,
      466,
      2242,
      462,
      2239,
      492,
      485,
      482,
      2249,
      496,
      494,
      1534,
      1531,
      1528,
      1538,
      413,
      2196,
      406,
      2191,
      2188,
      425,
      419,
      2202,
      415,
      2199,
      432,
      430,
      427,
      1472,
      1467,
      1464,
      433,
      1476,
      1474,
      368,
      367,
      2160,
      365,
      2159,
      362,
      2157,
      2155,
      2152,
      378,
      377,
      375,
      2166,
      372,
      2165,
      369,
      2162,
      383,
      381,
      379,
      2168,
      1419,
      1418,
      1416,
      1414,
      385,
      1411,
      384,
      1423,
      1422,
      1420,
      1424,
      2461,
      802,
      2441,
      2439,
      790,
      786,
      783,
      794,
      2409,
      2406,
      2403,
      750,
      742,
      738,
      2414,
      756,
      753,
      1720,
      2367,
      2365,
      2362,
      2359,
      1663,
      693,
      691,
      684,
      2373,
      680,
      2370,
      702,
      699,
      696,
      704,
      1690,
      1687,
      2337,
      2336,
      2334,
      2332,
      1624,
      2329,
      1622,
      640,
      637,
      2344,
      634,
      2342,
      630,
      2340,
      650,
      648,
      645,
      2346,
      655,
      653,
      1653,
      1651,
      1649,
      1655,
      2612,
      2597,
      2595,
      2571,
      2568,
      2565,
      2576,
      2534,
      2529,
      2526,
      1787,
      2540,
      2537,
      907,
      904,
      900,
      910,
      2503,
      2502,
      2500,
      2498,
      1768,
      2495,
      1767,
      2510,
      2508,
      2506,
      869,
      866,
      863,
      2513,
      876,
      874,
      1782,
      2720,
      2713,
      2711,
      2697,
      2694,
      2691,
      2702,
      2672,
      2670,
      2664,
      1828,
      2678,
      2675,
      2647,
      2646,
      2644,
      2642,
      1823,
      2639,
      1822,
      2654,
      2652,
      2650,
      2657,
      2771,
      1855,
      2765,
      2762,
      1850,
      1849,
      2751,
      2749,
      2747,
      2754,
      353,
      2148,
      344,
      342,
      336,
      2142,
      332,
      2140,
      345,
      1375,
      1373,
      306,
      2130,
      299,
      2128,
      295,
      2125,
      319,
      314,
      311,
      2132,
      1354,
      1352,
      1349,
      1356,
      262,
      257,
      2101,
      253,
      2096,
      2093,
      274,
      273,
      267,
      2107,
      263,
      2104,
      280,
      278,
      275,
      1316,
      1311,
      1308,
      1320,
      1318,
      2052,
      202,
      2050,
      2044,
      2040,
      219,
      2063,
      212,
      2060,
      208,
      2055,
      224,
      221,
      2066,
      1260,
      1258,
      1252,
      231,
      1248,
      229,
      1266,
      1264,
      1261,
      1268,
      155,
      1998,
      153,
      1996,
      1994,
      1991,
      1988,
      165,
      164,
      2007,
      162,
      2006,
      159,
      2003,
      2e3,
      172,
      171,
      169,
      2012,
      166,
      2010,
      1186,
      1184,
      1182,
      1179,
      175,
      1176,
      173,
      1192,
      1191,
      1189,
      1187,
      176,
      1194,
      1193,
      2313,
      2307,
      2305,
      592,
      589,
      2294,
      2292,
      2289,
      578,
      572,
      568,
      2297,
      580,
      1591,
      2272,
      2267,
      2264,
      1547,
      538,
      536,
      529,
      2278,
      525,
      2275,
      547,
      544,
      541,
      1574,
      1571,
      2237,
      2235,
      2229,
      1493,
      2225,
      1489,
      478,
      2247,
      470,
      2244,
      465,
      2241,
      493,
      488,
      484,
      2250,
      498,
      495,
      1536,
      1533,
      1530,
      1539,
      2187,
      2186,
      2184,
      2182,
      1432,
      2179,
      1430,
      2176,
      1427,
      414,
      412,
      2197,
      409,
      2195,
      405,
      2193,
      2190,
      426,
      424,
      421,
      2203,
      418,
      2201,
      431,
      429,
      1473,
      1471,
      1469,
      1466,
      434,
      1477,
      1475,
      2478,
      2472,
      2470,
      2459,
      2457,
      2454,
      2462,
      803,
      2437,
      2432,
      2429,
      1726,
      2443,
      2440,
      792,
      789,
      785,
      2401,
      2399,
      2393,
      1702,
      2389,
      1699,
      2411,
      2408,
      2405,
      745,
      741,
      2415,
      758,
      755,
      1721,
      2358,
      2357,
      2355,
      2353,
      1661,
      2350,
      1660,
      2347,
      1657,
      2368,
      2366,
      2364,
      2361,
      1666,
      690,
      687,
      2374,
      683,
      2372,
      701,
      698,
      705,
      1691,
      1689,
      2619,
      2617,
      2610,
      2608,
      2605,
      2613,
      2593,
      2588,
      2585,
      1803,
      2599,
      2596,
      2563,
      2561,
      2555,
      1797,
      2551,
      1795,
      2573,
      2570,
      2567,
      2577,
      2525,
      2524,
      2522,
      2520,
      1786,
      2517,
      1785,
      2514,
      1783,
      2535,
      2533,
      2531,
      2528,
      1788,
      2541,
      2539,
      906,
      903,
      911,
      2721,
      1844,
      2715,
      2712,
      1838,
      1836,
      2699,
      2696,
      2693,
      2703,
      1827,
      1826,
      1824,
      2673,
      2671,
      2669,
      2666,
      1829,
      2679,
      2677,
      1858,
      1857,
      2772,
      1854,
      1853,
      1851,
      1856,
      2766,
      2764,
      143,
      1987,
      139,
      1986,
      135,
      133,
      131,
      1984,
      128,
      1983,
      125,
      1981,
      138,
      137,
      136,
      1985,
      1133,
      1132,
      1130,
      112,
      110,
      1974,
      107,
      1973,
      104,
      1971,
      1969,
      122,
      121,
      119,
      117,
      1977,
      114,
      1976,
      124,
      1115,
      1114,
      1112,
      1110,
      1117,
      1116,
      84,
      83,
      1953,
      81,
      1952,
      78,
      1950,
      1948,
      1945,
      94,
      93,
      91,
      1959,
      88,
      1958,
      85,
      1955,
      99,
      97,
      95,
      1961,
      1086,
      1085,
      1083,
      1081,
      1078,
      100,
      1090,
      1089,
      1087,
      1091,
      49,
      47,
      1917,
      44,
      1915,
      1913,
      1910,
      1907,
      59,
      1926,
      56,
      1925,
      53,
      1922,
      1919,
      66,
      64,
      1931,
      61,
      1929,
      1042,
      1040,
      1038,
      71,
      1035,
      70,
      1032,
      68,
      1048,
      1047,
      1045,
      1043,
      1050,
      1049,
      12,
      10,
      1869,
      1867,
      1864,
      1861,
      21,
      1880,
      19,
      1877,
      1874,
      1871,
      28,
      1888,
      25,
      1886,
      22,
      1883,
      982,
      980,
      977,
      974,
      32,
      30,
      991,
      989,
      987,
      984,
      34,
      995,
      994,
      992,
      2151,
      2150,
      2147,
      2146,
      2144,
      356,
      355,
      354,
      2149,
      2139,
      2138,
      2136,
      2134,
      1359,
      343,
      341,
      338,
      2143,
      335,
      2141,
      348,
      347,
      346,
      1376,
      1374,
      2124,
      2123,
      2121,
      2119,
      1326,
      2116,
      1324,
      310,
      308,
      305,
      2131,
      302,
      2129,
      298,
      2127,
      320,
      318,
      316,
      313,
      2133,
      322,
      321,
      1355,
      1353,
      1351,
      1357,
      2092,
      2091,
      2089,
      2087,
      1276,
      2084,
      1274,
      2081,
      1271,
      259,
      2102,
      256,
      2100,
      252,
      2098,
      2095,
      272,
      269,
      2108,
      266,
      2106,
      281,
      279,
      277,
      1317,
      1315,
      1313,
      1310,
      282,
      1321,
      1319,
      2039,
      2037,
      2035,
      2032,
      1203,
      2029,
      1200,
      1197,
      207,
      2053,
      205,
      2051,
      201,
      2049,
      2046,
      2043,
      220,
      218,
      2064,
      215,
      2062,
      211,
      2059,
      228,
      226,
      223,
      2069,
      1259,
      1257,
      1254,
      232,
      1251,
      230,
      1267,
      1265,
      1263,
      2316,
      2315,
      2312,
      2311,
      2309,
      2314,
      2304,
      2303,
      2301,
      2299,
      1593,
      2308,
      2306,
      590,
      2288,
      2287,
      2285,
      2283,
      1578,
      2280,
      1577,
      2295,
      2293,
      2291,
      579,
      577,
      574,
      571,
      2298,
      582,
      581,
      1592,
      2263,
      2262,
      2260,
      2258,
      1545,
      2255,
      1544,
      2252,
      1541,
      2273,
      2271,
      2269,
      2266,
      1550,
      535,
      532,
      2279,
      528,
      2277,
      546,
      543,
      549,
      1575,
      1573,
      2224,
      2222,
      2220,
      1486,
      2217,
      1485,
      2214,
      1482,
      1479,
      2238,
      2236,
      2234,
      2231,
      1496,
      2228,
      1492,
      480,
      477,
      2248,
      473,
      2246,
      469,
      2243,
      490,
      487,
      2251,
      497,
      1537,
      1535,
      1532,
      2477,
      2476,
      2474,
      2479,
      2469,
      2468,
      2466,
      2464,
      1730,
      2473,
      2471,
      2453,
      2452,
      2450,
      2448,
      1729,
      2445,
      1728,
      2460,
      2458,
      2456,
      2463,
      805,
      804,
      2428,
      2427,
      2425,
      2423,
      1725,
      2420,
      1724,
      2417,
      1722,
      2438,
      2436,
      2434,
      2431,
      1727,
      2444,
      2442,
      793,
      791,
      788,
      795,
      2388,
      2386,
      2384,
      1697,
      2381,
      1696,
      2378,
      1694,
      1692,
      2402,
      2400,
      2398,
      2395,
      1703,
      2392,
      1701,
      2412,
      2410,
      2407,
      751,
      748,
      744,
      2416,
      759,
      757,
      1807,
      2620,
      2618,
      1806,
      1805,
      2611,
      2609,
      2607,
      2614,
      1802,
      1801,
      1799,
      2594,
      2592,
      2590,
      2587,
      1804,
      2600,
      2598,
      1794,
      1793,
      1791,
      1789,
      2564,
      2562,
      2560,
      2557,
      1798,
      2554,
      1796,
      2574,
      2572,
      2569,
      2578,
      1847,
      1846,
      2722,
      1843,
      1842,
      1840,
      1845,
      2716,
      2714,
      1835,
      1834,
      1832,
      1830,
      1839,
      1837,
      2700,
      2698,
      2695,
      2704,
      1817,
      1811,
      1810,
      897,
      862,
      1777,
      829,
      826,
      838,
      1760,
      1758,
      808,
      2481,
      1741,
      1740,
      1738,
      1743,
      2624,
      1818,
      2726,
      2776,
      782,
      740,
      737,
      1715,
      686,
      679,
      695,
      1682,
      1680,
      639,
      628,
      2339,
      647,
      644,
      1645,
      1643,
      1640,
      1648,
      602,
      600,
      597,
      595,
      2320,
      593,
      2318,
      609,
      607,
      604,
      1611,
      1610,
      1608,
      1606,
      613,
      1615,
      1613,
      2328,
      926,
      924,
      892,
      886,
      899,
      857,
      850,
      2505,
      1778,
      824,
      823,
      821,
      819,
      2488,
      818,
      2486,
      833,
      831,
      828,
      840,
      1761,
      1759,
      2649,
      2632,
      2630,
      2746,
      2734,
      2732,
      2782,
      2781,
      570,
      567,
      1587,
      531,
      527,
      523,
      540,
      1566,
      1564,
      476,
      467,
      463,
      2240,
      486,
      483,
      1524,
      1521,
      1518,
      1529,
      411,
      403,
      2192,
      399,
      2189,
      423,
      416,
      1462,
      1457,
      1454,
      428,
      1468,
      1465,
      2210,
      366,
      363,
      2158,
      360,
      2156,
      357,
      2153,
      376,
      373,
      370,
      2163,
      1410,
      1409,
      1407,
      1405,
      382,
      1402,
      380,
      1417,
      1415,
      1412,
      1421,
      2175,
      2174,
      777,
      774,
      771,
      784,
      732,
      725,
      722,
      2404,
      743,
      1716,
      676,
      674,
      668,
      2363,
      665,
      2360,
      685,
      1684,
      1681,
      626,
      624,
      622,
      2335,
      620,
      2333,
      617,
      2330,
      641,
      635,
      649,
      1646,
      1644,
      1642,
      2566,
      928,
      925,
      2530,
      2527,
      894,
      891,
      888,
      2501,
      2499,
      2496,
      858,
      856,
      854,
      851,
      1779,
      2692,
      2668,
      2665,
      2645,
      2643,
      2640,
      2651,
      2768,
      2759,
      2757,
      2744,
      2743,
      2741,
      2748,
      352,
      1382,
      340,
      337,
      333,
      1371,
      1369,
      307,
      300,
      296,
      2126,
      315,
      312,
      1347,
      1342,
      1350,
      261,
      258,
      250,
      2097,
      246,
      2094,
      271,
      268,
      264,
      1306,
      1301,
      1298,
      276,
      1312,
      1309,
      2115,
      203,
      2048,
      195,
      2045,
      191,
      2041,
      213,
      209,
      2056,
      1246,
      1244,
      1238,
      225,
      1234,
      222,
      1256,
      1253,
      1249,
      1262,
      2080,
      2079,
      154,
      1997,
      150,
      1995,
      147,
      1992,
      1989,
      163,
      160,
      2004,
      156,
      2001,
      1175,
      1174,
      1172,
      1170,
      1167,
      170,
      1164,
      167,
      1185,
      1183,
      1180,
      1177,
      174,
      1190,
      1188,
      2025,
      2024,
      2022,
      587,
      586,
      564,
      559,
      556,
      2290,
      573,
      1588,
      520,
      518,
      512,
      2268,
      508,
      2265,
      530,
      1568,
      1565,
      461,
      457,
      2233,
      450,
      2230,
      446,
      2226,
      479,
      471,
      489,
      1526,
      1523,
      1520,
      397,
      395,
      2185,
      392,
      2183,
      389,
      2180,
      2177,
      410,
      2194,
      402,
      422,
      1463,
      1461,
      1459,
      1456,
      1470,
      2455,
      799,
      2433,
      2430,
      779,
      776,
      773,
      2397,
      2394,
      2390,
      734,
      728,
      724,
      746,
      1717,
      2356,
      2354,
      2351,
      2348,
      1658,
      677,
      675,
      673,
      670,
      667,
      688,
      1685,
      1683,
      2606,
      2589,
      2586,
      2559,
      2556,
      2552,
      927,
      2523,
      2521,
      2518,
      2515,
      1784,
      2532,
      895,
      893,
      890,
      2718,
      2709,
      2707,
      2689,
      2687,
      2684,
      2663,
      2662,
      2660,
      2658,
      1825,
      2667,
      2769,
      1852,
      2760,
      2758,
      142,
      141,
      1139,
      1138,
      134,
      132,
      129,
      126,
      1982,
      1129,
      1128,
      1126,
      1131,
      113,
      111,
      108,
      105,
      1972,
      101,
      1970,
      120,
      118,
      115,
      1109,
      1108,
      1106,
      1104,
      123,
      1113,
      1111,
      82,
      79,
      1951,
      75,
      1949,
      72,
      1946,
      92,
      89,
      86,
      1956,
      1077,
      1076,
      1074,
      1072,
      98,
      1069,
      96,
      1084,
      1082,
      1079,
      1088,
      1968,
      1967,
      48,
      45,
      1916,
      42,
      1914,
      39,
      1911,
      1908,
      60,
      57,
      54,
      1923,
      50,
      1920,
      1031,
      1030,
      1028,
      1026,
      67,
      1023,
      65,
      1020,
      62,
      1041,
      1039,
      1036,
      1033,
      69,
      1046,
      1044,
      1944,
      1943,
      1941,
      11,
      9,
      1868,
      7,
      1865,
      1862,
      1859,
      20,
      1878,
      16,
      1875,
      13,
      1872,
      970,
      968,
      966,
      963,
      29,
      960,
      26,
      23,
      983,
      981,
      978,
      975,
      33,
      971,
      31,
      990,
      988,
      985,
      1906,
      1904,
      1902,
      993,
      351,
      2145,
      1383,
      331,
      330,
      328,
      326,
      2137,
      323,
      2135,
      339,
      1372,
      1370,
      294,
      293,
      291,
      289,
      2122,
      286,
      2120,
      283,
      2117,
      309,
      303,
      317,
      1348,
      1346,
      1344,
      245,
      244,
      242,
      2090,
      239,
      2088,
      236,
      2085,
      2082,
      260,
      2099,
      249,
      270,
      1307,
      1305,
      1303,
      1300,
      1314,
      189,
      2038,
      186,
      2036,
      183,
      2033,
      2030,
      2026,
      206,
      198,
      2047,
      194,
      216,
      1247,
      1245,
      1243,
      1240,
      227,
      1237,
      1255,
      2310,
      2302,
      2300,
      2286,
      2284,
      2281,
      565,
      563,
      561,
      558,
      575,
      1589,
      2261,
      2259,
      2256,
      2253,
      1542,
      521,
      519,
      517,
      514,
      2270,
      511,
      533,
      1569,
      1567,
      2223,
      2221,
      2218,
      2215,
      1483,
      2211,
      1480,
      459,
      456,
      453,
      2232,
      449,
      474,
      491,
      1527,
      1525,
      1522,
      2475,
      2467,
      2465,
      2451,
      2449,
      2446,
      801,
      800,
      2426,
      2424,
      2421,
      2418,
      1723,
      2435,
      780,
      778,
      775,
      2387,
      2385,
      2382,
      2379,
      1695,
      2375,
      1693,
      2396,
      735,
      733,
      730,
      727,
      749,
      1718,
      2616,
      2615,
      2604,
      2603,
      2601,
      2584,
      2583,
      2581,
      2579,
      1800,
      2591,
      2550,
      2549,
      2547,
      2545,
      1792,
      2542,
      1790,
      2558,
      929,
      2719,
      1841,
      2710,
      2708,
      1833,
      1831,
      2690,
      2688,
      2686,
      1815,
      1809,
      1808,
      1774,
      1756,
      1754,
      1737,
      1736,
      1734,
      1739,
      1816,
      1711,
      1676,
      1674,
      633,
      629,
      1638,
      1636,
      1633,
      1641,
      598,
      1605,
      1604,
      1602,
      1600,
      605,
      1609,
      1607,
      2327,
      887,
      853,
      1775,
      822,
      820,
      1757,
      1755,
      1584,
      524,
      1560,
      1558,
      468,
      464,
      1514,
      1511,
      1508,
      1519,
      408,
      404,
      400,
      1452,
      1447,
      1444,
      417,
      1458,
      1455,
      2208,
      364,
      361,
      358,
      2154,
      1401,
      1400,
      1398,
      1396,
      374,
      1393,
      371,
      1408,
      1406,
      1403,
      1413,
      2173,
      2172,
      772,
      726,
      723,
      1712,
      672,
      669,
      666,
      682,
      1678,
      1675,
      625,
      623,
      621,
      618,
      2331,
      636,
      632,
      1639,
      1637,
      1635,
      920,
      918,
      884,
      880,
      889,
      849,
      848,
      847,
      846,
      2497,
      855,
      852,
      1776,
      2641,
      2742,
      2787,
      1380,
      334,
      1367,
      1365,
      301,
      297,
      1340,
      1338,
      1335,
      1343,
      255,
      251,
      247,
      1296,
      1291,
      1288,
      265,
      1302,
      1299,
      2113,
      204,
      196,
      192,
      2042,
      1232,
      1230,
      1224,
      214,
      1220,
      210,
      1242,
      1239,
      1235,
      1250,
      2077,
      2075,
      151,
      148,
      1993,
      144,
      1990,
      1163,
      1162,
      1160,
      1158,
      1155,
      161,
      1152,
      157,
      1173,
      1171,
      1168,
      1165,
      168,
      1181,
      1178,
      2021,
      2020,
      2018,
      2023,
      585,
      560,
      557,
      1585,
      516,
      509,
      1562,
      1559,
      458,
      447,
      2227,
      472,
      1516,
      1513,
      1510,
      398,
      396,
      393,
      390,
      2181,
      386,
      2178,
      407,
      1453,
      1451,
      1449,
      1446,
      420,
      1460,
      2209,
      769,
      764,
      720,
      712,
      2391,
      729,
      1713,
      664,
      663,
      661,
      659,
      2352,
      656,
      2349,
      671,
      1679,
      1677,
      2553,
      922,
      919,
      2519,
      2516,
      885,
      883,
      881,
      2685,
      2661,
      2659,
      2767,
      2756,
      2755,
      140,
      1137,
      1136,
      130,
      127,
      1125,
      1124,
      1122,
      1127,
      109,
      106,
      102,
      1103,
      1102,
      1100,
      1098,
      116,
      1107,
      1105,
      1980,
      80,
      76,
      73,
      1947,
      1068,
      1067,
      1065,
      1063,
      90,
      1060,
      87,
      1075,
      1073,
      1070,
      1080,
      1966,
      1965,
      46,
      43,
      40,
      1912,
      36,
      1909,
      1019,
      1018,
      1016,
      1014,
      58,
      1011,
      55,
      1008,
      51,
      1029,
      1027,
      1024,
      1021,
      63,
      1037,
      1034,
      1940,
      1939,
      1937,
      1942,
      8,
      1866,
      4,
      1863,
      1,
      1860,
      956,
      954,
      952,
      949,
      946,
      17,
      14,
      969,
      967,
      964,
      961,
      27,
      957,
      24,
      979,
      976,
      972,
      1901,
      1900,
      1898,
      1896,
      986,
      1905,
      1903,
      350,
      349,
      1381,
      329,
      327,
      324,
      1368,
      1366,
      292,
      290,
      287,
      284,
      2118,
      304,
      1341,
      1339,
      1337,
      1345,
      243,
      240,
      237,
      2086,
      233,
      2083,
      254,
      1297,
      1295,
      1293,
      1290,
      1304,
      2114,
      190,
      187,
      184,
      2034,
      180,
      2031,
      177,
      2027,
      199,
      1233,
      1231,
      1229,
      1226,
      217,
      1223,
      1241,
      2078,
      2076,
      584,
      555,
      554,
      552,
      550,
      2282,
      562,
      1586,
      507,
      506,
      504,
      502,
      2257,
      499,
      2254,
      515,
      1563,
      1561,
      445,
      443,
      441,
      2219,
      438,
      2216,
      435,
      2212,
      460,
      454,
      475,
      1517,
      1515,
      1512,
      2447,
      798,
      797,
      2422,
      2419,
      770,
      768,
      766,
      2383,
      2380,
      2376,
      721,
      719,
      717,
      714,
      731,
      1714,
      2602,
      2582,
      2580,
      2548,
      2546,
      2543,
      923,
      921,
      2717,
      2706,
      2705,
      2683,
      2682,
      2680,
      1771,
      1752,
      1750,
      1733,
      1732,
      1731,
      1735,
      1814,
      1707,
      1670,
      1668,
      1631,
      1629,
      1626,
      1634,
      1599,
      1598,
      1596,
      1594,
      1603,
      1601,
      2326,
      1772,
      1753,
      1751,
      1581,
      1554,
      1552,
      1504,
      1501,
      1498,
      1509,
      1442,
      1437,
      1434,
      401,
      1448,
      1445,
      2206,
      1392,
      1391,
      1389,
      1387,
      1384,
      359,
      1399,
      1397,
      1394,
      1404,
      2171,
      2170,
      1708,
      1672,
      1669,
      619,
      1632,
      1630,
      1628,
      1773,
      1378,
      1363,
      1361,
      1333,
      1328,
      1336,
      1286,
      1281,
      1278,
      248,
      1292,
      1289,
      2111,
      1218,
      1216,
      1210,
      197,
      1206,
      193,
      1228,
      1225,
      1221,
      1236,
      2073,
      2071,
      1151,
      1150,
      1148,
      1146,
      152,
      1143,
      149,
      1140,
      145,
      1161,
      1159,
      1156,
      1153,
      158,
      1169,
      1166,
      2017,
      2016,
      2014,
      2019,
      1582,
      510,
      1556,
      1553,
      452,
      448,
      1506,
      1500,
      394,
      391,
      387,
      1443,
      1441,
      1439,
      1436,
      1450,
      2207,
      765,
      716,
      713,
      1709,
      662,
      660,
      657,
      1673,
      1671,
      916,
      914,
      879,
      878,
      877,
      882,
      1135,
      1134,
      1121,
      1120,
      1118,
      1123,
      1097,
      1096,
      1094,
      1092,
      103,
      1101,
      1099,
      1979,
      1059,
      1058,
      1056,
      1054,
      77,
      1051,
      74,
      1066,
      1064,
      1061,
      1071,
      1964,
      1963,
      1007,
      1006,
      1004,
      1002,
      999,
      41,
      996,
      37,
      1017,
      1015,
      1012,
      1009,
      52,
      1025,
      1022,
      1936,
      1935,
      1933,
      1938,
      942,
      940,
      938,
      935,
      932,
      5,
      2,
      955,
      953,
      950,
      947,
      18,
      943,
      15,
      965,
      962,
      958,
      1895,
      1894,
      1892,
      1890,
      973,
      1899,
      1897,
      1379,
      325,
      1364,
      1362,
      288,
      285,
      1334,
      1332,
      1330,
      241,
      238,
      234,
      1287,
      1285,
      1283,
      1280,
      1294,
      2112,
      188,
      185,
      181,
      178,
      2028,
      1219,
      1217,
      1215,
      1212,
      200,
      1209,
      1227,
      2074,
      2072,
      583,
      553,
      551,
      1583,
      505,
      503,
      500,
      513,
      1557,
      1555,
      444,
      442,
      439,
      436,
      2213,
      455,
      451,
      1507,
      1505,
      1502,
      796,
      763,
      762,
      760,
      767,
      711,
      710,
      708,
      706,
      2377,
      718,
      715,
      1710,
      2544,
      917,
      915,
      2681,
      1627,
      1597,
      1595,
      2325,
      1769,
      1749,
      1747,
      1499,
      1438,
      1435,
      2204,
      1390,
      1388,
      1385,
      1395,
      2169,
      2167,
      1704,
      1665,
      1662,
      1625,
      1623,
      1620,
      1770,
      1329,
      1282,
      1279,
      2109,
      1214,
      1207,
      1222,
      2068,
      2065,
      1149,
      1147,
      1144,
      1141,
      146,
      1157,
      1154,
      2013,
      2011,
      2008,
      2015,
      1579,
      1549,
      1546,
      1495,
      1487,
      1433,
      1431,
      1428,
      1425,
      388,
      1440,
      2205,
      1705,
      658,
      1667,
      1664,
      1119,
      1095,
      1093,
      1978,
      1057,
      1055,
      1052,
      1062,
      1962,
      1960,
      1005,
      1003,
      1e3,
      997,
      38,
      1013,
      1010,
      1932,
      1930,
      1927,
      1934,
      941,
      939,
      936,
      933,
      6,
      930,
      3,
      951,
      948,
      944,
      1889,
      1887,
      1884,
      1881,
      959,
      1893,
      1891,
      35,
      1377,
      1360,
      1358,
      1327,
      1325,
      1322,
      1331,
      1277,
      1275,
      1272,
      1269,
      235,
      1284,
      2110,
      1205,
      1204,
      1201,
      1198,
      182,
      1195,
      179,
      1213,
      2070,
      2067,
      1580,
      501,
      1551,
      1548,
      440,
      437,
      1497,
      1494,
      1490,
      1503,
      761,
      709,
      707,
      1706,
      913,
      912,
      2198,
      1386,
      2164,
      2161,
      1621,
      1766,
      2103,
      1208,
      2058,
      2054,
      1145,
      1142,
      2005,
      2002,
      1999,
      2009,
      1488,
      1429,
      1426,
      2200,
      1698,
      1659,
      1656,
      1975,
      1053,
      1957,
      1954,
      1001,
      998,
      1924,
      1921,
      1918,
      1928,
      937,
      934,
      931,
      1879,
      1876,
      1873,
      1870,
      945,
      1885,
      1882,
      1323,
      1273,
      1270,
      2105,
      1202,
      1199,
      1196,
      1211,
      2061,
      2057,
      1576,
      1543,
      1540,
      1484,
      1481,
      1478,
      1491,
      1700
    ]);
    class PDF417DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class Detector$3 {
      static detectMultiple(image, hints, multiple) {
        let bitMatrix = image.getBlackMatrix();
        let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        if (!barcodeCoordinates.length) {
          bitMatrix = bitMatrix.clone();
          bitMatrix.rotate180();
          barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        }
        return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
      }
      static detect(multiple, bitMatrix) {
        const barcodeCoordinates = new Array();
        let row = 0;
        let column = 0;
        let foundBarcodeInRow = false;
        while (row < bitMatrix.getHeight()) {
          const vertices = Detector$3.findVertices(bitMatrix, row, column);
          if (vertices[0] == null && vertices[3] == null) {
            if (!foundBarcodeInRow) {
              break;
            }
            foundBarcodeInRow = false;
            column = 0;
            for (const barcodeCoordinate of barcodeCoordinates) {
              if (barcodeCoordinate[1] != null) {
                row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
              }
              if (barcodeCoordinate[3] != null) {
                row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
              }
            }
            row += Detector$3.ROW_STEP;
            continue;
          }
          foundBarcodeInRow = true;
          barcodeCoordinates.push(vertices);
          if (!multiple) {
            break;
          }
          if (vertices[2] != null) {
            column = Math.trunc(vertices[2].getX());
            row = Math.trunc(vertices[2].getY());
          } else {
            column = Math.trunc(vertices[4].getX());
            row = Math.trunc(vertices[4].getY());
          }
        }
        return barcodeCoordinates;
      }
      static findVertices(matrix, startRow, startColumn) {
        const height = matrix.getHeight();
        const width = matrix.getWidth();
        const result = new Array(8);
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
        if (result[4] != null) {
          startColumn = Math.trunc(result[4].getX());
          startRow = Math.trunc(result[4].getY());
        }
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
        return result;
      }
      static copyToResult(result, tmpResult, destinationIndexes) {
        for (let i2 = 0; i2 < destinationIndexes.length; i2++) {
          result[destinationIndexes[i2]] = tmpResult[i2];
        }
      }
      static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
        const result = new Array(4);
        let found = false;
        const counters = new Int32Array(pattern.length);
        for (; startRow < height; startRow += Detector$3.ROW_STEP) {
          let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
          if (loc != null) {
            while (startRow > 0) {
              const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
              if (previousRowLoc != null) {
                loc = previousRowLoc;
              } else {
                startRow++;
                break;
              }
            }
            result[0] = new ResultPoint(loc[0], startRow);
            result[1] = new ResultPoint(loc[1], startRow);
            found = true;
            break;
          }
        }
        let stopRow = startRow + 1;
        if (found) {
          let skippedRowCount = 0;
          let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
          for (; stopRow < height; stopRow++) {
            const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
            if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
              previousRowLoc = loc;
              skippedRowCount = 0;
            } else {
              if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                break;
              } else {
                skippedRowCount++;
              }
            }
          }
          stopRow -= skippedRowCount + 1;
          result[2] = new ResultPoint(previousRowLoc[0], stopRow);
          result[3] = new ResultPoint(previousRowLoc[1], stopRow);
        }
        if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
          Arrays.fill(result, null);
        }
        return result;
      }
      static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
        Arrays.fillWithin(counters, 0, counters.length, 0);
        let patternStart = column;
        let pixelDrift = 0;
        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
          patternStart--;
        }
        let x = patternStart;
        let counterPosition = 0;
        let patternLength = pattern.length;
        for (let isWhite = whiteFirst; x < width; x++) {
          let pixel = matrix.get(x, row);
          if (pixel !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                return new Int32Array([patternStart, x]);
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
          return new Int32Array([patternStart, x - 1]);
        }
        return null;
      }
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        let numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i2 = 0; i2 < numCounters; i2++) {
          total += counters[i2];
          patternLength += pattern[i2];
        }
        if (total < patternLength) {
          return Infinity;
        }
        let unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x = 0; x < numCounters; x++) {
          let counter = counters[x];
          let scaledPattern = pattern[x] * unitBarWidth;
          let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return Infinity;
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
    Detector$3.MAX_AVG_VARIANCE = 0.42;
    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
    Detector$3.MAX_PIXEL_DRIFT = 3;
    Detector$3.MAX_PATTERN_DRIFT = 5;
    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
    Detector$3.ROW_STEP = 5;
    Detector$3.BARCODE_MIN_HEIGHT = 10;
    class ModulusPoly {
      constructor(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field;
        let coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = new Int32Array([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      getDegree() {
        return this.coefficients.length - 1;
      }
      isZero() {
        return this.coefficients[0] === 0;
      }
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      evaluateAt(a2) {
        if (a2 === 0) {
          return this.getCoefficient(0);
        }
        if (a2 === 1) {
          let sum = 0;
          for (let coefficient of this.coefficients) {
            sum = this.field.add(sum, coefficient);
          }
          return sum;
        }
        let result = this.coefficients[0];
        let size2 = this.coefficients.length;
        for (let i2 = 1; i2 < size2; i2++) {
          result = this.field.add(this.field.multiply(a2, result), this.coefficients[i2]);
        }
        return result;
      }
      add(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          let temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        let lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i2 = lengthDiff; i2 < largerCoefficients.length; i2++) {
          sumDiff[i2] = this.field.add(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
        }
        return new ModulusPoly(this.field, sumDiff);
      }
      subtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (other.isZero()) {
          return this;
        }
        return this.add(other.negative());
      }
      multiply(other) {
        if (other instanceof ModulusPoly) {
          return this.multiplyOther(other);
        }
        return this.multiplyScalar(other);
      }
      multiplyOther(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero() || other.isZero()) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let aCoefficients = this.coefficients;
        let aLength = aCoefficients.length;
        let bCoefficients = other.coefficients;
        let bLength = bCoefficients.length;
        let product = new Int32Array(aLength + bLength - 1);
        for (let i2 = 0; i2 < aLength; i2++) {
          let aCoeff = aCoefficients[i2];
          for (let j = 0; j < bLength; j++) {
            product[i2 + j] = this.field.add(product[i2 + j], this.field.multiply(aCoeff, bCoefficients[j]));
          }
        }
        return new ModulusPoly(this.field, product);
      }
      negative() {
        let size2 = this.coefficients.length;
        let negativeCoefficients = new Int32Array(size2);
        for (let i2 = 0; i2 < size2; i2++) {
          negativeCoefficients[i2] = this.field.subtract(0, this.coefficients[i2]);
        }
        return new ModulusPoly(this.field, negativeCoefficients);
      }
      multiplyScalar(scalar) {
        if (scalar === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        if (scalar === 1) {
          return this;
        }
        let size2 = this.coefficients.length;
        let product = new Int32Array(size2);
        for (let i2 = 0; i2 < size2; i2++) {
          product[i2] = this.field.multiply(this.coefficients[i2], scalar);
        }
        return new ModulusPoly(this.field, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let size2 = this.coefficients.length;
        let product = new Int32Array(size2 + degree);
        for (let i2 = 0; i2 < size2; i2++) {
          product[i2] = this.field.multiply(this.coefficients[i2], coefficient);
        }
        return new ModulusPoly(this.field, product);
      }
      toString() {
        let result = new StringBuilder();
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = this.getCoefficient(degree);
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result.append(" - ");
              coefficient = -coefficient;
            } else {
              if (result.length() > 0) {
                result.append(" + ");
              }
            }
            if (degree === 0 || coefficient !== 1) {
              result.append(coefficient);
            }
            if (degree !== 0) {
              if (degree === 1) {
                result.append("x");
              } else {
                result.append("x^");
                result.append(degree);
              }
            }
          }
        }
        return result.toString();
      }
    }
    class ModulusBase {
      add(a2, b) {
        return (a2 + b) % this.modulus;
      }
      subtract(a2, b) {
        return (this.modulus + a2 - b) % this.modulus;
      }
      exp(a2) {
        return this.expTable[a2];
      }
      log(a2) {
        if (a2 === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a2];
      }
      inverse(a2) {
        if (a2 === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.modulus - this.logTable[a2] - 1];
      }
      multiply(a2, b) {
        if (a2 === 0 || b === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a2] + this.logTable[b]) % (this.modulus - 1)];
      }
      getSize() {
        return this.modulus;
      }
      equals(o2) {
        return o2 === this;
      }
    }
    class ModulusGF extends ModulusBase {
      constructor(modulus, generator) {
        super();
        this.modulus = modulus;
        this.expTable = new Int32Array(modulus);
        this.logTable = new Int32Array(modulus);
        let x = 1;
        for (let i2 = 0; i2 < modulus; i2++) {
          this.expTable[i2] = x;
          x = x * generator % modulus;
        }
        for (let i2 = 0; i2 < modulus - 1; i2++) {
          this.logTable[this.expTable[i2]] = i2;
        }
        this.zero = new ModulusPoly(this, new Int32Array([0]));
        this.one = new ModulusPoly(this, new Int32Array([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        let coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new ModulusPoly(this, coefficients);
      }
    }
    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);
    class ErrorCorrection {
      constructor() {
        this.field = ModulusGF.PDF417_GF;
      }
      decode(received, numECCodewords, erasures) {
        let poly = new ModulusPoly(this.field, received);
        let S = new Int32Array(numECCodewords);
        let error = false;
        for (let i2 = numECCodewords; i2 > 0; i2--) {
          let evaluation = poly.evaluateAt(this.field.exp(i2));
          S[numECCodewords - i2] = evaluation;
          if (evaluation !== 0) {
            error = true;
          }
        }
        if (!error) {
          return 0;
        }
        let knownErrors = this.field.getOne();
        if (erasures != null) {
          for (const erasure of erasures) {
            let b = this.field.exp(received.length - 1 - erasure);
            let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b), 1]));
            knownErrors = knownErrors.multiply(term);
          }
        }
        let syndrome = new ModulusPoly(this.field, S);
        let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
        let sigma = sigmaOmega[0];
        let omega = sigmaOmega[1];
        let errorLocations = this.findErrorLocations(sigma);
        let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
        for (let i2 = 0; i2 < errorLocations.length; i2++) {
          let position = received.length - 1 - this.field.log(errorLocations[i2]);
          if (position < 0) {
            throw ChecksumException.getChecksumInstance();
          }
          received[position] = this.field.subtract(received[position], errorMagnitudes[i2]);
        }
        return errorLocations.length;
      }
      runEuclideanAlgorithm(a2, b, R) {
        if (a2.getDegree() < b.getDegree()) {
          let temp = a2;
          a2 = b;
          b = temp;
        }
        let rLast = a2;
        let r2 = b;
        let tLast = this.field.getZero();
        let t2 = this.field.getOne();
        while (r2.getDegree() >= Math.round(R / 2)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r2;
          tLast = t2;
          if (rLast.isZero()) {
            throw ChecksumException.getChecksumInstance();
          }
          r2 = rLastLast;
          let q = this.field.getZero();
          let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          let dltInverse = this.field.inverse(denominatorLeadingTerm);
          while (r2.getDegree() >= rLast.getDegree() && !r2.isZero()) {
            let degreeDiff = r2.getDegree() - rLast.getDegree();
            let scale = this.field.multiply(r2.getCoefficient(r2.getDegree()), dltInverse);
            q = q.add(this.field.buildMonomial(degreeDiff, scale));
            r2 = r2.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t2 = q.multiply(tLast).subtract(tLastLast).negative();
        }
        let sigmaTildeAtZero = t2.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw ChecksumException.getChecksumInstance();
        }
        let inverse = this.field.inverse(sigmaTildeAtZero);
        let sigma = t2.multiply(inverse);
        let omega = r2.multiply(inverse);
        return [sigma, omega];
      }
      findErrorLocations(errorLocator) {
        let numErrors = errorLocator.getDegree();
        let result = new Int32Array(numErrors);
        let e2 = 0;
        for (let i2 = 1; i2 < this.field.getSize() && e2 < numErrors; i2++) {
          if (errorLocator.evaluateAt(i2) === 0) {
            result[e2] = this.field.inverse(i2);
            e2++;
          }
        }
        if (e2 !== numErrors) {
          throw ChecksumException.getChecksumInstance();
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
        let errorLocatorDegree = errorLocator.getDegree();
        let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
        for (let i2 = 1; i2 <= errorLocatorDegree; i2++) {
          formalDerivativeCoefficients[errorLocatorDegree - i2] = this.field.multiply(i2, errorLocator.getCoefficient(i2));
        }
        let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
        let s2 = errorLocations.length;
        let result = new Int32Array(s2);
        for (let i2 = 0; i2 < s2; i2++) {
          let xiInverse = this.field.inverse(errorLocations[i2]);
          let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
          let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
          result[i2] = this.field.multiply(numerator, denominator);
        }
        return result;
      }
    }
    class BoundingBox {
      constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
        if (image instanceof BoundingBox) {
          this.constructor_2(image);
        } else {
          this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
        }
      }
      constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
        const leftUnspecified = topLeft == null || bottomLeft == null;
        const rightUnspecified = topRight == null || bottomRight == null;
        if (leftUnspecified && rightUnspecified) {
          throw new NotFoundException();
        }
        if (leftUnspecified) {
          topLeft = new ResultPoint(0, topRight.getY());
          bottomLeft = new ResultPoint(0, bottomRight.getY());
        } else if (rightUnspecified) {
          topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
          bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
        }
        this.image = image;
        this.topLeft = topLeft;
        this.bottomLeft = bottomLeft;
        this.topRight = topRight;
        this.bottomRight = bottomRight;
        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
      }
      constructor_2(boundingBox) {
        this.image = boundingBox.image;
        this.topLeft = boundingBox.getTopLeft();
        this.bottomLeft = boundingBox.getBottomLeft();
        this.topRight = boundingBox.getTopRight();
        this.bottomRight = boundingBox.getBottomRight();
        this.minX = boundingBox.getMinX();
        this.maxX = boundingBox.getMaxX();
        this.minY = boundingBox.getMinY();
        this.maxY = boundingBox.getMaxY();
      }
      static merge(leftBox, rightBox) {
        if (leftBox == null) {
          return rightBox;
        }
        if (rightBox == null) {
          return leftBox;
        }
        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
      }
      addMissingRows(missingStartRows, missingEndRows, isLeft) {
        let newTopLeft = this.topLeft;
        let newBottomLeft = this.bottomLeft;
        let newTopRight = this.topRight;
        let newBottomRight = this.bottomRight;
        if (missingStartRows > 0) {
          let top = isLeft ? this.topLeft : this.topRight;
          let newMinY = Math.trunc(top.getY() - missingStartRows);
          if (newMinY < 0) {
            newMinY = 0;
          }
          let newTop = new ResultPoint(top.getX(), newMinY);
          if (isLeft) {
            newTopLeft = newTop;
          } else {
            newTopRight = newTop;
          }
        }
        if (missingEndRows > 0) {
          let bottom = isLeft ? this.bottomLeft : this.bottomRight;
          let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
          if (newMaxY >= this.image.getHeight()) {
            newMaxY = this.image.getHeight() - 1;
          }
          let newBottom = new ResultPoint(bottom.getX(), newMaxY);
          if (isLeft) {
            newBottomLeft = newBottom;
          } else {
            newBottomRight = newBottom;
          }
        }
        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
      }
      getMinX() {
        return this.minX;
      }
      getMaxX() {
        return this.maxX;
      }
      getMinY() {
        return this.minY;
      }
      getMaxY() {
        return this.maxY;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getBottomRight() {
        return this.bottomRight;
      }
    }
    class BarcodeMetadata {
      constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
        this.columnCount = columnCount;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.rowCountUpperPart = rowCountUpperPart;
        this.rowCountLowerPart = rowCountLowerPart;
        this.rowCount = rowCountUpperPart + rowCountLowerPart;
      }
      getColumnCount() {
        return this.columnCount;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getRowCount() {
        return this.rowCount;
      }
      getRowCountUpperPart() {
        return this.rowCountUpperPart;
      }
      getRowCountLowerPart() {
        return this.rowCountLowerPart;
      }
    }
    class Formatter {
      constructor() {
        this.buffer = "";
      }
      static form(str, arr) {
        let i2 = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (arr[++i2] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = arr[i2];
              break;
            case "c":
              val = arr[i2][0];
              break;
            case "f":
              val = parseFloat(arr[i2]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(arr[i2]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(arr[i2]).toExponential(exp);
              break;
            case "x":
              val = parseInt(arr[i2]).toString(base ? base : 16);
              break;
            case "d":
              val = parseFloat(parseInt(arr[i2], base ? base : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
          let size2 = parseInt(p1);
          let ch = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size2)
            val = p0 !== void 0 ? val + ch : ch + val;
          return val;
        }
        let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return str.replace(regex, callback);
      }
      format(append, ...args) {
        this.buffer += Formatter.form(append, args);
      }
      toString() {
        return this.buffer;
      }
    }
    class DetectionResultColumn {
      constructor(boundingBox) {
        this.boundingBox = new BoundingBox(boundingBox);
        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
      }
      getCodewordNearby(imageRow) {
        let codeword = this.getCodeword(imageRow);
        if (codeword != null) {
          return codeword;
        }
        for (let i2 = 1; i2 < DetectionResultColumn.MAX_NEARBY_DISTANCE; i2++) {
          let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i2;
          if (nearImageRow >= 0) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
          nearImageRow = this.imageRowToCodewordIndex(imageRow) + i2;
          if (nearImageRow < this.codewords.length) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
        }
        return null;
      }
      imageRowToCodewordIndex(imageRow) {
        return imageRow - this.boundingBox.getMinY();
      }
      setCodeword(imageRow, codeword) {
        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
      }
      getCodeword(imageRow) {
        return this.codewords[this.imageRowToCodewordIndex(imageRow)];
      }
      getBoundingBox() {
        return this.boundingBox;
      }
      getCodewords() {
        return this.codewords;
      }
      toString() {
        const formatter = new Formatter();
        let row = 0;
        for (const codeword of this.codewords) {
          if (codeword == null) {
            formatter.format("%3d:    |   %n", row++);
            continue;
          }
          formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
        }
        return formatter.toString();
      }
    }
    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
    class BarcodeValue {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      setValue(value) {
        value = Math.trunc(value);
        let confidence = this.values.get(value);
        if (confidence == null) {
          confidence = 0;
        }
        confidence++;
        this.values.set(value, confidence);
      }
      getValue() {
        let maxConfidence = -1;
        let result = new Array();
        for (const [key, value] of this.values.entries()) {
          const entry = {
            getKey: () => key,
            getValue: () => value
          };
          if (entry.getValue() > maxConfidence) {
            maxConfidence = entry.getValue();
            result = [];
            result.push(entry.getKey());
          } else if (entry.getValue() === maxConfidence) {
            result.push(entry.getKey());
          }
        }
        return PDF417Common.toIntArray(result);
      }
      getConfidence(value) {
        return this.values.get(value);
      }
    }
    class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
      constructor(boundingBox, isLeft) {
        super(boundingBox);
        this._isLeft = isLeft;
      }
      setRowNumbers() {
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            codeword.setRowNumberAsRowIndicatorColumn();
          }
        }
      }
      adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let codewords = this.getCodewords();
        this.setRowNumbers();
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let barcodeRow = -1;
        let maxRowHeight = 1;
        let currentRowHeight = 0;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) {
            currentRowHeight++;
          } else if (rowDifference === 1) {
            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
            currentRowHeight = 1;
            barcodeRow = codeword.getRowNumber();
          } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
            codewords[codewordsRow] = null;
          } else {
            let checkedRows;
            if (maxRowHeight > 2) {
              checkedRows = (maxRowHeight - 2) * rowDifference;
            } else {
              checkedRows = rowDifference;
            }
            let closePreviousCodewordFound = checkedRows >= codewordsRow;
            for (let i2 = 1; i2 <= checkedRows && !closePreviousCodewordFound; i2++) {
              closePreviousCodewordFound = codewords[codewordsRow - i2] != null;
            }
            if (closePreviousCodewordFound) {
              codewords[codewordsRow] = null;
            } else {
              barcodeRow = codeword.getRowNumber();
              currentRowHeight = 1;
            }
          }
        }
      }
      getRowHeights() {
        let barcodeMetadata = this.getBarcodeMetadata();
        if (barcodeMetadata == null) {
          return null;
        }
        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
        let result = new Int32Array(barcodeMetadata.getRowCount());
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            let rowNumber = codeword.getRowNumber();
            if (rowNumber >= result.length) {
              continue;
            }
            result[rowNumber]++;
          }
        }
        return result;
      }
      adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let codewords = this.getCodewords();
        let barcodeRow = -1;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0)
            ;
          else if (rowDifference === 1) {
            barcodeRow = codeword.getRowNumber();
          } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
            codewords[codewordsRow] = null;
          } else {
            barcodeRow = codeword.getRowNumber();
          }
        }
      }
      getBarcodeMetadata() {
        let codewords = this.getCodewords();
        let barcodeColumnCount = new BarcodeValue();
        let barcodeRowCountUpperPart = new BarcodeValue();
        let barcodeRowCountLowerPart = new BarcodeValue();
        let barcodeECLevel = new BarcodeValue();
        for (let codeword of codewords) {
          if (codeword == null) {
            continue;
          }
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
              break;
            case 1:
              barcodeECLevel.setValue(rowIndicatorValue / 3);
              barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
              break;
            case 2:
              barcodeColumnCount.setValue(rowIndicatorValue + 1);
              break;
          }
        }
        if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
          return null;
        }
        let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        return barcodeMetadata;
      }
      removeIncorrectCodewords(codewords, barcodeMetadata) {
        for (let codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
          let codeword = codewords[codewordRow];
          if (codewords[codewordRow] == null) {
            continue;
          }
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (codewordRowNumber > barcodeMetadata.getRowCount()) {
            codewords[codewordRow] = null;
            continue;
          }
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 1:
              if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 2:
              if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                codewords[codewordRow] = null;
              }
              break;
          }
        }
      }
      isLeft() {
        return this._isLeft;
      }
      toString() {
        return "IsLeft: " + this._isLeft + "\n" + super.toString();
      }
    }
    class DetectionResult {
      constructor(barcodeMetadata, boundingBox) {
        this.ADJUST_ROW_NUMBER_SKIP = 2;
        this.barcodeMetadata = barcodeMetadata;
        this.barcodeColumnCount = barcodeMetadata.getColumnCount();
        this.boundingBox = boundingBox;
        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
      }
      getDetectionResultColumns() {
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
        let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
        let previousUnadjustedCount;
        do {
          previousUnadjustedCount = unadjustedCodewordCount;
          unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
        return this.detectionResultColumns;
      }
      adjustIndicatorColumnRowNumbers(detectionResultColumn) {
        if (detectionResultColumn != null) {
          detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
        }
      }
      adjustRowNumbersAndGetCount() {
        let unadjustedCount = this.adjustRowNumbersByRow();
        if (unadjustedCount === 0) {
          return 0;
        }
        for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
          let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
          for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            if (!codewords[codewordsRow].hasValidRowNumber()) {
              this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersByRow() {
        this.adjustRowNumbersFromBothRI();
        let unadjustedCount = this.adjustRowNumbersFromLRI();
        return unadjustedCount + this.adjustRowNumbersFromRRI();
      }
      adjustRowNumbersFromBothRI() {
        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return;
        }
        let LRIcodewords = this.detectionResultColumns[0].getCodewords();
        let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
          if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
            for (let barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword == null) {
                continue;
              }
              codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
              if (!codeword.hasValidRowNumber()) {
                this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
              }
            }
          }
        }
      }
      adjustRowNumbersFromRRI() {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersFromLRI() {
        if (this.detectionResultColumns[0] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[0].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
        if (codeword == null) {
          return invalidRowCounts;
        }
        if (!codeword.hasValidRowNumber()) {
          if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
            codeword.setRowNumber(rowIndicatorRowNumber);
            invalidRowCounts = 0;
          } else {
            ++invalidRowCounts;
          }
        }
        return invalidRowCounts;
      }
      adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
        let codeword = codewords[codewordsRow];
        let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
        let nextColumnCodewords = previousColumnCodewords;
        if (this.detectionResultColumns[barcodeColumn + 1] != null) {
          nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
        }
        let otherCodewords = new Array(14);
        otherCodewords[2] = previousColumnCodewords[codewordsRow];
        otherCodewords[3] = nextColumnCodewords[codewordsRow];
        if (codewordsRow > 0) {
          otherCodewords[0] = codewords[codewordsRow - 1];
          otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
          otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
        }
        if (codewordsRow > 1) {
          otherCodewords[8] = codewords[codewordsRow - 2];
          otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
          otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
        }
        if (codewordsRow < codewords.length - 1) {
          otherCodewords[1] = codewords[codewordsRow + 1];
          otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
          otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
        }
        if (codewordsRow < codewords.length - 2) {
          otherCodewords[9] = codewords[codewordsRow + 2];
          otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
          otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
        }
        for (let otherCodeword of otherCodewords) {
          if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
            return;
          }
        }
      }
      static adjustRowNumber(codeword, otherCodeword) {
        if (otherCodeword == null) {
          return false;
        }
        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
          codeword.setRowNumber(otherCodeword.getRowNumber());
          return true;
        }
        return false;
      }
      getBarcodeColumnCount() {
        return this.barcodeColumnCount;
      }
      getBarcodeRowCount() {
        return this.barcodeMetadata.getRowCount();
      }
      getBarcodeECLevel() {
        return this.barcodeMetadata.getErrorCorrectionLevel();
      }
      setBoundingBox(boundingBox) {
        this.boundingBox = boundingBox;
      }
      getBoundingBox() {
        return this.boundingBox;
      }
      setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
      }
      getDetectionResultColumn(barcodeColumn) {
        return this.detectionResultColumns[barcodeColumn];
      }
      toString() {
        let rowIndicatorColumn = this.detectionResultColumns[0];
        if (rowIndicatorColumn == null) {
          rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
        }
        let formatter = new Formatter();
        for (let codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
          formatter.format("CW %3d:", codewordsRow);
          for (let barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
            if (this.detectionResultColumns[barcodeColumn] == null) {
              formatter.format("    |   ");
              continue;
            }
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword == null) {
              formatter.format("    |   ");
              continue;
            }
            formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    class Codeword {
      constructor(startX, endX, bucket, value) {
        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
        this.startX = Math.trunc(startX);
        this.endX = Math.trunc(endX);
        this.bucket = Math.trunc(bucket);
        this.value = Math.trunc(value);
      }
      hasValidRowNumber() {
        return this.isValidRowNumber(this.rowNumber);
      }
      isValidRowNumber(rowNumber) {
        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
      }
      setRowNumberAsRowIndicatorColumn() {
        this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
      }
      getWidth() {
        return this.endX - this.startX;
      }
      getStartX() {
        return this.startX;
      }
      getEndX() {
        return this.endX;
      }
      getBucket() {
        return this.bucket;
      }
      getValue() {
        return this.value;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      setRowNumber(rowNumber) {
        this.rowNumber = rowNumber;
      }
      toString() {
        return this.rowNumber + "|" + this.value;
      }
    }
    Codeword.BARCODE_ROW_UNKNOWN = -1;
    class PDF417CodewordDecoder {
      static initialize() {
        for (let i2 = 0; i2 < PDF417Common.SYMBOL_TABLE.length; i2++) {
          let currentSymbol = PDF417Common.SYMBOL_TABLE[i2];
          let currentBit = currentSymbol & 1;
          for (let j = 0; j < PDF417Common.BARS_IN_MODULE; j++) {
            let size2 = 0;
            while ((currentSymbol & 1) === currentBit) {
              size2 += 1;
              currentSymbol >>= 1;
            }
            currentBit = currentSymbol & 1;
            if (!PDF417CodewordDecoder.RATIOS_TABLE[i2]) {
              PDF417CodewordDecoder.RATIOS_TABLE[i2] = new Array(PDF417Common.BARS_IN_MODULE);
            }
            PDF417CodewordDecoder.RATIOS_TABLE[i2][PDF417Common.BARS_IN_MODULE - j - 1] = Math.fround(size2 / PDF417Common.MODULES_IN_CODEWORD);
          }
        }
        this.bSymbolTableReady = true;
      }
      static getDecodedValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
        if (decodedValue !== -1) {
          return decodedValue;
        }
        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
      }
      static sampleBitCounts(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
        let bitCountIndex = 0;
        let sumPreviousBits = 0;
        for (let i2 = 0; i2 < PDF417Common.MODULES_IN_CODEWORD; i2++) {
          let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i2 * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;
          if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
            sumPreviousBits += moduleBitCount[bitCountIndex];
            bitCountIndex++;
          }
          result[bitCountIndex]++;
        }
        return result;
      }
      static getDecodedCodewordValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
        return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
      }
      static getBitValue(moduleBitCount) {
        let result = 0;
        for (let i2 = 0; i2 < moduleBitCount.length; i2++) {
          for (let bit = 0; bit < moduleBitCount[i2]; bit++) {
            result = result << 1 | (i2 % 2 === 0 ? 1 : 0);
          }
        }
        return Math.trunc(result);
      }
      static getClosestDecodedValue(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
        if (bitCountSum > 1) {
          for (let i2 = 0; i2 < bitCountRatios.length; i2++) {
            bitCountRatios[i2] = Math.fround(moduleBitCount[i2] / bitCountSum);
          }
        }
        let bestMatchError = Float.MAX_VALUE;
        let bestMatch = -1;
        if (!this.bSymbolTableReady) {
          PDF417CodewordDecoder.initialize();
        }
        for (let j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {
          let error = 0;
          let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];
          for (let k = 0; k < PDF417Common.BARS_IN_MODULE; k++) {
            let diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
            error += Math.fround(diff * diff);
            if (error >= bestMatchError) {
              break;
            }
          }
          if (error < bestMatchError) {
            bestMatchError = error;
            bestMatch = PDF417Common.SYMBOL_TABLE[j];
          }
        }
        return bestMatch;
      }
    }
    PDF417CodewordDecoder.bSymbolTableReady = false;
    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x) => new Array(PDF417Common.BARS_IN_MODULE));
    class PDF417ResultMetadata {
      constructor() {
        this.segmentCount = -1;
        this.fileSize = -1;
        this.timestamp = -1;
        this.checksum = -1;
      }
      getSegmentIndex() {
        return this.segmentIndex;
      }
      setSegmentIndex(segmentIndex) {
        this.segmentIndex = segmentIndex;
      }
      getFileId() {
        return this.fileId;
      }
      setFileId(fileId) {
        this.fileId = fileId;
      }
      getOptionalData() {
        return this.optionalData;
      }
      setOptionalData(optionalData) {
        this.optionalData = optionalData;
      }
      isLastSegment() {
        return this.lastSegment;
      }
      setLastSegment(lastSegment) {
        this.lastSegment = lastSegment;
      }
      getSegmentCount() {
        return this.segmentCount;
      }
      setSegmentCount(segmentCount) {
        this.segmentCount = segmentCount;
      }
      getSender() {
        return this.sender || null;
      }
      setSender(sender) {
        this.sender = sender;
      }
      getAddressee() {
        return this.addressee || null;
      }
      setAddressee(addressee) {
        this.addressee = addressee;
      }
      getFileName() {
        return this.fileName;
      }
      setFileName(fileName) {
        this.fileName = fileName;
      }
      getFileSize() {
        return this.fileSize;
      }
      setFileSize(fileSize) {
        this.fileSize = fileSize;
      }
      getChecksum() {
        return this.checksum;
      }
      setChecksum(checksum) {
        this.checksum = checksum;
      }
      getTimestamp() {
        return this.timestamp;
      }
      setTimestamp(timestamp) {
        this.timestamp = timestamp;
      }
    }
    class Long {
      static parseLong(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    class NullPointerException extends Exception {
    }
    NullPointerException.kind = "NullPointerException";
    class OutputStream {
      writeBytes(b) {
        this.writeBytesOffset(b, 0, b.length);
      }
      writeBytesOffset(b, off, len) {
        if (b == null) {
          throw new NullPointerException();
        } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
          throw new IndexOutOfBoundsException();
        } else if (len === 0) {
          return;
        }
        for (let i2 = 0; i2 < len; i2++) {
          this.write(b[off + i2]);
        }
      }
      flush() {
      }
      close() {
      }
    }
    class OutOfMemoryError extends Exception {
    }
    class ByteArrayOutputStream extends OutputStream {
      constructor(size2 = 32) {
        super();
        this.count = 0;
        if (size2 < 0) {
          throw new IllegalArgumentException("Negative initial size: " + size2);
        }
        this.buf = new Uint8Array(size2);
      }
      ensureCapacity(minCapacity) {
        if (minCapacity - this.buf.length > 0)
          this.grow(minCapacity);
      }
      grow(minCapacity) {
        let oldCapacity = this.buf.length;
        let newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0)
          newCapacity = minCapacity;
        if (newCapacity < 0) {
          if (minCapacity < 0)
            throw new OutOfMemoryError();
          newCapacity = Integer.MAX_VALUE;
        }
        this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
      }
      write(b) {
        this.ensureCapacity(this.count + 1);
        this.buf[this.count] = b;
        this.count += 1;
      }
      writeBytesOffset(b, off, len) {
        if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {
          throw new IndexOutOfBoundsException();
        }
        this.ensureCapacity(this.count + len);
        System.arraycopy(b, off, this.buf, this.count, len);
        this.count += len;
      }
      writeTo(out) {
        out.writeBytesOffset(this.buf, 0, this.count);
      }
      reset() {
        this.count = 0;
      }
      toByteArray() {
        return Arrays.copyOfUint8Array(this.buf, this.count);
      }
      size() {
        return this.count;
      }
      toString(param) {
        if (!param) {
          return this.toString_void();
        }
        if (typeof param === "string") {
          return this.toString_string(param);
        }
        return this.toString_number(param);
      }
      toString_void() {
        return new String(this.buf).toString();
      }
      toString_string(charsetName) {
        return new String(this.buf).toString();
      }
      toString_number(hibyte) {
        return new String(this.buf).toString();
      }
      close() {
      }
    }
    var Mode$2;
    (function(Mode2) {
      Mode2[Mode2["ALPHA"] = 0] = "ALPHA";
      Mode2[Mode2["LOWER"] = 1] = "LOWER";
      Mode2[Mode2["MIXED"] = 2] = "MIXED";
      Mode2[Mode2["PUNCT"] = 3] = "PUNCT";
      Mode2[Mode2["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
      Mode2[Mode2["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
    })(Mode$2 || (Mode$2 = {}));
    function getBigIntConstructor() {
      if (typeof window !== "undefined") {
        return window["BigInt"] || null;
      }
      if (typeof commonjsGlobal !== "undefined") {
        return commonjsGlobal["BigInt"] || null;
      }
      if (typeof self !== "undefined") {
        return self["BigInt"] || null;
      }
      throw new Error("Can't search globals for BigInt!");
    }
    let BigInteger;
    function createBigInt(num) {
      if (typeof BigInteger === "undefined") {
        BigInteger = getBigIntConstructor();
      }
      if (BigInteger === null) {
        throw new Error("BigInt is not supported!");
      }
      return BigInteger(num);
    }
    function getEXP900() {
      let EXP900 = [];
      EXP900[0] = createBigInt(1);
      let nineHundred = createBigInt(900);
      EXP900[1] = nineHundred;
      for (let i2 = 2; i2 < 16; i2++) {
        EXP900[i2] = EXP900[i2 - 1] * nineHundred;
      }
      return EXP900;
    }
    class DecodedBitStreamParser$2 {
      static decode(codewords, ecLevel) {
        let result = new StringBuilder("");
        let encoding = CharacterSetECI.ISO8859_1;
        result.enableDecoding(encoding);
        let codeIndex = 1;
        let code = codewords[codeIndex++];
        let resultMetadata = new PDF417ResultMetadata();
        while (codeIndex < codewords[0]) {
          switch (code) {
            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              result.append(codewords[codeIndex++]);
              break;
            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.ECI_CHARSET:
              CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
              break;
            case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
              codeIndex += 2;
              break;
            case DecodedBitStreamParser$2.ECI_USER_DEFINED:
              codeIndex++;
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              throw new FormatException();
            default:
              codeIndex--;
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
          }
          if (codeIndex < codewords.length) {
            code = codewords[codeIndex++];
          } else {
            throw FormatException.getFormatInstance();
          }
        }
        if (result.length() === 0) {
          throw FormatException.getFormatInstance();
        }
        let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
      }
      static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
        if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
          throw FormatException.getFormatInstance();
        }
        let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
        for (let i2 = 0; i2 < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i2++, codeIndex++) {
          segmentIndexArray[i2] = codewords[codeIndex];
        }
        resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
        let fileId = new StringBuilder();
        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
        resultMetadata.setFileId(fileId.toString());
        let optionalFieldsStart = -1;
        if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
          optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
          switch (codewords[codeIndex]) {
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              codeIndex++;
              switch (codewords[codeIndex]) {
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  let fileName = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                  resultMetadata.setFileName(fileName.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  let sender = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                  resultMetadata.setSender(sender.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  let addressee = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                  resultMetadata.setAddressee(addressee.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  let segmentCount = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                  resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  let timestamp = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                  resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  let checksum = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                  resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  let fileSize = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                  resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                  break;
                default:
                  throw FormatException.getFormatInstance();
              }
              break;
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              codeIndex++;
              resultMetadata.setLastSegment(true);
              break;
            default:
              throw FormatException.getFormatInstance();
          }
        }
        if (optionalFieldsStart !== -1) {
          let optionalFieldsLength = codeIndex - optionalFieldsStart;
          if (resultMetadata.isLastSegment()) {
            optionalFieldsLength--;
          }
          resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
        }
        return codeIndex;
      }
      static textCompaction(codewords, codeIndex, result) {
        let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let index = 0;
        let end = false;
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            textCompactionData[index] = code / 30;
            textCompactionData[index + 1] = code % 30;
            index += 2;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                textCompactionData[index++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                break;
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
              case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                textCompactionData[index] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                code = codewords[codeIndex++];
                byteCompactionData[index] = code;
                index++;
                break;
            }
          }
        }
        DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
        return codeIndex;
      }
      static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {
        let subMode = Mode$2.ALPHA;
        let priorToShiftMode = Mode$2.ALPHA;
        let i2 = 0;
        while (i2 < length) {
          let subModeCh = textCompactionData[i2];
          let ch = "";
          switch (subMode) {
            case Mode$2.ALPHA:
              if (subModeCh < 26) {
                ch = String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(byteCompactionData[i2]);
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.LOWER:
              if (subModeCh < 26) {
                ch = String.fromCharCode(97 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.AS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.ALPHA_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(byteCompactionData[i2]);
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.MIXED:
              if (subModeCh < DecodedBitStreamParser$2.PL) {
                ch = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PL:
                    subMode = Mode$2.PUNCT;
                    break;
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.AL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(byteCompactionData[i2]);
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT:
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(byteCompactionData[i2]);
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.ALPHA_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < 26) {
                ch = String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch = " ";
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(byteCompactionData[i2]);
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
          }
          if (ch !== "") {
            result.append(ch);
          }
          i2++;
        }
      }
      static byteCompaction(mode, codewords, encoding, codeIndex, result) {
        let decodedBytes = new ByteArrayOutputStream();
        let count = 0;
        let value = 0;
        let end = false;
        switch (mode) {
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            let byteCompactedCodewords = new Int32Array(6);
            let nextCode = codewords[codeIndex++];
            while (codeIndex < codewords[0] && !end) {
              byteCompactedCodewords[count++] = nextCode;
              value = 900 * value + nextCode;
              nextCode = codewords[codeIndex++];
              switch (nextCode) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end = true;
                  break;
                default:
                  if (count % 5 === 0 && count > 0) {
                    for (let j = 0; j < 6; ++j) {
                      decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                    }
                    value = 0;
                    count = 0;
                  }
                  break;
              }
            }
            if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
              byteCompactedCodewords[count++] = nextCode;
            }
            for (let i2 = 0; i2 < count; i2++) {
              decodedBytes.write(byteCompactedCodewords[i2]);
            }
            break;
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
            while (codeIndex < codewords[0] && !end) {
              let code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                count++;
                value = 900 * value + code;
              } else {
                switch (code) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                }
              }
              if (count % 5 === 0 && count > 0) {
                for (let j = 0; j < 6; ++j) {
                  decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                }
                value = 0;
                count = 0;
              }
            }
            break;
        }
        result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
        return codeIndex;
      }
      static numericCompaction(codewords, codeIndex, result) {
        let count = 0;
        let end = false;
        let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (codeIndex === codewords[0]) {
            end = true;
          }
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            numericCodewords[count] = code;
            count++;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
            }
          }
          if ((count % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
            result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count));
            count = 0;
          }
        }
        return codeIndex;
      }
      static decodeBase900toBase10(codewords, count) {
        let result = createBigInt(0);
        for (let i2 = 0; i2 < count; i2++) {
          result += DecodedBitStreamParser$2.EXP900[count - i2 - 1] * createBigInt(codewords[i2]);
        }
        let resultString = result.toString();
        if (resultString.charAt(0) !== "1") {
          throw new FormatException();
        }
        return resultString.substring(1);
      }
    }
    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
    DecodedBitStreamParser$2.ECI_CHARSET = 927;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    DecodedBitStreamParser$2.PL = 25;
    DecodedBitStreamParser$2.LL = 27;
    DecodedBitStreamParser$2.AS = 27;
    DecodedBitStreamParser$2.ML = 28;
    DecodedBitStreamParser$2.AL = 28;
    DecodedBitStreamParser$2.PS = 29;
    DecodedBitStreamParser$2.PAL = 29;
    DecodedBitStreamParser$2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
    DecodedBitStreamParser$2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
    class PDF417ScanningDecoder {
      constructor() {
      }
      static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
        let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
        let leftRowIndicatorColumn = null;
        let rightRowIndicatorColumn = null;
        let detectionResult;
        for (let firstPass = true; ; firstPass = false) {
          if (imageTopLeft != null) {
            leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
          }
          if (imageTopRight != null) {
            rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
          }
          detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (detectionResult == null) {
            throw NotFoundException.getNotFoundInstance();
          }
          let resultBox = detectionResult.getBoundingBox();
          if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
            boundingBox = resultBox;
          } else {
            break;
          }
        }
        detectionResult.setBoundingBox(boundingBox);
        let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
        let leftToRight = leftRowIndicatorColumn != null;
        for (let barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
          let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
          if (detectionResult.getDetectionResultColumn(barcodeColumn) !== void 0) {
            continue;
          }
          let detectionResultColumn;
          if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
            detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
          } else {
            detectionResultColumn = new DetectionResultColumn(boundingBox);
          }
          detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
          let startColumn = -1;
          let previousStartColumn = startColumn;
          for (let imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
            startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
            if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
              if (previousStartColumn === -1) {
                continue;
              }
              startColumn = previousStartColumn;
            }
            let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              detectionResultColumn.setCodeword(imageRow, codeword);
              previousStartColumn = startColumn;
              minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
              maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
            }
          }
        }
        return PDF417ScanningDecoder.createDecoderResult(detectionResult);
      }
      static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
          return null;
        }
        let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
        if (barcodeMetadata == null) {
          return null;
        }
        let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
        return new DetectionResult(barcodeMetadata, boundingBox);
      }
      static adjustBoundingBox(rowIndicatorColumn) {
        if (rowIndicatorColumn == null) {
          return null;
        }
        let rowHeights = rowIndicatorColumn.getRowHeights();
        if (rowHeights == null) {
          return null;
        }
        let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
        let missingStartRows = 0;
        for (let rowHeight of rowHeights) {
          missingStartRows += maxRowHeight - rowHeight;
          if (rowHeight > 0) {
            break;
          }
        }
        let codewords = rowIndicatorColumn.getCodewords();
        for (let row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
          missingStartRows--;
        }
        let missingEndRows = 0;
        for (let row = rowHeights.length - 1; row >= 0; row--) {
          missingEndRows += maxRowHeight - rowHeights[row];
          if (rowHeights[row] > 0) {
            break;
          }
        }
        for (let row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
          missingEndRows--;
        }
        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
      }
      static getMax(values) {
        let maxValue = -1;
        for (let value of values) {
          maxValue = Math.max(maxValue, value);
        }
        return maxValue;
      }
      static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        let leftBarcodeMetadata;
        if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
        }
        let rightBarcodeMetadata;
        if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return leftBarcodeMetadata;
        }
        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
          return null;
        }
        return leftBarcodeMetadata;
      }
      static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
        let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
        for (let i2 = 0; i2 < 2; i2++) {
          let increment = i2 === 0 ? 1 : -1;
          let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
          for (let imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
            let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              rowIndicatorColumn.setCodeword(imageRow, codeword);
              if (leftToRight) {
                startColumn = codeword.getStartX();
              } else {
                startColumn = codeword.getEndX();
              }
            }
          }
        }
        return rowIndicatorColumn;
      }
      static adjustCodewordCount(detectionResult, barcodeMatrix) {
        let barcodeMatrix01 = barcodeMatrix[0][1];
        let numberOfCodewords = barcodeMatrix01.getValue();
        let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
        if (numberOfCodewords.length === 0) {
          if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
            throw NotFoundException.getNotFoundInstance();
          }
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
      }
      static createDecoderResult(detectionResult) {
        let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
        let erasures = new Array();
        let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
        let ambiguousIndexValuesList = [];
        let ambiguousIndexesList = new Array();
        for (let row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
          for (let column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
            let values = barcodeMatrix[row][column + 1].getValue();
            let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
            if (values.length === 0) {
              erasures.push(codewordIndex);
            } else if (values.length === 1) {
              codewords[codewordIndex] = values[0];
            } else {
              ambiguousIndexesList.push(codewordIndex);
              ambiguousIndexValuesList.push(values);
            }
          }
        }
        let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
        for (let i2 = 0; i2 < ambiguousIndexValues.length; i2++) {
          ambiguousIndexValues[i2] = ambiguousIndexValuesList[i2];
        }
        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
      }
      static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
        let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
        let tries = 100;
        while (tries-- > 0) {
          for (let i2 = 0; i2 < ambiguousIndexCount.length; i2++) {
            codewords[ambiguousIndexes[i2]] = ambiguousIndexValues[i2][ambiguousIndexCount[i2]];
          }
          try {
            return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
          } catch (err) {
            let ignored = err instanceof ChecksumException;
            if (!ignored) {
              throw err;
            }
          }
          if (ambiguousIndexCount.length === 0) {
            throw ChecksumException.getChecksumInstance();
          }
          for (let i2 = 0; i2 < ambiguousIndexCount.length; i2++) {
            if (ambiguousIndexCount[i2] < ambiguousIndexValues[i2].length - 1) {
              ambiguousIndexCount[i2]++;
              break;
            } else {
              ambiguousIndexCount[i2] = 0;
              if (i2 === ambiguousIndexCount.length - 1) {
                throw ChecksumException.getChecksumInstance();
              }
            }
          }
        }
        throw ChecksumException.getChecksumInstance();
      }
      static createBarcodeMatrix(detectionResult) {
        let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
        for (let row = 0; row < barcodeMatrix.length; row++) {
          for (let column2 = 0; column2 < barcodeMatrix[row].length; column2++) {
            barcodeMatrix[row][column2] = new BarcodeValue();
          }
        }
        let column = 0;
        for (let detectionResultColumn of detectionResult.getDetectionResultColumns()) {
          if (detectionResultColumn != null) {
            for (let codeword of detectionResultColumn.getCodewords()) {
              if (codeword != null) {
                let rowNumber = codeword.getRowNumber();
                if (rowNumber >= 0) {
                  if (rowNumber >= barcodeMatrix.length) {
                    continue;
                  }
                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                }
              }
            }
          }
          column++;
        }
        return barcodeMatrix;
      }
      static isValidBarcodeColumn(detectionResult, barcodeColumn) {
        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
      }
      static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
        let offset = leftToRight ? 1 : -1;
        let codeword = null;
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
        if (codeword != null) {
          return leftToRight ? codeword.getStartX() : codeword.getEndX();
        }
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        let skippedColumns = 0;
        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
          barcodeColumn -= offset;
          for (let previousRowCodeword of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
            if (previousRowCodeword != null) {
              return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
            }
          }
          skippedColumns++;
        }
        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
      }
      static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        if (moduleBitCount == null) {
          return null;
        }
        let endColumn;
        let codewordBitCount = MathUtils.sum(moduleBitCount);
        if (leftToRight) {
          endColumn = startColumn + codewordBitCount;
        } else {
          for (let i2 = 0; i2 < moduleBitCount.length / 2; i2++) {
            let tmpCount = moduleBitCount[i2];
            moduleBitCount[i2] = moduleBitCount[moduleBitCount.length - 1 - i2];
            moduleBitCount[moduleBitCount.length - 1 - i2] = tmpCount;
          }
          endColumn = startColumn;
          startColumn = endColumn - codewordBitCount;
        }
        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
          return null;
        }
        let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
        let codeword = PDF417Common.getCodeword(decodedValue);
        if (codeword === -1) {
          return null;
        }
        return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
      }
      static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
        let imageColumn = startColumn;
        let moduleBitCount = new Int32Array(8);
        let moduleNumber = 0;
        let increment = leftToRight ? 1 : -1;
        let previousPixelValue = leftToRight;
        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
          if (image.get(imageColumn, imageRow) === previousPixelValue) {
            moduleBitCount[moduleNumber]++;
            imageColumn += increment;
          } else {
            moduleNumber++;
            previousPixelValue = !previousPixelValue;
          }
        }
        if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
          return moduleBitCount;
        }
        return null;
      }
      static getNumberOfECCodeWords(barcodeECLevel) {
        return 2 << barcodeECLevel;
      }
      static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
        let correctedStartColumn = codewordStartColumn;
        let increment = leftToRight ? -1 : 1;
        for (let i2 = 0; i2 < 2; i2++) {
          while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
            if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
              return codewordStartColumn;
            }
            correctedStartColumn += increment;
          }
          increment = -increment;
          leftToRight = !leftToRight;
        }
        return correctedStartColumn;
      }
      static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
      }
      static decodeCodewords(codewords, ecLevel, erasures) {
        if (codewords.length === 0) {
          throw FormatException.getFormatInstance();
        }
        let numECCodewords = 1 << ecLevel + 1;
        let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
        let decoderResult = DecodedBitStreamParser$2.decode(codewords, "" + ecLevel);
        decoderResult.setErrorsCorrected(correctedErrorsCount);
        decoderResult.setErasures(erasures.length);
        return decoderResult;
      }
      static correctErrors(codewords, erasures, numECCodewords) {
        if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
          throw ChecksumException.getChecksumInstance();
        }
        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
      }
      static verifyCodewordCount(codewords, numECCodewords) {
        if (codewords.length < 4) {
          throw FormatException.getFormatInstance();
        }
        let numberOfCodewords = codewords[0];
        if (numberOfCodewords > codewords.length) {
          throw FormatException.getFormatInstance();
        }
        if (numberOfCodewords === 0) {
          if (numECCodewords < codewords.length) {
            codewords[0] = codewords.length - numECCodewords;
          } else {
            throw FormatException.getFormatInstance();
          }
        }
      }
      static getBitCountForCodeword(codeword) {
        let result = new Int32Array(8);
        let previousValue = 0;
        let i2 = result.length - 1;
        while (true) {
          if ((codeword & 1) !== previousValue) {
            previousValue = codeword & 1;
            i2--;
            if (i2 < 0) {
              break;
            }
          }
          result[i2]++;
          codeword >>= 1;
        }
        return result;
      }
      static getCodewordBucketNumber(codeword) {
        if (codeword instanceof Int32Array) {
          return this.getCodewordBucketNumber_Int32Array(codeword);
        }
        return this.getCodewordBucketNumber_number(codeword);
      }
      static getCodewordBucketNumber_number(codeword) {
        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
      }
      static getCodewordBucketNumber_Int32Array(moduleBitCount) {
        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
      }
      static toString(barcodeMatrix) {
        let formatter = new Formatter();
        for (let row = 0; row < barcodeMatrix.length; row++) {
          formatter.format("Row %2d: ", row);
          for (let column = 0; column < barcodeMatrix[row].length; column++) {
            let barcodeValue = barcodeMatrix[row][column];
            if (barcodeValue.getValue().length === 0) {
              formatter.format("        ", null);
            } else {
              formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
            }
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
    PDF417ScanningDecoder.MAX_ERRORS = 3;
    PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
    PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
    class PDF417Reader {
      decode(image, hints = null) {
        let result = PDF417Reader.decode(image, hints, false);
        if (result == null || result.length === 0 || result[0] == null) {
          throw NotFoundException.getNotFoundInstance();
        }
        return result[0];
      }
      decodeMultiple(image, hints = null) {
        try {
          return PDF417Reader.decode(image, hints, true);
        } catch (ignored) {
          if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
            throw NotFoundException.getNotFoundInstance();
          }
          throw ignored;
        }
      }
      static decode(image, hints, multiple) {
        const results = new Array();
        const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
        for (const points of detectorResult.getPoints()) {
          const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
          const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.PDF_417);
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
          const pdf417ResultMetadata = decoderResult.getOther();
          if (pdf417ResultMetadata != null) {
            result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
          }
          results.push(result);
        }
        return results.map((x) => x);
      }
      static getMaxWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return 0;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMinWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return Integer.MAX_VALUE;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMaxCodewordWidth(p2) {
        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p2[0], p2[4]), PDF417Reader.getMaxWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p2[1], p2[5]), PDF417Reader.getMaxWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      static getMinCodewordWidth(p2) {
        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p2[0], p2[4]), PDF417Reader.getMinWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p2[1], p2[5]), PDF417Reader.getMinWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      reset() {
      }
    }
    class ReaderException extends Exception {
    }
    ReaderException.kind = "ReaderException";
    class MultiFormatReader {
      constructor(verbose, hints) {
        this.verbose = verbose === true;
        if (hints) {
          this.setHints(hints);
        }
      }
      decode(image, hints) {
        if (hints) {
          this.setHints(hints);
        }
        return this.decodeInternal(image);
      }
      decodeWithState(image) {
        if (this.readers === null || this.readers === void 0) {
          this.setHints(null);
        }
        return this.decodeInternal(image);
      }
      setHints(hints) {
        this.hints = hints;
        const tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.TRY_HARDER);
        const formats = hints === null || hints === void 0 ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const readers = new Array();
        if (formats !== null && formats !== void 0) {
          const addOneDReader = formats.some((f2) => f2 === BarcodeFormat$1.UPC_A || f2 === BarcodeFormat$1.UPC_E || f2 === BarcodeFormat$1.EAN_13 || f2 === BarcodeFormat$1.EAN_8 || f2 === BarcodeFormat$1.CODABAR || f2 === BarcodeFormat$1.CODE_39 || f2 === BarcodeFormat$1.CODE_93 || f2 === BarcodeFormat$1.CODE_128 || f2 === BarcodeFormat$1.ITF || f2 === BarcodeFormat$1.RSS_14 || f2 === BarcodeFormat$1.RSS_EXPANDED);
          if (addOneDReader && !tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          if (formats.includes(BarcodeFormat$1.QR_CODE)) {
            readers.push(new QRCodeReader());
          }
          if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
            readers.push(new DataMatrixReader());
          }
          if (formats.includes(BarcodeFormat$1.AZTEC)) {
            readers.push(new AztecReader());
          }
          if (formats.includes(BarcodeFormat$1.PDF_417)) {
            readers.push(new PDF417Reader());
          }
          if (addOneDReader && tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        if (readers.length === 0) {
          if (!tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          readers.push(new QRCodeReader());
          readers.push(new DataMatrixReader());
          readers.push(new AztecReader());
          readers.push(new PDF417Reader());
          if (tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        this.readers = readers;
      }
      reset() {
        if (this.readers !== null) {
          for (const reader of this.readers) {
            reader.reset();
          }
        }
      }
      decodeInternal(image) {
        if (this.readers === null) {
          throw new ReaderException("No readers where selected, nothing can be read.");
        }
        for (const reader of this.readers) {
          try {
            return reader.decode(image, this.hints);
          } catch (ex) {
            if (ex instanceof ReaderException) {
              continue;
            }
          }
        }
        throw new NotFoundException("No MultiFormat Readers were able to detect the code.");
      }
    }
    class BrowserMultiFormatReader extends BrowserCodeReader {
      constructor(hints = null, timeBetweenScansMillis = 500) {
        const reader = new MultiFormatReader();
        reader.setHints(hints);
        super(reader, timeBetweenScansMillis);
      }
      decodeBitmap(binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
      }
    }
    class BrowserPDF417Reader extends BrowserCodeReader {
      constructor(timeBetweenScansMillis = 500) {
        super(new PDF417Reader(), timeBetweenScansMillis);
      }
    }
    class BrowserQRCodeReader extends BrowserCodeReader {
      constructor(timeBetweenScansMillis = 500) {
        super(new QRCodeReader(), timeBetweenScansMillis);
      }
    }
    var EncodeHintType;
    (function(EncodeHintType2) {
      EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
      EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
      EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
      EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
      EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
      EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
      EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
      EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
      EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
    })(EncodeHintType || (EncodeHintType = {}));
    var EncodeHintType$1 = EncodeHintType;
    class ReedSolomonEncoder {
      constructor(field) {
        this.field = field;
        this.cachedGenerators = [];
        this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
      }
      buildGenerator(degree) {
        const cachedGenerators = this.cachedGenerators;
        if (degree >= cachedGenerators.length) {
          let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
          const field = this.field;
          for (let d = cachedGenerators.length; d <= degree; d++) {
            const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
            cachedGenerators.push(nextGenerator);
            lastGenerator = nextGenerator;
          }
        }
        return cachedGenerators[degree];
      }
      encode(toEncode, ecBytes) {
        if (ecBytes === 0) {
          throw new IllegalArgumentException("No error correction bytes");
        }
        const dataBytes = toEncode.length - ecBytes;
        if (dataBytes <= 0) {
          throw new IllegalArgumentException("No data bytes provided");
        }
        const generator = this.buildGenerator(ecBytes);
        const infoCoefficients = new Int32Array(dataBytes);
        System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
        let info = new GenericGFPoly(this.field, infoCoefficients);
        info = info.multiplyByMonomial(ecBytes, 1);
        const remainder = info.divide(generator)[1];
        const coefficients = remainder.getCoefficients();
        const numZeroCoefficients = ecBytes - coefficients.length;
        for (let i2 = 0; i2 < numZeroCoefficients; i2++) {
          toEncode[dataBytes + i2] = 0;
        }
        System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
      }
    }
    class MaskUtil {
      constructor() {
      }
      static applyMaskPenaltyRule1(matrix) {
        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
      }
      static applyMaskPenaltyRule2(matrix) {
        let penalty = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height - 1; y++) {
          const arrayY = array[y];
          for (let x = 0; x < width - 1; x++) {
            const value = arrayY[x];
            if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
              penalty++;
            }
          }
        }
        return MaskUtil.N2 * penalty;
      }
      static applyMaskPenaltyRule3(matrix) {
        let numPenalties = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const arrayY = array[y];
            if (x + 6 < width && arrayY[x] === 1 && arrayY[x + 1] === 0 && arrayY[x + 2] === 1 && arrayY[x + 3] === 1 && arrayY[x + 4] === 1 && arrayY[x + 5] === 0 && arrayY[x + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
              numPenalties++;
            }
            if (y + 6 < height && array[y][x] === 1 && array[y + 1][x] === 0 && array[y + 2][x] === 1 && array[y + 3][x] === 1 && array[y + 4][x] === 1 && array[y + 5][x] === 0 && array[y + 6][x] === 1 && (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
              numPenalties++;
            }
          }
        }
        return numPenalties * MaskUtil.N3;
      }
      static isWhiteHorizontal(rowArray, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, rowArray.length);
        for (let i2 = from; i2 < to; i2++) {
          if (rowArray[i2] === 1) {
            return false;
          }
        }
        return true;
      }
      static isWhiteVertical(array, col, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, array.length);
        for (let i2 = from; i2 < to; i2++) {
          if (array[i2][col] === 1) {
            return false;
          }
        }
        return true;
      }
      static applyMaskPenaltyRule4(matrix) {
        let numDarkCells = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y = 0; y < height; y++) {
          const arrayY = array[y];
          for (let x = 0; x < width; x++) {
            if (arrayY[x] === 1) {
              numDarkCells++;
            }
          }
        }
        const numTotalCells = matrix.getHeight() * matrix.getWidth();
        const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
        return fivePercentVariances * MaskUtil.N4;
      }
      static getDataMaskBit(maskPattern, x, y) {
        let intermediate;
        let temp;
        switch (maskPattern) {
          case 0:
            intermediate = y + x & 1;
            break;
          case 1:
            intermediate = y & 1;
            break;
          case 2:
            intermediate = x % 3;
            break;
          case 3:
            intermediate = (y + x) % 3;
            break;
          case 4:
            intermediate = Math.floor(y / 2) + Math.floor(x / 3) & 1;
            break;
          case 5:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3;
            break;
          case 6:
            temp = y * x;
            intermediate = (temp & 1) + temp % 3 & 1;
            break;
          case 7:
            temp = y * x;
            intermediate = temp % 3 + (y + x & 1) & 1;
            break;
          default:
            throw new IllegalArgumentException("Invalid mask pattern: " + maskPattern);
        }
        return intermediate === 0;
      }
      static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
        let penalty = 0;
        const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
        const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
        const array = matrix.getArray();
        for (let i2 = 0; i2 < iLimit; i2++) {
          let numSameBitCells = 0;
          let prevBit = -1;
          for (let j = 0; j < jLimit; j++) {
            const bit = isHorizontal ? array[i2][j] : array[j][i2];
            if (bit === prevBit) {
              numSameBitCells++;
            } else {
              if (numSameBitCells >= 5) {
                penalty += MaskUtil.N1 + (numSameBitCells - 5);
              }
              numSameBitCells = 1;
              prevBit = bit;
            }
          }
          if (numSameBitCells >= 5) {
            penalty += MaskUtil.N1 + (numSameBitCells - 5);
          }
        }
        return penalty;
      }
    }
    MaskUtil.N1 = 3;
    MaskUtil.N2 = 3;
    MaskUtil.N3 = 40;
    MaskUtil.N4 = 10;
    class ByteMatrix {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        const bytes = new Array(height);
        for (let i2 = 0; i2 !== height; i2++) {
          bytes[i2] = new Uint8Array(width);
        }
        this.bytes = bytes;
      }
      getHeight() {
        return this.height;
      }
      getWidth() {
        return this.width;
      }
      get(x, y) {
        return this.bytes[y][x];
      }
      getArray() {
        return this.bytes;
      }
      setNumber(x, y, value) {
        this.bytes[y][x] = value;
      }
      setBoolean(x, y, value) {
        this.bytes[y][x] = value ? 1 : 0;
      }
      clear(value) {
        for (const aByte of this.bytes) {
          Arrays.fill(aByte, value);
        }
      }
      equals(o2) {
        if (!(o2 instanceof ByteMatrix)) {
          return false;
        }
        const other = o2;
        if (this.width !== other.width) {
          return false;
        }
        if (this.height !== other.height) {
          return false;
        }
        for (let y = 0, height = this.height; y < height; ++y) {
          const bytesY = this.bytes[y];
          const otherBytesY = other.bytes[y];
          for (let x = 0, width = this.width; x < width; ++x) {
            if (bytesY[x] !== otherBytesY[x]) {
              return false;
            }
          }
        }
        return true;
      }
      toString() {
        const result = new StringBuilder();
        for (let y = 0, height = this.height; y < height; ++y) {
          const bytesY = this.bytes[y];
          for (let x = 0, width = this.width; x < width; ++x) {
            switch (bytesY[x]) {
              case 0:
                result.append(" 0");
                break;
              case 1:
                result.append(" 1");
                break;
              default:
                result.append("  ");
                break;
            }
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class QRCode {
      constructor() {
        this.maskPattern = -1;
      }
      getMode() {
        return this.mode;
      }
      getECLevel() {
        return this.ecLevel;
      }
      getVersion() {
        return this.version;
      }
      getMaskPattern() {
        return this.maskPattern;
      }
      getMatrix() {
        return this.matrix;
      }
      toString() {
        const result = new StringBuilder();
        result.append("<<\n");
        result.append(" mode: ");
        result.append(this.mode ? this.mode.toString() : "null");
        result.append("\n ecLevel: ");
        result.append(this.ecLevel ? this.ecLevel.toString() : "null");
        result.append("\n version: ");
        result.append(this.version ? this.version.toString() : "null");
        result.append("\n maskPattern: ");
        result.append(this.maskPattern.toString());
        if (this.matrix) {
          result.append("\n matrix:\n");
          result.append(this.matrix.toString());
        } else {
          result.append("\n matrix: null\n");
        }
        result.append(">>\n");
        return result.toString();
      }
      setMode(value) {
        this.mode = value;
      }
      setECLevel(value) {
        this.ecLevel = value;
      }
      setVersion(version2) {
        this.version = version2;
      }
      setMaskPattern(value) {
        this.maskPattern = value;
      }
      setMatrix(value) {
        this.matrix = value;
      }
      static isValidMaskPattern(maskPattern) {
        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
      }
    }
    QRCode.NUM_MASK_PATTERNS = 8;
    class WriterException extends Exception {
    }
    WriterException.kind = "WriterException";
    class MatrixUtil {
      constructor() {
      }
      static clearMatrix(matrix) {
        matrix.clear(255);
      }
      static buildMatrix(dataBits, ecLevel, version2, maskPattern, matrix) {
        MatrixUtil.clearMatrix(matrix);
        MatrixUtil.embedBasicPatterns(version2, matrix);
        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
        MatrixUtil.maybeEmbedVersionInfo(version2, matrix);
        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
      }
      static embedBasicPatterns(version2, matrix) {
        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version2, matrix);
        MatrixUtil.embedTimingPatterns(matrix);
      }
      static embedTypeInfo(ecLevel, maskPattern, matrix) {
        const typeInfoBits = new BitArray();
        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
        for (let i2 = 0, size2 = typeInfoBits.getSize(); i2 < size2; ++i2) {
          const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i2);
          const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i2];
          const x1 = coordinates[0];
          const y1 = coordinates[1];
          matrix.setBoolean(x1, y1, bit);
          if (i2 < 8) {
            const x2 = matrix.getWidth() - i2 - 1;
            const y2 = 8;
            matrix.setBoolean(x2, y2, bit);
          } else {
            const x2 = 8;
            const y2 = matrix.getHeight() - 7 + (i2 - 8);
            matrix.setBoolean(x2, y2, bit);
          }
        }
      }
      static maybeEmbedVersionInfo(version2, matrix) {
        if (version2.getVersionNumber() < 7) {
          return;
        }
        const versionInfoBits = new BitArray();
        MatrixUtil.makeVersionInfoBits(version2, versionInfoBits);
        let bitIndex = 6 * 3 - 1;
        for (let i2 = 0; i2 < 6; ++i2) {
          for (let j = 0; j < 3; ++j) {
            const bit = versionInfoBits.get(bitIndex);
            bitIndex--;
            matrix.setBoolean(i2, matrix.getHeight() - 11 + j, bit);
            matrix.setBoolean(matrix.getHeight() - 11 + j, i2, bit);
          }
        }
      }
      static embedDataBits(dataBits, maskPattern, matrix) {
        let bitIndex = 0;
        let direction = -1;
        let x = matrix.getWidth() - 1;
        let y = matrix.getHeight() - 1;
        while (x > 0) {
          if (x === 6) {
            x -= 1;
          }
          while (y >= 0 && y < matrix.getHeight()) {
            for (let i2 = 0; i2 < 2; ++i2) {
              const xx = x - i2;
              if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                continue;
              }
              let bit;
              if (bitIndex < dataBits.getSize()) {
                bit = dataBits.get(bitIndex);
                ++bitIndex;
              } else {
                bit = false;
              }
              if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y)) {
                bit = !bit;
              }
              matrix.setBoolean(xx, y, bit);
            }
            y += direction;
          }
          direction = -direction;
          y += direction;
          x -= 2;
        }
        if (bitIndex !== dataBits.getSize()) {
          throw new WriterException("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
        }
      }
      static findMSBSet(value) {
        return 32 - Integer.numberOfLeadingZeros(value);
      }
      static calculateBCHCode(value, poly) {
        if (poly === 0) {
          throw new IllegalArgumentException("0 polynomial");
        }
        const msbSetInPoly = MatrixUtil.findMSBSet(poly);
        value <<= msbSetInPoly - 1;
        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
          value ^= poly << MatrixUtil.findMSBSet(value) - msbSetInPoly;
        }
        return value;
      }
      static makeTypeInfoBits(ecLevel, maskPattern, bits) {
        if (!QRCode.isValidMaskPattern(maskPattern)) {
          throw new WriterException("Invalid mask pattern");
        }
        const typeInfo = ecLevel.getBits() << 3 | maskPattern;
        bits.appendBits(typeInfo, 5);
        const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
        bits.appendBits(bchCode, 10);
        const maskBits = new BitArray();
        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
        bits.xor(maskBits);
        if (bits.getSize() !== 15) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      static makeVersionInfoBits(version2, bits) {
        bits.appendBits(version2.getVersionNumber(), 6);
        const bchCode = MatrixUtil.calculateBCHCode(version2.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
        bits.appendBits(bchCode, 12);
        if (bits.getSize() !== 18) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      static isEmpty(value) {
        return value === 255;
      }
      static embedTimingPatterns(matrix) {
        for (let i2 = 8; i2 < matrix.getWidth() - 8; ++i2) {
          const bit = (i2 + 1) % 2;
          if (MatrixUtil.isEmpty(matrix.get(i2, 6))) {
            matrix.setNumber(i2, 6, bit);
          }
          if (MatrixUtil.isEmpty(matrix.get(6, i2))) {
            matrix.setNumber(6, i2, bit);
          }
        }
      }
      static embedDarkDotAtLeftBottomCorner(matrix) {
        if (matrix.get(8, matrix.getHeight() - 8) === 0) {
          throw new WriterException();
        }
        matrix.setNumber(8, matrix.getHeight() - 8, 1);
      }
      static embedHorizontalSeparationPattern(xStart, yStart, matrix) {
        for (let x = 0; x < 8; ++x) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart + x, yStart, 0);
        }
      }
      static embedVerticalSeparationPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 7; ++y) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart, yStart + y, 0);
        }
      }
      static embedPositionAdjustmentPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 5; ++y) {
          const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
          for (let x = 0; x < 5; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      }
      static embedPositionDetectionPattern(xStart, yStart, matrix) {
        for (let y = 0; y < 7; ++y) {
          const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
          for (let x = 0; x < 7; ++x) {
            matrix.setNumber(xStart + x, yStart + y, patternY[x]);
          }
        }
      }
      static embedPositionDetectionPatternsAndSeparators(matrix) {
        const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
        const hspWidth = 8;
        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
        const vspSize = 7;
        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
      }
      static maybeEmbedPositionAdjustmentPatterns(version2, matrix) {
        if (version2.getVersionNumber() < 2) {
          return;
        }
        const index = version2.getVersionNumber() - 1;
        const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
        for (let i2 = 0, length = coordinates.length; i2 !== length; i2++) {
          const y = coordinates[i2];
          if (y >= 0) {
            for (let j = 0; j !== length; j++) {
              const x = coordinates[j];
              if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
              }
            }
          }
        }
      }
    }
    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
      Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
      Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
      Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
      Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
      Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
      Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
      Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
      Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
      Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
      Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
      Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
      Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
      Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
      Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
      Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
      Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
      Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
      Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
      Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
      Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
      Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
      Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
      Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
      Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
      Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
      Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
      Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
      Int32Array.from([6, 30, 58, 86, 114, 142, 170])
    ]);
    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
      Int32Array.from([8, 0]),
      Int32Array.from([8, 1]),
      Int32Array.from([8, 2]),
      Int32Array.from([8, 3]),
      Int32Array.from([8, 4]),
      Int32Array.from([8, 5]),
      Int32Array.from([8, 7]),
      Int32Array.from([8, 8]),
      Int32Array.from([7, 8]),
      Int32Array.from([5, 8]),
      Int32Array.from([4, 8]),
      Int32Array.from([3, 8]),
      Int32Array.from([2, 8]),
      Int32Array.from([1, 8]),
      Int32Array.from([0, 8])
    ]);
    MatrixUtil.VERSION_INFO_POLY = 7973;
    MatrixUtil.TYPE_INFO_POLY = 1335;
    MatrixUtil.TYPE_INFO_MASK_PATTERN = 21522;
    class BlockPair {
      constructor(dataBytes, errorCorrectionBytes) {
        this.dataBytes = dataBytes;
        this.errorCorrectionBytes = errorCorrectionBytes;
      }
      getDataBytes() {
        return this.dataBytes;
      }
      getErrorCorrectionBytes() {
        return this.errorCorrectionBytes;
      }
    }
    class Encoder {
      constructor() {
      }
      static calculateMaskPenalty(matrix) {
        return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);
      }
      static encode(content, ecLevel, hints = null) {
        let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
        const hasEncodingHint = hints !== null && void 0 !== hints.get(EncodeHintType$1.CHARACTER_SET);
        if (hasEncodingHint) {
          encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
        }
        const mode = this.chooseMode(content, encoding);
        const headerBits = new BitArray();
        if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
          const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
          if (eci !== void 0) {
            this.appendECI(eci, headerBits);
          }
        }
        this.appendModeInfo(mode, headerBits);
        const dataBits = new BitArray();
        this.appendBytes(content, mode, dataBits, encoding);
        let version2;
        if (hints !== null && void 0 !== hints.get(EncodeHintType$1.QR_VERSION)) {
          const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
          version2 = Version$1.getVersionForNumber(versionNumber);
          const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version2);
          if (!this.willFit(bitsNeeded, version2, ecLevel)) {
            throw new WriterException("Data too big for requested version");
          }
        } else {
          version2 = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
        }
        const headerAndDataBits = new BitArray();
        headerAndDataBits.appendBitArray(headerBits);
        const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
        this.appendLengthInfo(numLetters, version2, mode, headerAndDataBits);
        headerAndDataBits.appendBitArray(dataBits);
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        const numDataBytes = version2.getTotalCodewords() - ecBlocks.getTotalECCodewords();
        this.terminateBits(numDataBytes, headerAndDataBits);
        const finalBits = this.interleaveWithECBytes(headerAndDataBits, version2.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
        const qrCode = new QRCode();
        qrCode.setECLevel(ecLevel);
        qrCode.setMode(mode);
        qrCode.setVersion(version2);
        const dimension = version2.getDimensionForVersion();
        const matrix = new ByteMatrix(dimension, dimension);
        const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version2, matrix);
        qrCode.setMaskPattern(maskPattern);
        MatrixUtil.buildMatrix(finalBits, ecLevel, version2, maskPattern, matrix);
        qrCode.setMatrix(matrix);
        return qrCode;
      }
      static recommendVersion(ecLevel, mode, headerBits, dataBits) {
        const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
        const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
        const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
        return this.chooseVersion(bitsNeeded, ecLevel);
      }
      static calculateBitsNeeded(mode, headerBits, dataBits, version2) {
        return headerBits.getSize() + mode.getCharacterCountBits(version2) + dataBits.getSize();
      }
      static getAlphanumericCode(code) {
        if (code < Encoder.ALPHANUMERIC_TABLE.length) {
          return Encoder.ALPHANUMERIC_TABLE[code];
        }
        return -1;
      }
      static chooseMode(content, encoding = null) {
        if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
          return Mode$1.KANJI;
        }
        let hasNumeric = false;
        let hasAlphanumeric = false;
        for (let i2 = 0, length = content.length; i2 < length; ++i2) {
          const c2 = content.charAt(i2);
          if (Encoder.isDigit(c2)) {
            hasNumeric = true;
          } else if (this.getAlphanumericCode(c2.charCodeAt(0)) !== -1) {
            hasAlphanumeric = true;
          } else {
            return Mode$1.BYTE;
          }
        }
        if (hasAlphanumeric) {
          return Mode$1.ALPHANUMERIC;
        }
        if (hasNumeric) {
          return Mode$1.NUMERIC;
        }
        return Mode$1.BYTE;
      }
      static isOnlyDoubleByteKanji(content) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (ignored) {
          return false;
        }
        const length = bytes.length;
        if (length % 2 !== 0) {
          return false;
        }
        for (let i2 = 0; i2 < length; i2 += 2) {
          const byte1 = bytes[i2] & 255;
          if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
            return false;
          }
        }
        return true;
      }
      static chooseMaskPattern(bits, ecLevel, version2, matrix) {
        let minPenalty = Number.MAX_SAFE_INTEGER;
        let bestMaskPattern = -1;
        for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
          MatrixUtil.buildMatrix(bits, ecLevel, version2, maskPattern, matrix);
          let penalty = this.calculateMaskPenalty(matrix);
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestMaskPattern = maskPattern;
          }
        }
        return bestMaskPattern;
      }
      static chooseVersion(numInputBits, ecLevel) {
        for (let versionNum = 1; versionNum <= 40; versionNum++) {
          const version2 = Version$1.getVersionForNumber(versionNum);
          if (Encoder.willFit(numInputBits, version2, ecLevel)) {
            return version2;
          }
        }
        throw new WriterException("Data too big");
      }
      static willFit(numInputBits, version2, ecLevel) {
        const numBytes = version2.getTotalCodewords();
        const ecBlocks = version2.getECBlocksForLevel(ecLevel);
        const numEcBytes = ecBlocks.getTotalECCodewords();
        const numDataBytes = numBytes - numEcBytes;
        const totalInputBytes = (numInputBits + 7) / 8;
        return numDataBytes >= totalInputBytes;
      }
      static terminateBits(numDataBytes, bits) {
        const capacity = numDataBytes * 8;
        if (bits.getSize() > capacity) {
          throw new WriterException("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
        }
        for (let i2 = 0; i2 < 4 && bits.getSize() < capacity; ++i2) {
          bits.appendBit(false);
        }
        const numBitsInLastByte = bits.getSize() & 7;
        if (numBitsInLastByte > 0) {
          for (let i2 = numBitsInLastByte; i2 < 8; i2++) {
            bits.appendBit(false);
          }
        }
        const numPaddingBytes = numDataBytes - bits.getSizeInBytes();
        for (let i2 = 0; i2 < numPaddingBytes; ++i2) {
          bits.appendBits((i2 & 1) === 0 ? 236 : 17, 8);
        }
        if (bits.getSize() !== capacity) {
          throw new WriterException("Bits size does not equal capacity");
        }
      }
      static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
        if (blockID >= numRSBlocks) {
          throw new WriterException("Block ID too large");
        }
        const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
        const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
        const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
        const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
        const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
        const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
        const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
        const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
          throw new WriterException("EC bytes mismatch");
        }
        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
          throw new WriterException("RS blocks mismatch");
        }
        if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
          throw new WriterException("Total bytes mismatch");
        }
        if (blockID < numRsBlocksInGroup1) {
          numDataBytesInBlock[0] = numDataBytesInGroup1;
          numECBytesInBlock[0] = numEcBytesInGroup1;
        } else {
          numDataBytesInBlock[0] = numDataBytesInGroup2;
          numECBytesInBlock[0] = numEcBytesInGroup2;
        }
      }
      static interleaveWithECBytes(bits, numTotalBytes, numDataBytes, numRSBlocks) {
        if (bits.getSizeInBytes() !== numDataBytes) {
          throw new WriterException("Number of bits and data bytes does not match");
        }
        let dataBytesOffset = 0;
        let maxNumDataBytes = 0;
        let maxNumEcBytes = 0;
        const blocks = new Array();
        for (let i2 = 0; i2 < numRSBlocks; ++i2) {
          const numDataBytesInBlock = new Int32Array(1);
          const numEcBytesInBlock = new Int32Array(1);
          Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i2, numDataBytesInBlock, numEcBytesInBlock);
          const size2 = numDataBytesInBlock[0];
          const dataBytes = new Uint8Array(size2);
          bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size2);
          const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
          blocks.push(new BlockPair(dataBytes, ecBytes));
          maxNumDataBytes = Math.max(maxNumDataBytes, size2);
          maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
          dataBytesOffset += numDataBytesInBlock[0];
        }
        if (numDataBytes !== dataBytesOffset) {
          throw new WriterException("Data bytes does not match offset");
        }
        const result = new BitArray();
        for (let i2 = 0; i2 < maxNumDataBytes; ++i2) {
          for (const block of blocks) {
            const dataBytes = block.getDataBytes();
            if (i2 < dataBytes.length) {
              result.appendBits(dataBytes[i2], 8);
            }
          }
        }
        for (let i2 = 0; i2 < maxNumEcBytes; ++i2) {
          for (const block of blocks) {
            const ecBytes = block.getErrorCorrectionBytes();
            if (i2 < ecBytes.length) {
              result.appendBits(ecBytes[i2], 8);
            }
          }
        }
        if (numTotalBytes !== result.getSizeInBytes()) {
          throw new WriterException("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
        }
        return result;
      }
      static generateECBytes(dataBytes, numEcBytesInBlock) {
        const numDataBytes = dataBytes.length;
        const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
        for (let i2 = 0; i2 < numDataBytes; i2++) {
          toEncode[i2] = dataBytes[i2] & 255;
        }
        new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
        const ecBytes = new Uint8Array(numEcBytesInBlock);
        for (let i2 = 0; i2 < numEcBytesInBlock; i2++) {
          ecBytes[i2] = toEncode[numDataBytes + i2];
        }
        return ecBytes;
      }
      static appendModeInfo(mode, bits) {
        bits.appendBits(mode.getBits(), 4);
      }
      static appendLengthInfo(numLetters, version2, mode, bits) {
        const numBits = mode.getCharacterCountBits(version2);
        if (numLetters >= 1 << numBits) {
          throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
        }
        bits.appendBits(numLetters, numBits);
      }
      static appendBytes(content, mode, bits, encoding) {
        switch (mode) {
          case Mode$1.NUMERIC:
            Encoder.appendNumericBytes(content, bits);
            break;
          case Mode$1.ALPHANUMERIC:
            Encoder.appendAlphanumericBytes(content, bits);
            break;
          case Mode$1.BYTE:
            Encoder.append8BitBytes(content, bits, encoding);
            break;
          case Mode$1.KANJI:
            Encoder.appendKanjiBytes(content, bits);
            break;
          default:
            throw new WriterException("Invalid mode: " + mode);
        }
      }
      static getDigit(singleCharacter) {
        return singleCharacter.charCodeAt(0) - 48;
      }
      static isDigit(singleCharacter) {
        const cn = Encoder.getDigit(singleCharacter);
        return cn >= 0 && cn <= 9;
      }
      static appendNumericBytes(content, bits) {
        const length = content.length;
        let i2 = 0;
        while (i2 < length) {
          const num1 = Encoder.getDigit(content.charAt(i2));
          if (i2 + 2 < length) {
            const num2 = Encoder.getDigit(content.charAt(i2 + 1));
            const num3 = Encoder.getDigit(content.charAt(i2 + 2));
            bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
            i2 += 3;
          } else if (i2 + 1 < length) {
            const num2 = Encoder.getDigit(content.charAt(i2 + 1));
            bits.appendBits(num1 * 10 + num2, 7);
            i2 += 2;
          } else {
            bits.appendBits(num1, 4);
            i2++;
          }
        }
      }
      static appendAlphanumericBytes(content, bits) {
        const length = content.length;
        let i2 = 0;
        while (i2 < length) {
          const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i2));
          if (code1 === -1) {
            throw new WriterException();
          }
          if (i2 + 1 < length) {
            const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i2 + 1));
            if (code2 === -1) {
              throw new WriterException();
            }
            bits.appendBits(code1 * 45 + code2, 11);
            i2 += 2;
          } else {
            bits.appendBits(code1, 6);
            i2++;
          }
        }
      }
      static append8BitBytes(content, bits, encoding) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, encoding);
        } catch (uee) {
          throw new WriterException(uee);
        }
        for (let i2 = 0, length = bytes.length; i2 !== length; i2++) {
          const b = bytes[i2];
          bits.appendBits(b, 8);
        }
      }
      static appendKanjiBytes(content, bits) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (uee) {
          throw new WriterException(uee);
        }
        const length = bytes.length;
        for (let i2 = 0; i2 < length; i2 += 2) {
          const byte1 = bytes[i2] & 255;
          const byte2 = bytes[i2 + 1] & 255;
          const code = byte1 << 8 & 4294967295 | byte2;
          let subtracted = -1;
          if (code >= 33088 && code <= 40956) {
            subtracted = code - 33088;
          } else if (code >= 57408 && code <= 60351) {
            subtracted = code - 49472;
          }
          if (subtracted === -1) {
            throw new WriterException("Invalid byte sequence");
          }
          const encoded = (subtracted >> 8) * 192 + (subtracted & 255);
          bits.appendBits(encoded, 13);
        }
      }
      static appendECI(eci, bits) {
        bits.appendBits(Mode$1.ECI.getBits(), 4);
        bits.appendBits(eci.getValue(), 8);
      }
    }
    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      36,
      -1,
      -1,
      -1,
      37,
      38,
      -1,
      -1,
      -1,
      -1,
      39,
      40,
      -1,
      41,
      42,
      43,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      44,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      -1,
      -1,
      -1,
      -1,
      -1
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName();
    class BrowserQRCodeSvgWriter {
      write(contents, width, height, hints = null) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
      }
      writeToDom(containerElement, contents, width, height, hints = null) {
        if (typeof containerElement === "string") {
          containerElement = document.querySelector(containerElement);
        }
        const svgElement = this.write(contents, width, height, hints);
        if (containerElement)
          containerElement.appendChild(svgElement);
      }
      renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      }
      createSVGElement(w, h2) {
        const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "svg");
        svgElement.setAttributeNS(null, "height", w.toString());
        svgElement.setAttributeNS(null, "width", h2.toString());
        return svgElement;
      }
      createSvgRectElement(x, y, w, h2) {
        const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "rect");
        rect.setAttributeNS(null, "x", x.toString());
        rect.setAttributeNS(null, "y", y.toString());
        rect.setAttributeNS(null, "height", w.toString());
        rect.setAttributeNS(null, "width", h2.toString());
        rect.setAttributeNS(null, "fill", "#000000");
        return rect;
      }
    }
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
    BrowserQRCodeSvgWriter.SVG_NS = "http://www.w3.org/2000/svg";
    class QRCodeWriter {
      encode(contents, format, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (format !== BarcodeFormat$1.QR_CODE) {
          throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format);
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return QRCodeWriter.renderResult(code, width, height, quietZone);
      }
      static renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const output = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      }
    }
    QRCodeWriter.QUIET_ZONE_SIZE = 4;
    class MultiFormatWriter {
      encode(contents, format, width, height, hints) {
        let writer;
        switch (format) {
          case BarcodeFormat$1.QR_CODE:
            writer = new QRCodeWriter();
            break;
          default:
            throw new IllegalArgumentException("No encoder available for format " + format);
        }
        return writer.encode(contents, format, width, height, hints);
      }
    }
    class PlanarYUVLuminanceSource extends LuminanceSource {
      constructor(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
        super(width, height);
        this.yuvData = yuvData;
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (left + width > dataWidth || top + height > dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
        if (reverseHorizontal) {
          this.reverseHorizontal(width, height);
        }
      }
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset = (y + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.yuvData, offset, row, 0, width);
        return row;
      }
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.yuvData;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      isCropSupported() {
        return true;
      }
      crop(left, top, width, height) {
        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
      }
      renderThumbnail() {
        const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const pixels = new Int32Array(width * height);
        const yuv = this.yuvData;
        let inputOffset = this.top * this.dataWidth + this.left;
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          for (let x = 0; x < width; x++) {
            const grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 255;
            pixels[outputOffset + x] = 4278190080 | grey * 65793;
          }
          inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        return pixels;
      }
      getThumbnailWidth() {
        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      getThumbnailHeight() {
        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      reverseHorizontal(width, height) {
        const yuvData = this.yuvData;
        for (let y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
          const middle = rowStart + width / 2;
          for (let x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
            const temp = yuvData[x1];
            yuvData[x1] = yuvData[x2];
            yuvData[x2] = temp;
          }
        }
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
    class RGBLuminanceSource extends LuminanceSource {
      constructor(luminances, width, height, dataWidth, dataHeight, left, top) {
        super(width, height);
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (luminances.BYTES_PER_ELEMENT === 4) {
          const size2 = width * height;
          const luminancesUint8Array = new Uint8ClampedArray(size2);
          for (let offset = 0; offset < size2; offset++) {
            const pixel = luminances[offset];
            const r2 = pixel >> 16 & 255;
            const g2 = pixel >> 7 & 510;
            const b = pixel & 255;
            luminancesUint8Array[offset] = (r2 + g2 + b) / 4 & 255;
          }
          this.luminances = luminancesUint8Array;
        } else {
          this.luminances = luminances;
        }
        if (void 0 === dataWidth) {
          this.dataWidth = width;
        }
        if (void 0 === dataHeight) {
          this.dataHeight = height;
        }
        if (void 0 === left) {
          this.left = 0;
        }
        if (void 0 === top) {
          this.top = 0;
        }
        if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
      }
      getRow(y, row) {
        if (y < 0 || y >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset = (y + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.luminances, offset, row, 0, width);
        return row;
      }
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.luminances;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y = 0; y < height; y++) {
          const outputOffset = y * width;
          System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      isCropSupported() {
        return true;
      }
      crop(left, top, width, height) {
        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    class Charset extends CharacterSetECI {
      static forName(name) {
        return this.getCharacterSetECIByName(name);
      }
    }
    class StandardCharsets {
    }
    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
    class AztecCode {
      isCompact() {
        return this.compact;
      }
      setCompact(compact) {
        this.compact = compact;
      }
      getSize() {
        return this.size;
      }
      setSize(size2) {
        this.size = size2;
      }
      getLayers() {
        return this.layers;
      }
      setLayers(layers) {
        this.layers = layers;
      }
      getCodeWords() {
        return this.codeWords;
      }
      setCodeWords(codeWords) {
        this.codeWords = codeWords;
      }
      getMatrix() {
        return this.matrix;
      }
      setMatrix(matrix) {
        this.matrix = matrix;
      }
    }
    class Collections {
      static singletonList(item) {
        return [item];
      }
      static min(collection, comparator2) {
        return collection.sort(comparator2)[0];
      }
    }
    class Token {
      constructor(previous) {
        this.previous = previous;
      }
      getPrevious() {
        return this.previous;
      }
    }
    class SimpleToken extends Token {
      constructor(previous, value, bitCount) {
        super(previous);
        this.value = value;
        this.bitCount = bitCount;
      }
      appendTo(bitArray, text) {
        bitArray.appendBits(this.value, this.bitCount);
      }
      add(value, bitCount) {
        return new SimpleToken(this, value, bitCount);
      }
      addBinaryShift(start, byteCount) {
        console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
        return new SimpleToken(this, start, byteCount);
      }
      toString() {
        let value = this.value & (1 << this.bitCount) - 1;
        value |= 1 << this.bitCount;
        return "<" + Integer.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
      }
    }
    class BinaryShiftToken extends SimpleToken {
      constructor(previous, binaryShiftStart, binaryShiftByteCount) {
        super(previous, 0, 0);
        this.binaryShiftStart = binaryShiftStart;
        this.binaryShiftByteCount = binaryShiftByteCount;
      }
      appendTo(bitArray, text) {
        for (let i2 = 0; i2 < this.binaryShiftByteCount; i2++) {
          if (i2 === 0 || i2 === 31 && this.binaryShiftByteCount <= 62) {
            bitArray.appendBits(31, 5);
            if (this.binaryShiftByteCount > 62) {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
            } else if (i2 === 0) {
              bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
            } else {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
            }
          }
          bitArray.appendBits(text[this.binaryShiftStart + i2], 8);
        }
      }
      addBinaryShift(start, byteCount) {
        return new BinaryShiftToken(this, start, byteCount);
      }
      toString() {
        return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
      }
    }
    function addBinaryShift(token, start, byteCount) {
      return new BinaryShiftToken(token, start, byteCount);
    }
    function add2(token, value, bitCount) {
      return new SimpleToken(token, value, bitCount);
    }
    const MODE_NAMES = [
      "UPPER",
      "LOWER",
      "DIGIT",
      "MIXED",
      "PUNCT"
    ];
    const MODE_UPPER = 0;
    const MODE_LOWER = 1;
    const MODE_DIGIT = 2;
    const MODE_MIXED = 3;
    const MODE_PUNCT = 4;
    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);
    const LATCH_TABLE = [
      Int32Array.from([
        0,
        (5 << 16) + 28,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
      ]),
      Int32Array.from([
        (9 << 16) + (30 << 4) + 14,
        0,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
      ]),
      Int32Array.from([
        (4 << 16) + 14,
        (9 << 16) + (14 << 5) + 28,
        0,
        (9 << 16) + (14 << 5) + 29,
        (14 << 16) + (14 << 10) + (29 << 5) + 30
      ]),
      Int32Array.from([
        (5 << 16) + 29,
        (5 << 16) + 28,
        (10 << 16) + (29 << 5) + 30,
        0,
        (5 << 16) + 30
      ]),
      Int32Array.from([
        (5 << 16) + 31,
        (10 << 16) + (31 << 5) + 28,
        (10 << 16) + (31 << 5) + 30,
        (10 << 16) + (31 << 5) + 29,
        0
      ])
    ];
    function static_SHIFT_TABLE(SHIFT_TABLE2) {
      for (let table of SHIFT_TABLE2) {
        Arrays.fill(table, -1);
      }
      SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
      SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
      return SHIFT_TABLE2;
    }
    const SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6));
    class State {
      constructor(token, mode, binaryBytes, bitCount) {
        this.token = token;
        this.mode = mode;
        this.binaryShiftByteCount = binaryBytes;
        this.bitCount = bitCount;
      }
      getMode() {
        return this.mode;
      }
      getToken() {
        return this.token;
      }
      getBinaryShiftByteCount() {
        return this.binaryShiftByteCount;
      }
      getBitCount() {
        return this.bitCount;
      }
      latchAndAppend(mode, value) {
        let bitCount = this.bitCount;
        let token = this.token;
        if (mode !== this.mode) {
          let latch = LATCH_TABLE[this.mode][mode];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
        }
        let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, value, latchModeBitCount);
        return new State(token, mode, 0, bitCount + latchModeBitCount);
      }
      shiftAndAppend(mode, value) {
        let token = this.token;
        let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
        token = add2(token, value, 5);
        return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
      }
      addBinaryShiftChar(index) {
        let token = this.token;
        let mode = this.mode;
        let bitCount = this.bitCount;
        if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
          let latch = LATCH_TABLE[mode][MODE_UPPER];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
          mode = MODE_UPPER;
        }
        let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
        let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
        if (result.binaryShiftByteCount === 2047 + 31) {
          result = result.endBinaryShift(index + 1);
        }
        return result;
      }
      endBinaryShift(index) {
        if (this.binaryShiftByteCount === 0) {
          return this;
        }
        let token = this.token;
        token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
        return new State(token, this.mode, 0, this.bitCount);
      }
      isBetterThanOrEqualTo(other) {
        let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
          newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);
        } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
          newModeBitCount += 10;
        }
        return newModeBitCount <= other.bitCount;
      }
      toBitArray(text) {
        let symbols = [];
        for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
          symbols.unshift(token);
        }
        let bitArray = new BitArray();
        for (const symbol of symbols) {
          symbol.appendTo(bitArray, text);
        }
        return bitArray;
      }
      toString() {
        return StringUtils.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
      }
      static calculateBinaryShiftCost(state) {
        if (state.binaryShiftByteCount > 62) {
          return 21;
        }
        if (state.binaryShiftByteCount > 31) {
          return 20;
        }
        if (state.binaryShiftByteCount > 0) {
          return 10;
        }
        return 0;
      }
    }
    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
    function static_CHAR_MAP(CHAR_MAP2) {
      const spaceCharCode = StringUtils.getCharCode(" ");
      const pointCharCode = StringUtils.getCharCode(".");
      const commaCharCode = StringUtils.getCharCode(",");
      CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
      const zUpperCharCode = StringUtils.getCharCode("Z");
      const aUpperCharCode = StringUtils.getCharCode("A");
      for (let c2 = aUpperCharCode; c2 <= zUpperCharCode; c2++) {
        CHAR_MAP2[MODE_UPPER][c2] = c2 - aUpperCharCode + 2;
      }
      CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
      const zLowerCharCode = StringUtils.getCharCode("z");
      const aLowerCharCode = StringUtils.getCharCode("a");
      for (let c2 = aLowerCharCode; c2 <= zLowerCharCode; c2++) {
        CHAR_MAP2[MODE_LOWER][c2] = c2 - aLowerCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
      const nineCharCode = StringUtils.getCharCode("9");
      const zeroCharCode = StringUtils.getCharCode("0");
      for (let c2 = zeroCharCode; c2 <= nineCharCode; c2++) {
        CHAR_MAP2[MODE_DIGIT][c2] = c2 - zeroCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
      CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
      const mixedTable = [
        "\0",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x07",
        "\b",
        "	",
        "\n",
        "\v",
        "\f",
        "\r",
        "\x1B",
        "",
        "",
        "",
        "",
        "@",
        "\\",
        "^",
        "_",
        "`",
        "|",
        "~",
        "\x7F"
      ];
      for (let i2 = 0; i2 < mixedTable.length; i2++) {
        CHAR_MAP2[MODE_MIXED][StringUtils.getCharCode(mixedTable[i2])] = i2;
      }
      const punctTable = [
        "\0",
        "\r",
        "\0",
        "\0",
        "\0",
        "\0",
        "!",
        "'",
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "{",
        "}"
      ];
      for (let i2 = 0; i2 < punctTable.length; i2++) {
        if (StringUtils.getCharCode(punctTable[i2]) > 0) {
          CHAR_MAP2[MODE_PUNCT][StringUtils.getCharCode(punctTable[i2])] = i2;
        }
      }
      return CHAR_MAP2;
    }
    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));
    class HighLevelEncoder {
      constructor(text) {
        this.text = text;
      }
      encode() {
        const spaceCharCode = StringUtils.getCharCode(" ");
        const lineBreakCharCode = StringUtils.getCharCode("\n");
        let states = Collections.singletonList(State.INITIAL_STATE);
        for (let index = 0; index < this.text.length; index++) {
          let pairCode;
          let nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
          switch (this.text[index]) {
            case StringUtils.getCharCode("\r"):
              pairCode = nextChar === lineBreakCharCode ? 2 : 0;
              break;
            case StringUtils.getCharCode("."):
              pairCode = nextChar === spaceCharCode ? 3 : 0;
              break;
            case StringUtils.getCharCode(","):
              pairCode = nextChar === spaceCharCode ? 4 : 0;
              break;
            case StringUtils.getCharCode(":"):
              pairCode = nextChar === spaceCharCode ? 5 : 0;
              break;
            default:
              pairCode = 0;
          }
          if (pairCode > 0) {
            states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);
            index++;
          } else {
            states = this.updateStateListForChar(states, index);
          }
        }
        const minState = Collections.min(states, (a2, b) => {
          return a2.getBitCount() - b.getBitCount();
        });
        return minState.toBitArray(this.text);
      }
      updateStateListForChar(states, index) {
        const result = [];
        for (let state of states) {
          this.updateStateForChar(state, index, result);
        }
        return HighLevelEncoder.simplifyStates(result);
      }
      updateStateForChar(state, index, result) {
        let ch = this.text[index] & 255;
        let charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
        let stateNoBinary = null;
        for (let mode = 0; mode <= MODE_PUNCT; mode++) {
          let charInMode = CHAR_MAP[mode][ch];
          if (charInMode > 0) {
            if (stateNoBinary == null) {
              stateNoBinary = state.endBinaryShift(index);
            }
            if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
              const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
              result.push(latchState);
            }
            if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
              const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
              result.push(shiftState);
            }
          }
        }
        if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
          let binaryState = state.addBinaryShiftChar(index);
          result.push(binaryState);
        }
      }
      static updateStateListForPair(states, index, pairCode) {
        const result = [];
        for (let state of states) {
          this.updateStateForPair(state, index, pairCode, result);
        }
        return this.simplifyStates(result);
      }
      static updateStateForPair(state, index, pairCode, result) {
        let stateNoBinary = state.endBinaryShift(index);
        result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
        if (state.getMode() !== MODE_PUNCT) {
          result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
        }
        if (pairCode === 3 || pairCode === 4) {
          let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
          result.push(digitState);
        }
        if (state.getBinaryShiftByteCount() > 0) {
          let binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);
          result.push(binaryState);
        }
      }
      static simplifyStates(states) {
        let result = [];
        for (const newState of states) {
          let add3 = true;
          for (const oldState of result) {
            if (oldState.isBetterThanOrEqualTo(newState)) {
              add3 = false;
              break;
            }
            if (newState.isBetterThanOrEqualTo(oldState)) {
              result = result.filter((x) => x !== oldState);
            }
          }
          if (add3) {
            result.push(newState);
          }
        }
        return result;
      }
    }
    class Encoder$1 {
      constructor() {
      }
      static encodeBytes(data) {
        return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
      }
      static encode(data, minECCPercent, userSpecifiedLayers) {
        let bits = new HighLevelEncoder(data).encode();
        let eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
        let totalSizeBits = bits.getSize() + eccBits;
        let compact;
        let layers;
        let totalBitsInLayer;
        let wordSize;
        let stuffedBits;
        if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
          compact = userSpecifiedLayers < 0;
          layers = Math.abs(userSpecifiedLayers);
          if (layers > (compact ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
            throw new IllegalArgumentException(StringUtils.format("Illegal value %s for layers", userSpecifiedLayers));
          }
          totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
          wordSize = Encoder$1.WORD_SIZE[layers];
          let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
          stuffedBits = Encoder$1.stuffBits(bits, wordSize);
          if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
          if (compact && stuffedBits.getSize() > wordSize * 64) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
        } else {
          wordSize = 0;
          stuffedBits = null;
          for (let i2 = 0; ; i2++) {
            if (i2 > Encoder$1.MAX_NB_BITS) {
              throw new IllegalArgumentException("Data too large for an Aztec code");
            }
            compact = i2 <= 3;
            layers = compact ? i2 + 1 : i2;
            totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact);
            if (totalSizeBits > totalBitsInLayer) {
              continue;
            }
            if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
              wordSize = Encoder$1.WORD_SIZE[layers];
              stuffedBits = Encoder$1.stuffBits(bits, wordSize);
            }
            let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
            if (compact && stuffedBits.getSize() > wordSize * 64) {
              continue;
            }
            if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
              break;
            }
          }
        }
        let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
        let messageSizeInWords = stuffedBits.getSize() / wordSize;
        let modeMessage = Encoder$1.generateModeMessage(compact, layers, messageSizeInWords);
        let baseMatrixSize = (compact ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let matrixSize;
        if (compact) {
          matrixSize = baseMatrixSize;
          for (let i2 = 0; i2 < alignmentMap.length; i2++) {
            alignmentMap[i2] = i2;
          }
        } else {
          matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = Integer.truncDivision(baseMatrixSize, 2);
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i2 = 0; i2 < origCenter; i2++) {
            let newOffset = i2 + Integer.truncDivision(i2, 15);
            alignmentMap[origCenter - i2 - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i2] = center + newOffset + 1;
          }
        }
        let matrix = new BitMatrix(matrixSize);
        for (let i2 = 0, rowOffset = 0; i2 < layers; i2++) {
          let rowSize = (layers - i2) * 4 + (compact ? 9 : 12);
          for (let j = 0; j < rowSize; j++) {
            let columnOffset = j * 2;
            for (let k = 0; k < 2; k++) {
              if (messageBits.get(rowOffset + columnOffset + k)) {
                matrix.set(alignmentMap[i2 * 2 + k], alignmentMap[i2 * 2 + j]);
              }
              if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
                matrix.set(alignmentMap[i2 * 2 + j], alignmentMap[baseMatrixSize - 1 - i2 * 2 - k]);
              }
              if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i2 * 2 - k], alignmentMap[baseMatrixSize - 1 - i2 * 2 - j]);
              }
              if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i2 * 2 - j], alignmentMap[i2 * 2 + k]);
              }
            }
          }
          rowOffset += rowSize * 8;
        }
        Encoder$1.drawModeMessage(matrix, compact, matrixSize, modeMessage);
        if (compact) {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
        } else {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
          for (let i2 = 0, j = 0; i2 < Integer.truncDivision(baseMatrixSize, 2) - 1; i2 += 15, j += 16) {
            for (let k = Integer.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
              matrix.set(Integer.truncDivision(matrixSize, 2) - j, k);
              matrix.set(Integer.truncDivision(matrixSize, 2) + j, k);
              matrix.set(k, Integer.truncDivision(matrixSize, 2) - j);
              matrix.set(k, Integer.truncDivision(matrixSize, 2) + j);
            }
          }
        }
        let aztec = new AztecCode();
        aztec.setCompact(compact);
        aztec.setSize(matrixSize);
        aztec.setLayers(layers);
        aztec.setCodeWords(messageSizeInWords);
        aztec.setMatrix(matrix);
        return aztec;
      }
      static drawBullsEye(matrix, center, size2) {
        for (let i2 = 0; i2 < size2; i2 += 2) {
          for (let j = center - i2; j <= center + i2; j++) {
            matrix.set(j, center - i2);
            matrix.set(j, center + i2);
            matrix.set(center - i2, j);
            matrix.set(center + i2, j);
          }
        }
        matrix.set(center - size2, center - size2);
        matrix.set(center - size2 + 1, center - size2);
        matrix.set(center - size2, center - size2 + 1);
        matrix.set(center + size2, center - size2);
        matrix.set(center + size2, center - size2 + 1);
        matrix.set(center + size2, center + size2 - 1);
      }
      static generateModeMessage(compact, layers, messageSizeInWords) {
        let modeMessage = new BitArray();
        if (compact) {
          modeMessage.appendBits(layers - 1, 2);
          modeMessage.appendBits(messageSizeInWords - 1, 6);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
        } else {
          modeMessage.appendBits(layers - 1, 5);
          modeMessage.appendBits(messageSizeInWords - 1, 11);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
        }
        return modeMessage;
      }
      static drawModeMessage(matrix, compact, matrixSize, modeMessage) {
        let center = Integer.truncDivision(matrixSize, 2);
        if (compact) {
          for (let i2 = 0; i2 < 7; i2++) {
            let offset = center - 3 + i2;
            if (modeMessage.get(i2)) {
              matrix.set(offset, center - 5);
            }
            if (modeMessage.get(i2 + 7)) {
              matrix.set(center + 5, offset);
            }
            if (modeMessage.get(20 - i2)) {
              matrix.set(offset, center + 5);
            }
            if (modeMessage.get(27 - i2)) {
              matrix.set(center - 5, offset);
            }
          }
        } else {
          for (let i2 = 0; i2 < 10; i2++) {
            let offset = center - 5 + i2 + Integer.truncDivision(i2, 5);
            if (modeMessage.get(i2)) {
              matrix.set(offset, center - 7);
            }
            if (modeMessage.get(i2 + 10)) {
              matrix.set(center + 7, offset);
            }
            if (modeMessage.get(29 - i2)) {
              matrix.set(offset, center + 7);
            }
            if (modeMessage.get(39 - i2)) {
              matrix.set(center - 7, offset);
            }
          }
        }
      }
      static generateCheckWords(bitArray, totalBits, wordSize) {
        let messageSizeInWords = bitArray.getSize() / wordSize;
        let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
        let totalWords = Integer.truncDivision(totalBits, wordSize);
        let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
        rs.encode(messageWords, totalWords - messageSizeInWords);
        let startPad = totalBits % wordSize;
        let messageBits = new BitArray();
        messageBits.appendBits(0, startPad);
        for (const messageWord of Array.from(messageWords)) {
          messageBits.appendBits(messageWord, wordSize);
        }
        return messageBits;
      }
      static bitsToWords(stuffedBits, wordSize, totalWords) {
        let message = new Int32Array(totalWords);
        let i2;
        let n2;
        for (i2 = 0, n2 = stuffedBits.getSize() / wordSize; i2 < n2; i2++) {
          let value = 0;
          for (let j = 0; j < wordSize; j++) {
            value |= stuffedBits.get(i2 * wordSize + j) ? 1 << wordSize - j - 1 : 0;
          }
          message[i2] = value;
        }
        return message;
      }
      static getGF(wordSize) {
        switch (wordSize) {
          case 4:
            return GenericGF.AZTEC_PARAM;
          case 6:
            return GenericGF.AZTEC_DATA_6;
          case 8:
            return GenericGF.AZTEC_DATA_8;
          case 10:
            return GenericGF.AZTEC_DATA_10;
          case 12:
            return GenericGF.AZTEC_DATA_12;
          default:
            throw new IllegalArgumentException("Unsupported word size " + wordSize);
        }
      }
      static stuffBits(bits, wordSize) {
        let out = new BitArray();
        let n2 = bits.getSize();
        let mask = (1 << wordSize) - 2;
        for (let i2 = 0; i2 < n2; i2 += wordSize) {
          let word = 0;
          for (let j = 0; j < wordSize; j++) {
            if (i2 + j >= n2 || bits.get(i2 + j)) {
              word |= 1 << wordSize - 1 - j;
            }
          }
          if ((word & mask) === mask) {
            out.appendBits(word & mask, wordSize);
            i2--;
          } else if ((word & mask) === 0) {
            out.appendBits(word | 1, wordSize);
            i2--;
          } else {
            out.appendBits(word, wordSize);
          }
        }
        return out;
      }
      static totalBitsInLayer(layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Encoder$1.DEFAULT_EC_PERCENT = 33;
    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
    Encoder$1.MAX_NB_BITS = 32;
    Encoder$1.MAX_NB_BITS_COMPACT = 4;
    Encoder$1.WORD_SIZE = Int32Array.from([
      4,
      6,
      6,
      8,
      8,
      8,
      8,
      8,
      8,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12
    ]);
    class AztecWriter {
      encode(contents, format, width, height) {
        return this.encodeWithHints(contents, format, width, height, null);
      }
      encodeWithHints(contents, format, width, height, hints) {
        let charset = StandardCharsets.ISO_8859_1;
        let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
        let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
        if (hints != null) {
          if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
            charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
          }
          if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
            eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
            layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
          }
        }
        return AztecWriter.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
      }
      static encodeLayers(contents, format, width, height, charset, eccPercent, layers) {
        if (format !== BarcodeFormat$1.AZTEC) {
          throw new IllegalArgumentException("Can only encode AZTEC, but got " + format);
        }
        let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
        return AztecWriter.renderResult(aztec, width, height);
      }
      static renderResult(code, width, height) {
        let input = code.getMatrix();
        if (input == null) {
          throw new IllegalStateException();
        }
        let inputWidth = input.getWidth();
        let inputHeight = input.getHeight();
        let outputWidth = Math.max(width, inputWidth);
        let outputHeight = Math.max(height, inputHeight);
        let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
        let leftPadding = (outputWidth - inputWidth * multiple) / 2;
        let topPadding = (outputHeight - inputHeight * multiple) / 2;
        let output = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY)) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      }
    }
    exports3.ArgumentException = ArgumentException;
    exports3.ArithmeticException = ArithmeticException;
    exports3.AztecCode = AztecCode;
    exports3.AztecCodeReader = AztecReader;
    exports3.AztecCodeWriter = AztecWriter;
    exports3.AztecDecoder = Decoder;
    exports3.AztecDetector = Detector;
    exports3.AztecDetectorResult = AztecDetectorResult;
    exports3.AztecEncoder = Encoder$1;
    exports3.AztecHighLevelEncoder = HighLevelEncoder;
    exports3.AztecPoint = Point;
    exports3.BarcodeFormat = BarcodeFormat$1;
    exports3.Binarizer = Binarizer;
    exports3.BinaryBitmap = BinaryBitmap;
    exports3.BitArray = BitArray;
    exports3.BitMatrix = BitMatrix;
    exports3.BitSource = BitSource;
    exports3.BrowserAztecCodeReader = BrowserAztecCodeReader;
    exports3.BrowserBarcodeReader = BrowserBarcodeReader;
    exports3.BrowserCodeReader = BrowserCodeReader;
    exports3.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
    exports3.BrowserMultiFormatReader = BrowserMultiFormatReader;
    exports3.BrowserPDF417Reader = BrowserPDF417Reader;
    exports3.BrowserQRCodeReader = BrowserQRCodeReader;
    exports3.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
    exports3.CharacterSetECI = CharacterSetECI;
    exports3.ChecksumException = ChecksumException;
    exports3.Code128Reader = Code128Reader;
    exports3.Code39Reader = Code39Reader;
    exports3.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
    exports3.DataMatrixReader = DataMatrixReader;
    exports3.DecodeHintType = DecodeHintType$1;
    exports3.DecoderResult = DecoderResult;
    exports3.DefaultGridSampler = DefaultGridSampler;
    exports3.DetectorResult = DetectorResult;
    exports3.EAN13Reader = EAN13Reader;
    exports3.EncodeHintType = EncodeHintType$1;
    exports3.Exception = Exception;
    exports3.FormatException = FormatException;
    exports3.GenericGF = GenericGF;
    exports3.GenericGFPoly = GenericGFPoly;
    exports3.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
    exports3.GridSampler = GridSampler;
    exports3.GridSamplerInstance = GridSamplerInstance;
    exports3.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
    exports3.HybridBinarizer = HybridBinarizer;
    exports3.ITFReader = ITFReader;
    exports3.IllegalArgumentException = IllegalArgumentException;
    exports3.IllegalStateException = IllegalStateException;
    exports3.InvertedLuminanceSource = InvertedLuminanceSource;
    exports3.LuminanceSource = LuminanceSource;
    exports3.MathUtils = MathUtils;
    exports3.MultiFormatOneDReader = MultiFormatOneDReader;
    exports3.MultiFormatReader = MultiFormatReader;
    exports3.MultiFormatWriter = MultiFormatWriter;
    exports3.NotFoundException = NotFoundException;
    exports3.OneDReader = OneDReader;
    exports3.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
    exports3.PDF417DecoderErrorCorrection = ErrorCorrection;
    exports3.PDF417Reader = PDF417Reader;
    exports3.PDF417ResultMetadata = PDF417ResultMetadata;
    exports3.PerspectiveTransform = PerspectiveTransform;
    exports3.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
    exports3.QRCodeByteMatrix = ByteMatrix;
    exports3.QRCodeDataMask = DataMask;
    exports3.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
    exports3.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
    exports3.QRCodeDecoderFormatInformation = FormatInformation;
    exports3.QRCodeEncoder = Encoder;
    exports3.QRCodeEncoderQRCode = QRCode;
    exports3.QRCodeMaskUtil = MaskUtil;
    exports3.QRCodeMatrixUtil = MatrixUtil;
    exports3.QRCodeMode = Mode$1;
    exports3.QRCodeReader = QRCodeReader;
    exports3.QRCodeVersion = Version$1;
    exports3.QRCodeWriter = QRCodeWriter;
    exports3.RGBLuminanceSource = RGBLuminanceSource;
    exports3.RSS14Reader = RSS14Reader;
    exports3.RSSExpandedReader = RSSExpandedReader;
    exports3.ReaderException = ReaderException;
    exports3.ReedSolomonDecoder = ReedSolomonDecoder;
    exports3.ReedSolomonEncoder = ReedSolomonEncoder;
    exports3.ReedSolomonException = ReedSolomonException;
    exports3.Result = Result;
    exports3.ResultMetadataType = ResultMetadataType$1;
    exports3.ResultPoint = ResultPoint;
    exports3.StringUtils = StringUtils;
    exports3.UnsupportedOperationException = UnsupportedOperationException;
    exports3.VideoInputDevice = VideoInputDevice;
    exports3.WhiteRectangleDetector = WhiteRectangleDetector;
    exports3.WriterException = WriterException;
    exports3.ZXingArrays = Arrays;
    exports3.ZXingCharset = Charset;
    exports3.ZXingInteger = Integer;
    exports3.ZXingStandardCharsets = StandardCharsets;
    exports3.ZXingStringBuilder = StringBuilder;
    exports3.ZXingStringEncoding = StringEncoding;
    exports3.ZXingSystem = System;
    Object.defineProperty(exports3, "__esModule", { value: true });
  });
})(zxingJs_umd$1, zxingJs_umd$1.exports);
const zxingJs_umd = /* @__PURE__ */ getDefaultExportFromCjs(zxingJs_umd$1.exports);
const ZXing = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: zxingJs_umd
}, [zxingJs_umd$1.exports]);
var ZXingHtml5QrcodeDecoder = function() {
  function ZXingHtml5QrcodeDecoder2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, zxingJs_umd$1.exports.BarcodeFormat.QR_CODE],
      [Html5QrcodeSupportedFormats.AZTEC, zxingJs_umd$1.exports.BarcodeFormat.AZTEC],
      [Html5QrcodeSupportedFormats.CODABAR, zxingJs_umd$1.exports.BarcodeFormat.CODABAR],
      [Html5QrcodeSupportedFormats.CODE_39, zxingJs_umd$1.exports.BarcodeFormat.CODE_39],
      [Html5QrcodeSupportedFormats.CODE_93, zxingJs_umd$1.exports.BarcodeFormat.CODE_93],
      [
        Html5QrcodeSupportedFormats.CODE_128,
        zxingJs_umd$1.exports.BarcodeFormat.CODE_128
      ],
      [
        Html5QrcodeSupportedFormats.DATA_MATRIX,
        zxingJs_umd$1.exports.BarcodeFormat.DATA_MATRIX
      ],
      [
        Html5QrcodeSupportedFormats.MAXICODE,
        zxingJs_umd$1.exports.BarcodeFormat.MAXICODE
      ],
      [Html5QrcodeSupportedFormats.ITF, zxingJs_umd$1.exports.BarcodeFormat.ITF],
      [Html5QrcodeSupportedFormats.EAN_13, zxingJs_umd$1.exports.BarcodeFormat.EAN_13],
      [Html5QrcodeSupportedFormats.EAN_8, zxingJs_umd$1.exports.BarcodeFormat.EAN_8],
      [Html5QrcodeSupportedFormats.PDF_417, zxingJs_umd$1.exports.BarcodeFormat.PDF_417],
      [Html5QrcodeSupportedFormats.RSS_14, zxingJs_umd$1.exports.BarcodeFormat.RSS_14],
      [
        Html5QrcodeSupportedFormats.RSS_EXPANDED,
        zxingJs_umd$1.exports.BarcodeFormat.RSS_EXPANDED
      ],
      [Html5QrcodeSupportedFormats.UPC_A, zxingJs_umd$1.exports.BarcodeFormat.UPC_A],
      [Html5QrcodeSupportedFormats.UPC_E, zxingJs_umd$1.exports.BarcodeFormat.UPC_E],
      [
        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,
        zxingJs_umd$1.exports.BarcodeFormat.UPC_EAN_EXTENSION
      ]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!ZXing) {
      throw "Use html5qrcode.min.js without edit, ZXing not found.";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createZXingFormats(requestedFormats);
    var hints = /* @__PURE__ */ new Map();
    hints.set(zxingJs_umd$1.exports.DecodeHintType.POSSIBLE_FORMATS, formats);
    this.hints = hints;
  }
  ZXingHtml5QrcodeDecoder2.prototype.decodeAsync = function(canvas) {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      try {
        resolve2(_this.decode(canvas));
      } catch (error) {
        reject(error);
      }
    });
  };
  ZXingHtml5QrcodeDecoder2.prototype.decode = function(canvas) {
    var zxingDecoder = new zxingJs_umd$1.exports.MultiFormatReader(this.verbose, this.hints);
    var luminanceSource = new zxingJs_umd$1.exports.HTMLCanvasElementLuminanceSource(canvas);
    var binaryBitmap = new zxingJs_umd$1.exports.BinaryBitmap(new zxingJs_umd$1.exports.HybridBinarizer(luminanceSource));
    var result = zxingDecoder.decode(binaryBitmap);
    return {
      text: result.text,
      format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format))
    };
  };
  ZXingHtml5QrcodeDecoder2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key, _2) {
      result.set(value, key);
    });
    return result;
  };
  ZXingHtml5QrcodeDecoder2.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {
    if (!this.reverseFormatMap.has(zxingFormat)) {
      throw "reverseFormatMap doesn't have " + zxingFormat;
    }
    return this.reverseFormatMap.get(zxingFormat);
  };
  ZXingHtml5QrcodeDecoder2.prototype.createZXingFormats = function(requestedFormats) {
    var zxingFormats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        zxingFormats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.logError(requestedFormat + " is not supported byZXingHtml5QrcodeShim");
      }
    }
    return zxingFormats;
  };
  return ZXingHtml5QrcodeDecoder2;
}();
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var BarcodeDetectorDelegate = function() {
  function BarcodeDetectorDelegate2(requestedFormats, verbose, logger) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, "qr_code"],
      [Html5QrcodeSupportedFormats.AZTEC, "aztec"],
      [Html5QrcodeSupportedFormats.CODABAR, "codabar"],
      [Html5QrcodeSupportedFormats.CODE_39, "code_39"],
      [Html5QrcodeSupportedFormats.CODE_93, "code_93"],
      [Html5QrcodeSupportedFormats.CODE_128, "code_128"],
      [Html5QrcodeSupportedFormats.DATA_MATRIX, "data_matrix"],
      [Html5QrcodeSupportedFormats.ITF, "itf"],
      [Html5QrcodeSupportedFormats.EAN_13, "ean_13"],
      [Html5QrcodeSupportedFormats.EAN_8, "ean_8"],
      [Html5QrcodeSupportedFormats.PDF_417, "pdf417"],
      [Html5QrcodeSupportedFormats.UPC_A, "upc_a"],
      [Html5QrcodeSupportedFormats.UPC_E, "upc_e"]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!BarcodeDetectorDelegate2.isSupported()) {
      throw "Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();";
    }
    this.verbose = verbose;
    this.logger = logger;
    var formats = this.createBarcodeDetectorFormats(requestedFormats);
    this.detector = new BarcodeDetector(formats);
    if (!this.detector) {
      throw "BarcodeDetector detector not supported";
    }
  }
  BarcodeDetectorDelegate2.isSupported = function() {
    if (!("BarcodeDetector" in window)) {
      return false;
    }
    var dummyDetector = new BarcodeDetector({ formats: ["qr_code"] });
    return typeof dummyDetector !== "undefined";
  };
  BarcodeDetectorDelegate2.prototype.decodeAsync = function(canvas) {
    return __awaiter(this, void 0, void 0, function() {
      var barcodes, largestBarcode;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.detector.detect(canvas)];
          case 1:
            barcodes = _a2.sent();
            if (!barcodes || barcodes.length === 0) {
              throw "No barcode or QR code detected.";
            }
            largestBarcode = this.selectLargestBarcode(barcodes);
            return [2, {
              text: largestBarcode.rawValue,
              format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format))
            }];
        }
      });
    });
  };
  BarcodeDetectorDelegate2.prototype.selectLargestBarcode = function(barcodes) {
    var largestBarcode = null;
    var maxArea = 0;
    for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {
      var barcode = barcodes_1[_i];
      var area = barcode.boundingBox.width * barcode.boundingBox.height;
      if (area > maxArea) {
        maxArea = area;
        largestBarcode = barcode;
      }
    }
    if (!largestBarcode) {
      throw "No largest barcode found";
    }
    return largestBarcode;
  };
  BarcodeDetectorDelegate2.prototype.createBarcodeDetectorFormats = function(requestedFormats) {
    var formats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        formats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.warn(requestedFormat + " is not supported byBarcodeDetectorDelegate");
      }
    }
    return { formats };
  };
  BarcodeDetectorDelegate2.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {
    if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {
      throw "reverseFormatMap doesn't have " + barcodeDetectorFormat;
    }
    return this.reverseFormatMap.get(barcodeDetectorFormat);
  };
  BarcodeDetectorDelegate2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key, _2) {
      result.set(value, key);
    });
    return result;
  };
  return BarcodeDetectorDelegate2;
}();
var Html5QrcodeShim = function() {
  function Html5QrcodeShim2(requestedFormats, verbose, logger, experimentalFeatureConfig) {
    this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;
    this.executions = 0;
    this.executionResults = [];
    this.verbose = verbose;
    if (experimentalFeatureConfig.useBarCodeDetectorIfSupported === true && BarcodeDetectorDelegate.isSupported()) {
      this.decoder = new BarcodeDetectorDelegate(requestedFormats, verbose, logger);
    } else {
      this.decoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger);
    }
  }
  Html5QrcodeShim2.prototype.decodeAsync = function(canvas) {
    var _this = this;
    var start = performance.now();
    return this.decoder.decodeAsync(canvas).finally(function() {
      if (_this.verbose) {
        var executionTime = performance.now() - start;
        _this.executionResults.push(executionTime);
        _this.executions++;
        _this.possiblyFlushPerformanceReport();
      }
    });
  };
  Html5QrcodeShim2.prototype.possiblyFlushPerformanceReport = function() {
    if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {
      return;
    }
    var sum = 0;
    for (var _i = 0, _a2 = this.executionResults; _i < _a2.length; _i++) {
      var executionTime = _a2[_i];
      sum += executionTime;
    }
    var mean = sum / this.executionResults.length;
    console.log(mean + " ms for " + this.executionResults.length + " last runs.");
    this.executions = 0;
    this.executionResults = [];
  };
  return Html5QrcodeShim2;
}();
var ExperimentalFeaturesConfigFactory = function() {
  function ExperimentalFeaturesConfigFactory2() {
  }
  ExperimentalFeaturesConfigFactory2.createExperimentalFeaturesConfig = function(config) {
    if (!config) {
      return {
        useBarCodeDetectorIfSupported: false
      };
    }
    if (config.useBarCodeDetectorIfSupported !== true) {
      config.useBarCodeDetectorIfSupported = false;
    }
    return config;
  };
  return ExperimentalFeaturesConfigFactory2;
}();
var Html5QrcodeScannerState;
(function(Html5QrcodeScannerState2) {
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["UNKNOWN"] = 0] = "UNKNOWN";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["NOT_STARTED"] = 1] = "NOT_STARTED";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["SCANNING"] = 2] = "SCANNING";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["PAUSED"] = 3] = "PAUSED";
})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));
var StateManagerImpl = function() {
  function StateManagerImpl2() {
    this.state = Html5QrcodeScannerState.NOT_STARTED;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  }
  StateManagerImpl2.prototype.directTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.state = newState;
  };
  StateManagerImpl2.prototype.startTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.onGoingTransactionNewState = newState;
    return this;
  };
  StateManagerImpl2.prototype.execute = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot execute().";
    }
    var tempNewState = this.onGoingTransactionNewState;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    this.directTransition(tempNewState);
  };
  StateManagerImpl2.prototype.cancel = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot cancel().";
    }
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  };
  StateManagerImpl2.prototype.getState = function() {
    return this.state;
  };
  StateManagerImpl2.prototype.failIfTransitionOngoing = function() {
    if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {
      throw "Cannnot transition to a new state, already under transition";
    }
  };
  StateManagerImpl2.prototype.validateTransition = function(newState) {
    switch (this.state) {
      case Html5QrcodeScannerState.UNKNOWN:
        throw "Transition from unknown is not allowed";
      case Html5QrcodeScannerState.NOT_STARTED:
        this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);
        break;
      case Html5QrcodeScannerState.SCANNING:
        break;
      case Html5QrcodeScannerState.PAUSED:
        break;
    }
  };
  StateManagerImpl2.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {
    for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {
      var disallowedState = disallowedStatesToTransition_1[_i];
      if (newState === disallowedState) {
        throw "Cannot transition from " + this.state + " to " + newState;
      }
    }
  };
  return StateManagerImpl2;
}();
var StateManagerProxy = function() {
  function StateManagerProxy2(stateManager) {
    this.stateManager = stateManager;
  }
  StateManagerProxy2.prototype.startTransition = function(newState) {
    return this.stateManager.startTransition(newState);
  };
  StateManagerProxy2.prototype.directTransition = function(newState) {
    this.stateManager.directTransition(newState);
  };
  StateManagerProxy2.prototype.getState = function() {
    return this.stateManager.getState();
  };
  StateManagerProxy2.prototype.canScanFile = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isScanning = function() {
    return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isStrictlyScanning = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;
  };
  StateManagerProxy2.prototype.isPaused = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;
  };
  return StateManagerProxy2;
}();
var StateManagerFactory = function() {
  function StateManagerFactory2() {
  }
  StateManagerFactory2.create = function() {
    return new StateManagerProxy(new StateManagerImpl());
  };
  return StateManagerFactory2;
}();
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Constants = function(_super) {
  __extends(Constants2, _super);
  function Constants2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Constants2.DEFAULT_WIDTH = 300;
  Constants2.DEFAULT_WIDTH_OFFSET = 2;
  Constants2.FILE_SCAN_MIN_HEIGHT = 300;
  Constants2.MIN_QR_BOX_SIZE = 50;
  Constants2.SHADED_LEFT = 1;
  Constants2.SHADED_RIGHT = 2;
  Constants2.SHADED_TOP = 3;
  Constants2.SHADED_BOTTOM = 4;
  Constants2.SHADED_REGION_ELEMENT_ID = "qr-shaded-region";
  Constants2.VERBOSE = false;
  Constants2.BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
  Constants2.BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";
  return Constants2;
}(Html5QrcodeConstants);
var InternalHtml5QrcodeConfig = function() {
  function InternalHtml5QrcodeConfig2(config, logger) {
    this.logger = logger;
    this.fps = Constants.SCAN_DEFAULT_FPS;
    if (!config) {
      this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;
    } else {
      if (config.fps) {
        this.fps = config.fps;
      }
      this.disableFlip = config.disableFlip === true;
      this.qrbox = config.qrbox;
      this.aspectRatio = config.aspectRatio;
      this.videoConstraints = config.videoConstraints;
    }
  }
  InternalHtml5QrcodeConfig2.prototype.isMediaStreamConstraintsValid = function() {
    if (!this.videoConstraints) {
      this.logger.logError("Empty videoConstraints", true);
      return false;
    }
    return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);
  };
  InternalHtml5QrcodeConfig2.prototype.isShadedBoxEnabled = function() {
    return !isNullOrUndefined(this.qrbox);
  };
  InternalHtml5QrcodeConfig2.create = function(config, logger) {
    return new InternalHtml5QrcodeConfig2(config, logger);
  };
  return InternalHtml5QrcodeConfig2;
}();
var Html5Qrcode = function() {
  function Html5Qrcode2(elementId, configOrVerbosityFlag) {
    this.element = null;
    this.canvasElement = null;
    this.scannerPausedUiElement = null;
    this.hasBorderShaders = null;
    this.borderShaders = null;
    this.qrMatch = null;
    this.videoElement = null;
    this.localMediaStream = null;
    this.qrRegion = null;
    this.context = null;
    this.lastScanImageFile = null;
    this.isScanning = false;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=" + elementId + " not found";
    }
    this.elementId = elementId;
    this.verbose = false;
    var experimentalFeatureConfig;
    if (typeof configOrVerbosityFlag == "boolean") {
      this.verbose = configOrVerbosityFlag === true;
    } else if (configOrVerbosityFlag) {
      this.verbose = configOrVerbosityFlag.verbose === true;
      experimentalFeatureConfig = configOrVerbosityFlag.experimentalFeatures;
    }
    this.logger = new BaseLoggger(this.verbose);
    this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.verbose, this.logger, ExperimentalFeaturesConfigFactory.createExperimentalFeaturesConfig(experimentalFeatureConfig));
    this.foreverScanTimeout;
    this.localMediaStream;
    this.shouldScan = true;
    this.stateManagerProxy = StateManagerFactory.create();
  }
  Html5Qrcode2.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
    if (!cameraIdOrConfig) {
      throw "cameraIdOrConfig is required";
    }
    if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
      throw "qrCodeSuccessCallback is required and should be a function.";
    }
    if (!qrCodeErrorCallback) {
      qrCodeErrorCallback = this.verbose ? this.logger.log : function() {
      };
    }
    var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);
    this.clearElement();
    var videoConstraintsAvailableAndValid = false;
    if (internalConfig.videoConstraints) {
      if (!internalConfig.isMediaStreamConstraintsValid()) {
        this.logger.logError("'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'", true);
      } else {
        videoConstraintsAvailableAndValid = true;
      }
    }
    var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;
    internalConfig.isShadedBoxEnabled();
    var element = document.getElementById(this.elementId);
    var rootElementWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
    element.style.position = "relative";
    this.shouldScan = true;
    this.element = element;
    var $this = this;
    var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);
    return new Promise(function(resolve2, reject) {
      var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);
      if (!videoConstraints) {
        toScanningStateChangeTransaction.cancel();
        reject("videoConstraints should be defined");
        return;
      }
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({
          audio: false,
          video: videoConstraints
        }).then(function(stream) {
          $this.onMediaStreamReceived(stream, internalConfig, areVideoConstraintsEnabled, rootElementWidth, qrCodeSuccessCallback, qrCodeErrorCallback).then(function(_2) {
            toScanningStateChangeTransaction.execute();
            $this.isScanning = true;
            resolve2(null);
          }).catch(function(error) {
            toScanningStateChangeTransaction.cancel();
            reject(error);
          });
        }).catch(function(error) {
          toScanningStateChangeTransaction.cancel();
          reject(Html5QrcodeStrings.errorGettingUserMedia(error));
        });
      } else {
        toScanningStateChangeTransaction.cancel();
        reject(Html5QrcodeStrings.cameraStreamingNotSupported());
      }
    });
  };
  Html5Qrcode2.prototype.pause = function(shouldPauseVideo) {
    if (!this.stateManagerProxy.isStrictlyScanning()) {
      throw "Cannot pause, scanner is not scanning.";
    }
    this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);
    this.showPausedState();
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    if (shouldPauseVideo && this.videoElement) {
      this.videoElement.pause();
    }
  };
  Html5Qrcode2.prototype.resume = function() {
    if (!this.stateManagerProxy.isPaused()) {
      throw "Cannot result, scanner is not paused.";
    }
    if (!this.videoElement) {
      throw "VideoElement doesn't exist while trying resume()";
    }
    var $this = this;
    var transitionToScanning = function() {
      $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);
      $this.hidePausedState();
    };
    var isVideoPaused = this.videoElement.paused;
    if (!isVideoPaused) {
      transitionToScanning();
      return;
    }
    var onVideoResume = function() {
      var _a2;
      setTimeout(transitionToScanning, 200);
      (_a2 = $this.videoElement) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("playing", onVideoResume);
    };
    this.videoElement.addEventListener("playing", onVideoResume);
    this.videoElement.play();
  };
  Html5Qrcode2.prototype.getState = function() {
    return this.stateManagerProxy.getState();
  };
  Html5Qrcode2.prototype.stop = function() {
    var _this = this;
    if (!this.stateManagerProxy.isScanning()) {
      throw "Cannot stop, scanner is not running or paused.";
    }
    var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);
    this.shouldScan = false;
    if (this.foreverScanTimeout) {
      clearTimeout(this.foreverScanTimeout);
    }
    var removeQrRegion = function() {
      if (!_this.element) {
        return;
      }
      var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);
      if (childElement) {
        _this.element.removeChild(childElement);
      }
    };
    return new Promise(function(resolve2, _2) {
      var onAllTracksClosed = function() {
        _this.localMediaStream = null;
        if (_this.element) {
          _this.element.removeChild(_this.videoElement);
          _this.element.removeChild(_this.canvasElement);
        }
        removeQrRegion();
        if (_this.qrRegion) {
          _this.qrRegion = null;
        }
        if (_this.context) {
          _this.context = null;
        }
        toStoppedStateTransaction.execute();
        _this.hidePausedState();
        _this.isScanning = false;
        resolve2();
      };
      if (!_this.localMediaStream) {
        onAllTracksClosed();
      }
      var tracksToClose = _this.localMediaStream.getVideoTracks().length;
      var tracksClosed = 0;
      _this.localMediaStream.getVideoTracks().forEach(function(videoTrack) {
        _this.localMediaStream.removeTrack(videoTrack);
        videoTrack.stop();
        ++tracksClosed;
        if (tracksClosed >= tracksToClose) {
          onAllTracksClosed();
        }
      });
    });
  };
  Html5Qrcode2.prototype.scanFile = function(imageFile, showImage) {
    return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {
      return html5qrcodeResult.decodedText;
    });
  };
  Html5Qrcode2.prototype.scanFileV2 = function(imageFile, showImage) {
    var _this = this;
    if (!imageFile || !(imageFile instanceof File)) {
      throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'.";
    }
    if (isNullOrUndefined(showImage)) {
      showImage = true;
    }
    if (!this.stateManagerProxy.canScanFile()) {
      throw "Cannot start file scan - ongoing camera scan";
    }
    return new Promise(function(resolve2, reject) {
      _this.possiblyCloseLastScanImageFile();
      _this.clearElement();
      _this.lastScanImageFile = URL.createObjectURL(imageFile);
      var inputImage = new Image();
      inputImage.onload = function() {
        var imageWidth = inputImage.width;
        var imageHeight = inputImage.height;
        var element = document.getElementById(_this.elementId);
        var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
        var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);
        var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
        if (showImage) {
          var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, "qr-canvas-visible");
          visibleCanvas.style.display = "inline-block";
          element.appendChild(visibleCanvas);
          var context_1 = visibleCanvas.getContext("2d");
          if (!context_1) {
            throw "Unable to get 2d context from canvas";
          }
          context_1.canvas.width = containerWidth;
          context_1.canvas.height = containerHeight;
          context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);
        }
        var hiddenCanvas = _this.createCanvasElement(config.width, config.height);
        element.appendChild(hiddenCanvas);
        var context = hiddenCanvas.getContext("2d");
        if (!context) {
          throw "Unable to get 2d context from canvas";
        }
        context.canvas.width = config.width;
        context.canvas.height = config.height;
        context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, 0, 0, config.width, config.height);
        try {
          _this.qrcode.decodeAsync(hiddenCanvas).then(function(result) {
            resolve2(Html5QrcodeResultFactory.createFromQrcodeResult(result));
          }).catch(reject);
        } catch (exception) {
          reject("QR code parse error, error = " + exception);
        }
      };
      inputImage.onerror = reject;
      inputImage.onabort = reject;
      inputImage.onstalled = reject;
      inputImage.onsuspend = reject;
      inputImage.src = URL.createObjectURL(imageFile);
    });
  };
  Html5Qrcode2.prototype.clear = function() {
    this.clearElement();
  };
  Html5Qrcode2.getCameras = function() {
    if (navigator.mediaDevices) {
      return Html5Qrcode2.getCamerasFromMediaDevices();
    }
    var mst = MediaStreamTrack;
    if (MediaStreamTrack && mst.getSources) {
      return Html5Qrcode2.getCamerasFromMediaStreamTrack();
    }
    var isHttpsOrLocalhost = function() {
      if (location.protocol === "https:") {
        return true;
      }
      var host = location.host.split(":")[0];
      return host === "127.0.0.1" || host === "localhost";
    };
    var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();
    if (!isHttpsOrLocalhost()) {
      errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();
    }
    return Promise.reject(errorMessage);
  };
  Html5Qrcode2.prototype.getRunningTrackCapabilities = function() {
    if (this.localMediaStream == null) {
      throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
    }
    if (this.localMediaStream.getVideoTracks().length === 0) {
      throw "No video tracks found";
    }
    var videoTrack = this.localMediaStream.getVideoTracks()[0];
    return videoTrack.getCapabilities();
  };
  Html5Qrcode2.prototype.applyVideoConstraints = function(videoConstaints) {
    var _this = this;
    if (!videoConstaints) {
      throw "videoConstaints is required argument.";
    } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {
      throw "invalid videoConstaints passed, check logs for more details";
    }
    if (this.localMediaStream === null) {
      throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
    }
    if (this.localMediaStream.getVideoTracks().length === 0) {
      throw "No video tracks found";
    }
    return new Promise(function(resolve2, reject) {
      if ("aspectRatio" in videoConstaints) {
        reject("Chaning 'aspectRatio' in run-time is not yet supported.");
        return;
      }
      var videoTrack = _this.localMediaStream.getVideoTracks()[0];
      videoTrack.applyConstraints(videoConstaints).then(function(_2) {
        resolve2(_2);
      }).catch(function(error) {
        reject(error);
      });
    });
  };
  Html5Qrcode2.getCamerasFromMediaDevices = function() {
    return new Promise(function(resolve2, reject) {
      navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(function(stream) {
        var closeActiveStreams = function(stream2) {
          var tracks = stream2.getVideoTracks();
          for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
            var track2 = tracks_1[_i];
            track2.enabled = false;
            track2.stop();
            stream2.removeTrack(track2);
          }
        };
        navigator.mediaDevices.enumerateDevices().then(function(devices) {
          var results = [];
          for (var _i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
            var device = devices_1[_i];
            if (device.kind === "videoinput") {
              results.push({
                id: device.deviceId,
                label: device.label
              });
            }
          }
          closeActiveStreams(stream);
          resolve2(results);
        }).catch(function(err) {
          reject(err.name + " : " + err.message);
        });
      }).catch(function(err) {
        reject(err.name + " : " + err.message);
      });
    });
  };
  Html5Qrcode2.getCamerasFromMediaStreamTrack = function() {
    return new Promise(function(resolve2, _2) {
      var callback = function(sourceInfos) {
        var results = [];
        for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
          var sourceInfo = sourceInfos_1[_i];
          if (sourceInfo.kind === "video") {
            results.push({
              id: sourceInfo.id,
              label: sourceInfo.label
            });
          }
        }
        resolve2(results);
      };
      var mst = MediaStreamTrack;
      mst.getSources(callback);
    });
  };
  Html5Qrcode2.prototype.getSupportedFormats = function(configOrVerbosityFlag) {
    var allFormats = [
      Html5QrcodeSupportedFormats.QR_CODE,
      Html5QrcodeSupportedFormats.AZTEC,
      Html5QrcodeSupportedFormats.CODABAR,
      Html5QrcodeSupportedFormats.CODE_39,
      Html5QrcodeSupportedFormats.CODE_93,
      Html5QrcodeSupportedFormats.CODE_128,
      Html5QrcodeSupportedFormats.DATA_MATRIX,
      Html5QrcodeSupportedFormats.MAXICODE,
      Html5QrcodeSupportedFormats.ITF,
      Html5QrcodeSupportedFormats.EAN_13,
      Html5QrcodeSupportedFormats.EAN_8,
      Html5QrcodeSupportedFormats.PDF_417,
      Html5QrcodeSupportedFormats.RSS_14,
      Html5QrcodeSupportedFormats.RSS_EXPANDED,
      Html5QrcodeSupportedFormats.UPC_A,
      Html5QrcodeSupportedFormats.UPC_E,
      Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION
    ];
    if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == "boolean") {
      return allFormats;
    }
    if (!configOrVerbosityFlag.formatsToSupport) {
      return allFormats;
    }
    if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {
      throw "configOrVerbosityFlag.formatsToSupport should be undefined or an array.";
    }
    if (configOrVerbosityFlag.formatsToSupport.length === 0) {
      throw "Atleast 1 formatsToSupport is needed.";
    }
    var supportedFormats = [];
    for (var _i = 0, _a2 = configOrVerbosityFlag.formatsToSupport; _i < _a2.length; _i++) {
      var format = _a2[_i];
      if (isValidHtml5QrcodeSupportedFormats(format)) {
        supportedFormats.push(format);
      } else {
        this.logger.warn("Invalid format: " + format + " passed in config, ignoring.");
      }
    }
    if (supportedFormats.length === 0) {
      throw "None of formatsToSupport match supported values.";
    }
    return supportedFormats;
  };
  Html5Qrcode2.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    var _this = this;
    var qrboxSize = internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    var validateMinSize = function(size2) {
      if (size2 < Constants.MIN_QR_BOX_SIZE) {
        throw "minimum size of 'config.qrbox' dimension value is" + (" " + Constants.MIN_QR_BOX_SIZE + "px.");
      }
    };
    var correctWidthBasedOnRootElementSize = function(configWidth) {
      if (configWidth > viewfinderWidth) {
        _this.logger.warn("`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.");
        configWidth = viewfinderWidth;
      }
      return configWidth;
    };
    validateMinSize(qrDimensions.width);
    validateMinSize(qrDimensions.height);
    qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);
  };
  Html5Qrcode2.prototype.validateQrboxConfig = function(qrboxSize) {
    if (typeof qrboxSize === "number") {
      return;
    }
    if (typeof qrboxSize === "function") {
      return;
    }
    if (qrboxSize.width === void 0 || qrboxSize.height === void 0) {
      throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set.";
    }
  };
  Html5Qrcode2.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {
    if (typeof qrboxSize === "number") {
      return { width: qrboxSize, height: qrboxSize };
    } else if (typeof qrboxSize === "function") {
      try {
        return qrboxSize(viewfinderWidth, viewfinderHeight);
      } catch (error) {
        throw new Error("qrbox config was passed as a function but it failed with unknown error" + error);
      }
    }
    return qrboxSize;
  };
  Html5Qrcode2.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    if (internalConfig.isShadedBoxEnabled()) {
      this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);
    }
    var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    if (qrDimensions.height > viewfinderHeight) {
      this.logger.warn("[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored");
    }
    var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;
    var defaultQrRegion = {
      x: 0,
      y: 0,
      width: viewfinderWidth,
      height: viewfinderHeight
    };
    var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;
    var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);
    var context = canvasElement.getContext("2d");
    context.canvas.width = qrRegion.width;
    context.canvas.height = qrRegion.height;
    this.element.append(canvasElement);
    if (shouldShadingBeApplied) {
      this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);
    }
    this.createScannerPausedUiElement(this.element);
    this.qrRegion = qrRegion;
    this.context = context;
    this.canvasElement = canvasElement;
  };
  Html5Qrcode2.prototype.createScannerPausedUiElement = function(rootElement) {
    var scannerPausedUiElement = document.createElement("div");
    scannerPausedUiElement.innerText = "Scanner paused";
    scannerPausedUiElement.style.display = "none";
    scannerPausedUiElement.style.position = "absolute";
    scannerPausedUiElement.style.top = "0px";
    scannerPausedUiElement.style.zIndex = "1";
    scannerPausedUiElement.style.background = "yellow";
    scannerPausedUiElement.style.textAlign = "center";
    scannerPausedUiElement.style.width = "100%";
    rootElement.appendChild(scannerPausedUiElement);
    this.scannerPausedUiElement = scannerPausedUiElement;
  };
  Html5Qrcode2.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (this.stateManagerProxy.isPaused()) {
      return Promise.resolve(false);
    }
    return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {
      qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));
      _this.possiblyUpdateShaders(true);
      return true;
    }).catch(function(error) {
      _this.possiblyUpdateShaders(false);
      var errorMessage = Html5QrcodeStrings.codeParseError(error);
      qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));
      return false;
    });
  };
  Html5Qrcode2.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!this.shouldScan) {
      return;
    }
    if (!this.localMediaStream) {
      return;
    }
    var videoElement = this.videoElement;
    var widthRatio = videoElement.videoWidth / videoElement.clientWidth;
    var heightRatio = videoElement.videoHeight / videoElement.clientHeight;
    if (!this.qrRegion) {
      throw "qrRegion undefined when localMediaStream is ready.";
    }
    var sWidthOffset = this.qrRegion.width * widthRatio;
    var sHeightOffset = this.qrRegion.height * heightRatio;
    var sxOffset = this.qrRegion.x * widthRatio;
    var syOffset = this.qrRegion.y * heightRatio;
    this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);
    var triggerNextScan = function() {
      _this.foreverScanTimeout = setTimeout(function() {
        _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
      }, _this.getTimeoutFps(internalConfig.fps));
    };
    this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {
      if (!isSuccessfull && internalConfig.disableFlip !== true) {
        _this.context.translate(_this.context.canvas.width, 0);
        _this.context.scale(-1, 1);
        _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {
          triggerNextScan();
        });
      } else {
        triggerNextScan();
      }
    }).catch(function(error) {
      _this.logger.logError("Error happend while scanning context", error);
      triggerNextScan();
    });
  };
  Html5Qrcode2.prototype.onMediaStreamReceived = function(mediaStream, internalConfig, areVideoConstraintsEnabled, clientWidth, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    var $this = this;
    return new Promise(function(resolve2, reject) {
      var setupVideo = function() {
        var videoElement = _this.createVideoElement(clientWidth);
        $this.element.append(videoElement);
        videoElement.onabort = reject;
        videoElement.onerror = reject;
        var onVideoStart = function() {
          var videoWidth = videoElement.clientWidth;
          var videoHeight = videoElement.clientHeight;
          $this.setupUi(videoWidth, videoHeight, internalConfig);
          $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
          videoElement.removeEventListener("playing", onVideoStart);
          resolve2(null);
        };
        videoElement.addEventListener("playing", onVideoStart);
        videoElement.srcObject = mediaStream;
        videoElement.play();
        $this.videoElement = videoElement;
      };
      $this.localMediaStream = mediaStream;
      if (areVideoConstraintsEnabled || !internalConfig.aspectRatio) {
        setupVideo();
      } else {
        var constraints = {
          aspectRatio: internalConfig.aspectRatio
        };
        var track2 = mediaStream.getVideoTracks()[0];
        track2.applyConstraints(constraints).then(function(_2) {
          return setupVideo();
        }).catch(function(error) {
          $this.logger.logErrors([
            "[Html5Qrcode] Constriants could not be satisfied, ignoring constraints",
            error
          ]);
          setupVideo();
        });
      }
    });
  };
  Html5Qrcode2.prototype.createVideoConstraints = function(cameraIdOrConfig) {
    if (typeof cameraIdOrConfig == "string") {
      return { deviceId: { exact: cameraIdOrConfig } };
    } else if (typeof cameraIdOrConfig == "object") {
      var facingModeKey = "facingMode";
      var deviceIdKey = "deviceId";
      var allowedFacingModeValues_1 = { "user": true, "environment": true };
      var exactKey = "exact";
      var isValidFacingModeValue = function(value) {
        if (value in allowedFacingModeValues_1) {
          return true;
        } else {
          throw "config has invalid 'facingMode' value = " + ("'" + value + "'");
        }
      };
      var keys = Object.keys(cameraIdOrConfig);
      if (keys.length !== 1) {
        throw "'cameraIdOrConfig' object should have exactly 1 key," + (" if passed as an object, found " + keys.length + " keys");
      }
      var key = Object.keys(cameraIdOrConfig)[0];
      if (key !== facingModeKey && key !== deviceIdKey) {
        throw "Only '" + facingModeKey + "' and '" + deviceIdKey + "'  are supported for 'cameraIdOrConfig'";
      }
      if (key === facingModeKey) {
        var facingMode = cameraIdOrConfig.facingMode;
        if (typeof facingMode == "string") {
          if (isValidFacingModeValue(facingMode)) {
            return { facingMode };
          }
        } else if (typeof facingMode == "object") {
          if (exactKey in facingMode) {
            if (isValidFacingModeValue(facingMode["" + exactKey])) {
              return {
                facingMode: {
                  exact: facingMode["" + exactKey]
                }
              };
            }
          } else {
            throw "'facingMode' should be string or object with" + (" " + exactKey + " as key.");
          }
        } else {
          var type_1 = typeof facingMode;
          throw "Invalid type of 'facingMode' = " + type_1;
        }
      } else {
        var deviceId = cameraIdOrConfig.deviceId;
        if (typeof deviceId == "string") {
          return { deviceId };
        } else if (typeof deviceId == "object") {
          if (exactKey in deviceId) {
            return {
              deviceId: { exact: deviceId["" + exactKey] }
            };
          } else {
            throw "'deviceId' should be string or object with" + (" " + exactKey + " as key.");
          }
        } else {
          var type_2 = typeof deviceId;
          throw "Invalid type of 'deviceId' = " + type_2;
        }
      }
    }
    var type = typeof cameraIdOrConfig;
    throw "Invalid type of 'cameraIdOrConfig' = " + type;
  };
  Html5Qrcode2.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {
    if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
      var xoffset = (containerWidth - imageWidth) / 2;
      var yoffset = (containerHeight - imageHeight) / 2;
      return {
        x: xoffset,
        y: yoffset,
        width: imageWidth,
        height: imageHeight
      };
    } else {
      var formerImageWidth = imageWidth;
      var formerImageHeight = imageHeight;
      if (imageWidth > containerWidth) {
        imageHeight = containerWidth / imageWidth * imageHeight;
        imageWidth = containerWidth;
      }
      if (imageHeight > containerHeight) {
        imageWidth = containerHeight / imageHeight * imageWidth;
        imageHeight = containerHeight;
      }
      this.logger.log("Image downsampled from " + (formerImageWidth + "X" + formerImageHeight) + (" to " + imageWidth + "X" + imageHeight + "."));
      return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
    }
  };
  Html5Qrcode2.prototype.clearElement = function() {
    if (this.stateManagerProxy.isScanning()) {
      throw "Cannot clear while scan is ongoing, close it first.";
    }
    var element = document.getElementById(this.elementId);
    if (element) {
      element.innerHTML = "";
    }
  };
  Html5Qrcode2.prototype.createVideoElement = function(width) {
    var videoElement = document.createElement("video");
    videoElement.style.width = width + "px";
    videoElement.muted = true;
    videoElement.setAttribute("muted", "true");
    videoElement.playsInline = true;
    return videoElement;
  };
  Html5Qrcode2.prototype.possiblyUpdateShaders = function(qrMatch) {
    if (this.qrMatch === qrMatch) {
      return;
    }
    if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {
      this.borderShaders.forEach(function(shader) {
        shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;
      });
    }
    this.qrMatch = qrMatch;
  };
  Html5Qrcode2.prototype.possiblyCloseLastScanImageFile = function() {
    if (this.lastScanImageFile) {
      URL.revokeObjectURL(this.lastScanImageFile);
      this.lastScanImageFile = null;
    }
  };
  Html5Qrcode2.prototype.createCanvasElement = function(width, height, customId) {
    var canvasWidth = width;
    var canvasHeight = height;
    var canvasElement = document.createElement("canvas");
    canvasElement.style.width = canvasWidth + "px";
    canvasElement.style.height = canvasHeight + "px";
    canvasElement.style.display = "none";
    canvasElement.id = isNullOrUndefined(customId) ? "qr-canvas" : customId;
    return canvasElement;
  };
  Html5Qrcode2.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {
    if (qrboxSize.width > width || qrboxSize.height > height) {
      throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element.";
    }
    return {
      x: (width - qrboxSize.width) / 2,
      y: (height - qrboxSize.height) / 2,
      width: qrboxSize.width,
      height: qrboxSize.height
    };
  };
  Html5Qrcode2.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {
    if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {
      return;
    }
    var shadingElement = document.createElement("div");
    shadingElement.style.position = "absolute";
    var rightLeftBorderSize = (width - qrboxSize.width) / 2;
    var topBottomBorderSize = (height - qrboxSize.height) / 2;
    shadingElement.style.borderLeft = rightLeftBorderSize + "px solid #0000007a";
    shadingElement.style.borderRight = rightLeftBorderSize + "px solid #0000007a";
    shadingElement.style.borderTop = topBottomBorderSize + "px solid #0000007a";
    shadingElement.style.borderBottom = topBottomBorderSize + "px solid #0000007a";
    shadingElement.style.boxSizing = "border-box";
    shadingElement.style.top = "0px";
    shadingElement.style.bottom = "0px";
    shadingElement.style.left = "0px";
    shadingElement.style.right = "0px";
    shadingElement.id = "" + Constants.SHADED_REGION_ELEMENT_ID;
    if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {
      this.hasBorderShaders = false;
    } else {
      var smallSize = 5;
      var largeSize = 40;
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, 0, false);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, qrboxSize.height + smallSize, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, qrboxSize.height + smallSize, 0, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, qrboxSize.height + smallSize - largeSize, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, -smallSize, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, qrboxSize.height + smallSize - largeSize, -smallSize, false);
      this.hasBorderShaders = true;
    }
    element.append(shadingElement);
  };
  Html5Qrcode2.prototype.insertShaderBorders = function(shaderElem, width, height, top, side, isLeft) {
    var elem = document.createElement("div");
    elem.style.position = "absolute";
    elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;
    elem.style.width = width + "px";
    elem.style.height = height + "px";
    elem.style.top = top + "px";
    if (isLeft) {
      elem.style.left = side + "px";
    } else {
      elem.style.right = side + "px";
    }
    if (!this.borderShaders) {
      this.borderShaders = [];
    }
    this.borderShaders.push(elem);
    shaderElem.appendChild(elem);
  };
  Html5Qrcode2.prototype.showPausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "block";
  };
  Html5Qrcode2.prototype.hidePausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "none";
  };
  Html5Qrcode2.prototype.getTimeoutFps = function(fps) {
    return 1e3 / fps;
  };
  return Html5Qrcode2;
}();
var Html5QrcodeScannerStatus;
(function(Html5QrcodeScannerStatus2) {
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_DEFAULT"] = 0] = "STATUS_DEFAULT";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_SUCCESS"] = 1] = "STATUS_SUCCESS";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_WARNING"] = 2] = "STATUS_WARNING";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_REQUESTING_PERMISSION"] = 3] = "STATUS_REQUESTING_PERMISSION";
})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));
const _hoisted_1$2 = /* @__PURE__ */ createStaticVNode('<path d="M0 .5A.5.5 0 0 1 .5 0h3a.5.5 0 0 1 0 1H1v2.5a.5.5 0 0 1-1 0v-3Zm12 0a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-1 0V1h-2.5a.5.5 0 0 1-.5-.5ZM.5 12a.5.5 0 0 1 .5.5V15h2.5a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5Zm15 0a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1 0-1H15v-2.5a.5.5 0 0 1 .5-.5ZM4 4h1v1H4V4Z"></path><path d="M7 2H2v5h5V2ZM3 3h3v3H3V3Zm2 8H4v1h1v-1Z"></path><path d="M7 9H2v5h5V9Zm-4 1h3v3H3v-3Zm8-6h1v1h-1V4Z"></path><path d="M9 2h5v5H9V2Zm1 1v3h3V3h-3ZM8 8v2h1v1H8v1h2v-2h1v2h1v-1h2v-1h-3V8H8Zm2 2H9V9h1v1Zm4 2h-1v1h-2v1h3v-2Zm-4 2v-1H8v1h2Z"></path><path d="M12 9h2V8h-2v1Z"></path>', 5);
const _hoisted_6$1 = [
  _hoisted_1$2
];
const _hoisted_7$1 = /* @__PURE__ */ createBaseVNode("div", { id: "reader" }, null, -1);
const _sfc_main$3 = {
  __name: "ScanQrcode",
  props: {
    expected: Array,
    qrbox: {
      type: Number,
      default: 250
    },
    fps: {
      type: Number,
      default: 10
    }
  },
  emits: ["resultat"],
  setup(__props, { emit: emits }) {
    const props = __props;
    let html5QrCode;
    function stopScanQrCode() {
      html5QrCode.stop().then((ignore) => {
        console.log("QR Code scanning stopped.");
      }).catch((err) => {
        console.log("Unable to stop scanning.");
      });
    }
    function onScanSuccess(qrCodeMessage, decodedResult) {
      console.log("-> fonc onScanSuccess, qrCodeMessage =", qrCodeMessage);
      if (props.expected.includes(qrCodeMessage) === true) {
        emits("resultat", qrCodeMessage);
        stopScanQrCode();
      }
    }
    function scanQrCode() {
      console.log("-> lecteur qrCode lanc\xE9 !");
      document.querySelector("#bt-scan").style.display = "none";
      html5QrCode = new Html5Qrcode("reader");
      const config = { fps: 10, qrbox: { width: 250, height: 250 } };
      html5QrCode.start({ facingMode: "environment" }, config, onScanSuccess);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        (openBlock(), createElementBlock("svg", {
          id: "bt-scan",
          onClick: _cache[0] || (_cache[0] = ($event) => scanQrCode()),
          xmlns: "http://www.w3.org/2000/svg",
          width: "75",
          height: "75",
          color: "white",
          fill: "currentColor",
          class: "bi bi-qr-code-scan",
          viewBox: "0 0 16 16"
        }, _hoisted_6$1)),
        _hoisted_7$1
      ], 64);
    };
  }
};
try {
  self["workbox:window:6.5.3"] && _();
} catch (n2) {
}
function n(n2, t2) {
  return new Promise(function(r2) {
    var e2 = new MessageChannel();
    e2.port1.onmessage = function(n3) {
      r2(n3.data);
    }, n2.postMessage(t2, [e2.port2]);
  });
}
function t(n2, t2) {
  for (var r2 = 0; r2 < t2.length; r2++) {
    var e2 = t2[r2];
    e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(n2, e2.key, e2);
  }
}
function r(n2, t2) {
  (null == t2 || t2 > n2.length) && (t2 = n2.length);
  for (var r2 = 0, e2 = new Array(t2); r2 < t2; r2++)
    e2[r2] = n2[r2];
  return e2;
}
function e(n2, t2) {
  var e2;
  if ("undefined" == typeof Symbol || null == n2[Symbol.iterator]) {
    if (Array.isArray(n2) || (e2 = function(n3, t3) {
      if (n3) {
        if ("string" == typeof n3)
          return r(n3, t3);
        var e3 = Object.prototype.toString.call(n3).slice(8, -1);
        return "Object" === e3 && n3.constructor && (e3 = n3.constructor.name), "Map" === e3 || "Set" === e3 ? Array.from(n3) : "Arguments" === e3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3) ? r(n3, t3) : void 0;
      }
    }(n2)) || t2 && n2 && "number" == typeof n2.length) {
      e2 && (n2 = e2);
      var i2 = 0;
      return function() {
        return i2 >= n2.length ? { done: true } : { done: false, value: n2[i2++] };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  return (e2 = n2[Symbol.iterator]()).next.bind(e2);
}
try {
  self["workbox:core:6.5.3"] && _();
} catch (n2) {
}
var i = function() {
  var n2 = this;
  this.promise = new Promise(function(t2, r2) {
    n2.resolve = t2, n2.reject = r2;
  });
};
function o(n2, t2) {
  var r2 = location.href;
  return new URL(n2, r2).href === new URL(t2, r2).href;
}
var u = function(n2, t2) {
  this.type = n2, Object.assign(this, t2);
};
function a(n2, t2, r2) {
  return r2 ? t2 ? t2(n2) : n2 : (n2 && n2.then || (n2 = Promise.resolve(n2)), t2 ? n2.then(t2) : n2);
}
function c() {
}
var f = { type: "SKIP_WAITING" };
function s(n2, t2) {
  if (!t2)
    return n2 && n2.then ? n2.then(c) : Promise.resolve();
}
var v = function(r2) {
  var e2, c2;
  function v2(n2, t2) {
    var e3, c3;
    return void 0 === t2 && (t2 = {}), (e3 = r2.call(this) || this).nn = {}, e3.tn = 0, e3.rn = new i(), e3.en = new i(), e3.on = new i(), e3.un = 0, e3.an = /* @__PURE__ */ new Set(), e3.cn = function() {
      var n3 = e3.fn, t3 = n3.installing;
      e3.tn > 0 || !o(t3.scriptURL, e3.sn.toString()) || performance.now() > e3.un + 6e4 ? (e3.vn = t3, n3.removeEventListener("updatefound", e3.cn)) : (e3.hn = t3, e3.an.add(t3), e3.rn.resolve(t3)), ++e3.tn, t3.addEventListener("statechange", e3.ln);
    }, e3.ln = function(n3) {
      var t3 = e3.fn, r3 = n3.target, i2 = r3.state, o2 = r3 === e3.vn, a2 = { sw: r3, isExternal: o2, originalEvent: n3 };
      !o2 && e3.mn && (a2.isUpdate = true), e3.dispatchEvent(new u(i2, a2)), "installed" === i2 ? e3.wn = self.setTimeout(function() {
        "installed" === i2 && t3.waiting === r3 && e3.dispatchEvent(new u("waiting", a2));
      }, 200) : "activating" === i2 && (clearTimeout(e3.wn), o2 || e3.en.resolve(r3));
    }, e3.dn = function(n3) {
      var t3 = e3.hn, r3 = t3 !== navigator.serviceWorker.controller;
      e3.dispatchEvent(new u("controlling", { isExternal: r3, originalEvent: n3, sw: t3, isUpdate: e3.mn })), r3 || e3.on.resolve(t3);
    }, e3.gn = (c3 = function(n3) {
      var t3 = n3.data, r3 = n3.ports, i2 = n3.source;
      return a(e3.getSW(), function() {
        e3.an.has(i2) && e3.dispatchEvent(new u("message", { data: t3, originalEvent: n3, ports: r3, sw: i2 }));
      });
    }, function() {
      for (var n3 = [], t3 = 0; t3 < arguments.length; t3++)
        n3[t3] = arguments[t3];
      try {
        return Promise.resolve(c3.apply(this, n3));
      } catch (n4) {
        return Promise.reject(n4);
      }
    }), e3.sn = n2, e3.nn = t2, navigator.serviceWorker.addEventListener("message", e3.gn), e3;
  }
  c2 = r2, (e2 = v2).prototype = Object.create(c2.prototype), e2.prototype.constructor = e2, e2.__proto__ = c2;
  var h2, l, w = v2.prototype;
  return w.register = function(n2) {
    var t2 = (void 0 === n2 ? {} : n2).immediate, r3 = void 0 !== t2 && t2;
    try {
      var e3 = this;
      return function(n3, t3) {
        var r4 = n3();
        if (r4 && r4.then)
          return r4.then(t3);
        return t3(r4);
      }(function() {
        if (!r3 && "complete" !== document.readyState)
          return s(new Promise(function(n3) {
            return window.addEventListener("load", n3);
          }));
      }, function() {
        return e3.mn = Boolean(navigator.serviceWorker.controller), e3.yn = e3.pn(), a(e3.bn(), function(n3) {
          e3.fn = n3, e3.yn && (e3.hn = e3.yn, e3.en.resolve(e3.yn), e3.on.resolve(e3.yn), e3.yn.addEventListener("statechange", e3.ln, { once: true }));
          var t3 = e3.fn.waiting;
          return t3 && o(t3.scriptURL, e3.sn.toString()) && (e3.hn = t3, Promise.resolve().then(function() {
            e3.dispatchEvent(new u("waiting", { sw: t3, wasWaitingBeforeRegister: true }));
          }).then(function() {
          })), e3.hn && (e3.rn.resolve(e3.hn), e3.an.add(e3.hn)), e3.fn.addEventListener("updatefound", e3.cn), navigator.serviceWorker.addEventListener("controllerchange", e3.dn), e3.fn;
        });
      });
    } catch (n3) {
      return Promise.reject(n3);
    }
  }, w.update = function() {
    try {
      return this.fn ? s(this.fn.update()) : void 0;
    } catch (n2) {
      return Promise.reject(n2);
    }
  }, w.getSW = function() {
    return void 0 !== this.hn ? Promise.resolve(this.hn) : this.rn.promise;
  }, w.messageSW = function(t2) {
    try {
      return a(this.getSW(), function(r3) {
        return n(r3, t2);
      });
    } catch (n2) {
      return Promise.reject(n2);
    }
  }, w.messageSkipWaiting = function() {
    this.fn && this.fn.waiting && n(this.fn.waiting, f);
  }, w.pn = function() {
    var n2 = navigator.serviceWorker.controller;
    return n2 && o(n2.scriptURL, this.sn.toString()) ? n2 : void 0;
  }, w.bn = function() {
    try {
      var n2 = this;
      return function(n3, t2) {
        try {
          var r3 = n3();
        } catch (n4) {
          return t2(n4);
        }
        if (r3 && r3.then)
          return r3.then(void 0, t2);
        return r3;
      }(function() {
        return a(navigator.serviceWorker.register(n2.sn, n2.nn), function(t2) {
          return n2.un = performance.now(), t2;
        });
      }, function(n3) {
        throw n3;
      });
    } catch (n3) {
      return Promise.reject(n3);
    }
  }, h2 = v2, (l = [{ key: "active", get: function() {
    return this.en.promise;
  } }, { key: "controlling", get: function() {
    return this.on.promise;
  } }]) && t(h2.prototype, l), v2;
}(function() {
  function n2() {
    this.Pn = /* @__PURE__ */ new Map();
  }
  var t2 = n2.prototype;
  return t2.addEventListener = function(n3, t3) {
    this.Sn(n3).add(t3);
  }, t2.removeEventListener = function(n3, t3) {
    this.Sn(n3).delete(t3);
  }, t2.dispatchEvent = function(n3) {
    n3.target = this;
    for (var t3, r2 = e(this.Sn(n3.type)); !(t3 = r2()).done; ) {
      (0, t3.value)(n3);
    }
  }, t2.Sn = function(n3) {
    return this.Pn.has(n3) || this.Pn.set(n3, /* @__PURE__ */ new Set()), this.Pn.get(n3);
  }, n2;
}());
function registerSW(options = {}) {
  const {
    immediate = false,
    onNeedRefresh,
    onOfflineReady,
    onRegistered,
    onRegisterError
  } = options;
  let wb;
  let registration;
  const updateServiceWorker = async (reloadPage = true) => {
    {
      if (reloadPage) {
        wb == null ? void 0 : wb.addEventListener("controlling", (event) => {
          if (event.isUpdate)
            window.location.reload();
        });
      }
      if (registration && registration.waiting) {
        await n(registration.waiting, { type: "SKIP_WAITING" });
      }
    }
  };
  if ("serviceWorker" in navigator) {
    wb = new v("/serviceWorker.js", { scope: "/", type: "classic" });
    wb.addEventListener("activated", (event) => {
      if (event.isUpdate)
        ;
      else
        onOfflineReady == null ? void 0 : onOfflineReady();
    });
    {
      const showSkipWaitingPrompt = () => {
        onNeedRefresh == null ? void 0 : onNeedRefresh();
      };
      wb.addEventListener("waiting", showSkipWaitingPrompt);
      wb.addEventListener("externalwaiting", showSkipWaitingPrompt);
    }
    wb.register({ immediate }).then((r2) => {
      registration = r2;
      onRegistered == null ? void 0 : onRegistered(r2);
    }).catch((e2) => {
      onRegisterError == null ? void 0 : onRegisterError(e2);
    });
  }
  return updateServiceWorker;
}
function useRegisterSW(options = {}) {
  const {
    immediate = true,
    onNeedRefresh,
    onOfflineReady,
    onRegistered,
    onRegisterError
  } = options;
  const needRefresh = ref(false);
  const offlineReady = ref(false);
  const updateServiceWorker = registerSW({
    immediate,
    onNeedRefresh() {
      needRefresh.value = true;
      onNeedRefresh == null ? void 0 : onNeedRefresh();
    },
    onOfflineReady() {
      offlineReady.value = true;
      onOfflineReady == null ? void 0 : onOfflineReady();
    },
    onRegistered,
    onRegisterError
  });
  return {
    updateServiceWorker,
    offlineReady,
    needRefresh
  };
}
const _hoisted_1$1 = {
  key: 0,
  class: "flex flex-wrap md:flex-nowrap bg-pink-900 text-white text-sm px-6 py-2 justify-between align-middle",
  role: "alert"
};
const _hoisted_2$1 = { class: "message mt-1" };
const _hoisted_3$1 = { key: 0 };
const _hoisted_4$1 = { key: 1 };
const _hoisted_5$1 = { class: "buttons flex align-middle mt-2 md:mt-0" };
const _sfc_main$2 = {
  __name: "ReloadPWA",
  setup(__props) {
    const { offlineReady, needRefresh, updateServiceWorker } = useRegisterSW();
    const close = async () => {
      offlineReady.value = false;
      needRefresh.value = false;
    };
    const updateCache = async () => {
      await updateServiceWorker();
    };
    return (_ctx, _cache) => {
      return unref(offlineReady) || unref(needRefresh) ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2$1, [
          unref(offlineReady) ? (openBlock(), createElementBlock("span", _hoisted_3$1, " Application pr\xEAte \xE0 fonctionner hors ligne ")) : (openBlock(), createElementBlock("span", _hoisted_4$1, "Il y a des changement dans l'application, cliquer pour la mise \xE0 jour."))
        ]),
        createBaseVNode("div", _hoisted_5$1, [
          unref(needRefresh) ? (openBlock(), createElementBlock("button", {
            key: 0,
            onClick: _cache[0] || (_cache[0] = ($event) => updateCache()),
            class: "w-full px-4 py-2 text-sm text-white leading-none transition-colors duration-150 bg-pink-900 border border-white rounded sm:w-auto active:bg-pink-600 hover:bg-pink-700 focus:outline-none focus:shadow-outline-purple mr-4"
          }, " Mise \xE0 jour ")) : createCommentVNode("", true),
          createBaseVNode("button", {
            onClick: close,
            class: "w-full px-4 py-2 text-sm text-white leading-none transition-colors duration-150 bg-pink-900 border border-white rounded sm:w-auto active:bg-pink-600 hover:bg-pink-700 focus:outline-none focus:shadow-outline-purple"
          }, " Fermer ")
        ])
      ])) : createCommentVNode("", true);
    };
  }
};
const backgroundImage = "/assets/Chris-Haga-premiere-page.60ec30cd.jpg";
const backgroundImageOne = "/assets/one-800x421.4f7f6b26.jpg";
const oiseau = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAoCAIAAAAQS2/OAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH5ggZEgYuhIbcvAAACPhJREFUSMeVV1twG9UZPpfdldaSVpZkyxeFWHZk2cExNoQGYgdMXAJJpqXxwDRA2wc6vDGd6XSGTplOaeAZUjp9bJsmJSQDDAMDg3GEKaYQO7Fz8UV3X2JdbK8ky9Ztpd3V7p4+CFwXfKH/05nZf8/3/9/5r4B8I5qmSZK0cSabRFGUyuHmzZt3Fhdff/3s7Ozsd9W2FAQAUBRlfn5ekqSJiYlcLufz+SCEhBDwjWCM4/G4KIqrSf7M738XWZi9dOkSAGCzznaCAAAURQ0NDU1PT5fLZa/Xe+3atcrPlf+j0ej777+/srL8yitnKJriOG5ubvbGjetzs7MIIU3TdgEYGxsLBALHjh0bHR21Wq2xWEyW5c0a9fX1Xq/34pv/dO1r8XiGFQKtNbX5XGZo6JNdzQcAIAjhxYsXHQ6H1Wr1+/2EkEgkoqoqQghCKAgChPC3L77Y3t4+MjLS1LQ3m80WCgWHwzF69Woum0MI7UwUcrvbFFXyeAbdrfuWlmIYwVx2PRqNVD77fd4/vvyH4WFPT0/PiRMnxsbGrFYLAEBRtGQqOTExDgDYmSVUFASKwsFgIJ/PcyaTTsc4nU0T4+MAgLW1tdu3byMEh4eH33nnHVmWBwYGlpaW9Ho9AJBhGI/nCgAAQrgTwOcjnzudzYqizs7OGo1Gv9/f0rLP7/cDANbX18PhMEKouroaQjg+Ps7z/PHjx7PZLMbYbOZCoVAkEtmZJfzss09P3p5sbm4pCsViqYgxhhDSNJPL551OZyS6qCplSZIEQaBpOh5f0jTNZDItLy8DQLLZfENDQ0dHh6ZpCKGtPXA6nR0dHV6v12gyUhRVLpdjsVh1dXUwGBwdHUUISZLc3t7e3d1NCBGEwsLCgiAIFotFUVSE0fXr13dmCff39wtCqbGhgedXVFVtbm6uqamJx2PV1eb5+TmMUDqdTiaTJpPp4MGDGOPFxUVRFCuXapqSzaw/0tfPcRwhZEsY1N6+P51eEyWppaXFbDb7fL5sNut2u0ulEmcyLS8vd3d319fX37lzx+PxOByOJ598EkKYSqUIIVVVbKlU/Gx4GGyf1fiNN94Ih0OiKNIUxXGczWaLx+PhcNhms9lsNlEUV1dXOY6rUDw2NlYulx999NFCocDzPMuyVqttbm7++IkTDMNsDfDqq68qinLlyhV+ZSWfLxQKeZvNRlFUNptFCNfV1QUCAVEUHQ6HLMt6vT4YDAYCgZ6eHkmSMpkMx3GpVPLw4R6bzaZp2ndZohBCXV1dLpcrGrmTSiUZhhEEQZKk2tpaSRKzWdLb2zs9PS0Iwv79+0VRpCiK5/mRkRGXy5XP50OhkMvVajIZt3tquAF7/vz5hYWFZDIhy1I+n1cVhWVZk8nU1tZWKpVqa2tjsZiiKG63O5lMrqys5HK5YDBot9v37LnrtdfP6nS6zc+wAUZVToqi2O32UCi0Z48jn89bLJYqlpVluVQqFYvFYrEoiuLp06enpqYWFxcBAIIg5LK5F154IRqNTk5OrqXTDY2N3/KgElewUpYhhLIsBwKBzz77NJlMVVWxqqJUDBFFkRBiMBgghAMDA8lU6t23384Xci+9/PKt8Zt//9tfpXL54P0/+PNrZ8uQFPM5sVgkgGlstEOECCFfN5aNKOZ5fnBwcGxsVCjkKYoihMiyLEkSwzA0TXd1dZ06dWp1NeW7MUGU8uDgB0gpMzQtavjQE8/YrOb1jAQBAXrAYu6J471Ox57/dq6vOxxC0Wj0woXz01OTPM8jhHQ6HUVRDMO43W6KogRBePqZZ4iqRq68rV+6ztKY0khRVz/j7Oe4OkQKVC6RXeKrmmoW0/ClX/8KnzlzZuNZKk6Yzea+vr4jvUeanM76uob1TEZTidPZxOh0FARiSVxaShw6eA/IxMhqQg80PcJQSie4Vn0Vdk9dMCW8yfico7huNhurbRzcMgM35/3yyop3Znrok0FRlIxGI59IQdZ076FDLkYE/n+xqXmaomRYvmXshu4j+71v2UtrKoWuync1NDeb6urgdim+0ZMrORwM+j/5+MPwXARytXfv26OsRA1ri/WlmBHJEEAAQZHQkbZ+aKytGn9PVrWa+47GUnlDYxPcdTIgRFNUQlM4NBe+/NFIA0nVBj41YkWPZKQRFTAAEEI0SFSAmRu2B9sfPvbg/YfMFutaKqmqGgV2EwgRhTVZloY8XzlygZbEDT2SVQBVAlWIoaYRAChGj4k6l8gdfuKhnseOV+yy2+0AgN0BiKZBhHxzc2L4WifxI01WiEYw0FSoEY3WsXpdlUazoVTe8dRvek6c2hgYKtzsDgAgBAB8OexxZSYKFCrKoLHWIpQkA6OxVvt6CSdKtH7vgd7nnnK72wghGOPN1WIXgEo4ReN8MnS7XKAwqnLeVbeCaIMZGzjI54jc2HLPDwfaOrsQAKomY/Ttov29AG5cHw0vr3dZ7acfuPtWUoaMyYoykxnF5L63o7Pbtb8dAUA09bu37w6AECqXlampm1pZOvDAya/WE0KNs+fufef/dJYQhOYTc0MfHvjRUz/5xXMAbN2W0Q63VyYqn2/G652Guqq/vOvJVDVBDXzg+ZJrcj342OOP9D9uNaD4wiwAQN1m/NrJA4SQCsDHH38klUoaABiAZ386kM3l4vH4Q4/0UpD5wuMJjVJLvpmbt24dvO++LYeXbT1QVRUA8O8vvrg6Oqpj2dXV9JGHHrbX1bW2th49ehRBplgUfMHpzh//zGh3BPx+sE1H29qDSrSl0+k3L/xDUzWhKOtZ0+HDPQAARVEqYa5n2dM//2UkEj35dP2BAwcEQTAYDN8XQNM0jPHFi2+Fw2GTySRJ0t69e1vdrQCAyugHAAAE2KzWarNZ0zSaprflebvbJyYmLl++xLIGi8WKMWWxWGpqajarVXIVY0zT9A4FbQsPKgaeO3dOr9d3dnbabDaaplmWrZi5meiN8w6j47erqaqqGONz587NzMycPHmyWCxijPv6+iCElbYM/l/ZvBFWtsZEIvH888/zPC/LcqFQKJfLu66SO8j/AKiqSggZHBwMBAKbt9fvs65uJ/8BQMyzbVU0X4QAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjItMDgtMjVUMTg6MDY6MzUrMDA6MDCTrZU+AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIyLTA4LTI1VDE4OjA2OjM1KzAwOjAw4vAtggAAAABJRU5ErkJggg==";
const attrs = {
  width: "1em",
  height: "1em",
  viewBox: "0 0 16 16",
  fill: "currentColor",
  role: "img",
  focusable: "false"
};
function genIcon(name, svgContent) {
  return {
    name,
    render() {
      return h("svg", Object.assign(Object.assign({}, attrs), { innerHTML: svgContent }));
    }
  };
}
const BIconArrowDown = /* @__PURE__ */ genIcon("BIconArrowDown", '<path fill-rule="evenodd" d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"/>');
const BIconHouseFill = /* @__PURE__ */ genIcon("BIconHouseFill", '<path fill-rule="evenodd" d="m8 3.293 6 6V13.5a1.5 1.5 0 0 1-1.5 1.5h-9A1.5 1.5 0 0 1 2 13.5V9.293l6-6zm5-.793V6l-2-2V2.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5z"/><path fill-rule="evenodd" d="M7.293 1.5a1 1 0 0 1 1.414 0l6.647 6.646a.5.5 0 0 1-.708.708L8 2.207 1.354 8.854a.5.5 0 1 1-.708-.708L7.293 1.5z"/>');
const Accueil_vue_vue_type_style_index_0_lang = "";
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_2 = { style: { "margin-top": "130px" } };
const _hoisted_3 = { class: "d-flex flex-row justify-content-center align-items-center mt-2" };
const _hoisted_4 = ["src"];
const _hoisted_5 = ["src"];
const _hoisted_6 = ["src"];
const _hoisted_7 = ["src"];
const _hoisted_8 = ["src"];
const _hoisted_9 = { class: "mt-5" };
const _hoisted_10 = { href: "#one" };
const _hoisted_11 = {
  type: "button",
  class: "btn bg-transparent",
  style: { "font-size": "25px", "border-color": "white", "color": "white" }
};
const _hoisted_12 = /* @__PURE__ */ createStaticVNode('<div class="content-style2"><div class="slide-right"><header><h2>Les compositions</h2></header></div><div class="line fade-in"></div><div class="slide-left"><p> Aux sons du jardin :<br> Parce qu\u2019il est peupl\xE9 d\u2019esp\xE8ces v\xE9g\xE9tales et animales singuli\xE8res, chaque jardin a son chant qui lui est propre, ses m\xE9lodies qui varient en fonction de la m\xE9t\xE9o, de la saison, des essences qui y ont \xE9lu domicile. Chaque jardin a sa propre signature acoustique. Et si, avec humilit\xE9, avec nos instruments, nous nous invitions sur cette sc\xE8ne pour faire d\xE9couvrir cette singularit\xE9, et en tirer une cr\xE9ation originale.<br><br> Fiche technique:<br><br> Compositeur, prises de sons au Jardin, musicien, arrangeur: Chris Hag\xE1 <br> Ing\xE9nieur son, prises de sons instruments et voix en studio: Letoyo <br> Mix\xE9 et masteuris\xE9 par Letoyo au Studio Play Hit Up <br> Artistes invit\xE9s : Sami Pageaux Waro, Julia Colmet <br> D\xE9veloppement de l\u2019application <q>Aux sons du jardin</q>: Ti Billet. <br><br> R\xE9sidence <q>Patrimoine et cr\xE9ation</q> r\xE9alis\xE9e entre f\xE9vrier et septembre 2022<br> au Jardin Botanique Des Mascarins, subventionn\xE9e par le D\xE9partement R\xE9union. <br></p></div></div>', 1);
const _hoisted_13 = [
  _hoisted_12
];
const _sfc_main$1 = {
  __name: "Accueil",
  setup(__props) {
    const router2 = useRouter();
    const routesQrCode = [
      { code: "chp5", route: "/Page5" },
      { code: "chp4", route: "/Page4" },
      { code: "chp3", route: "/Page3" },
      { code: "chp2", route: "/Page2" },
      { code: "chp1", route: "/Page1" }
    ];
    let expected = [];
    for (let i2 = 0; i2 < routesQrCode.length; i2++) {
      expected.push(routesQrCode[i2].code);
    }
    function onScan(qrCodeMessage) {
      console.log("-> fonc onScan !");
      console.log("qrCodeMessage =", qrCodeMessage);
      const test = routesQrCode.find((obj) => obj.code === qrCodeMessage);
      if (test !== void 0) {
        console.log("-> route =", test.route);
        router2.push(test.route);
      } else {
        console.log("Qrcode non g\xE9r\xE9, inconnu !");
      }
      console.log("test =", test);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_sfc_main$2),
        createBaseVNode("section", {
          id: "intro",
          style: normalizeStyle({ backgroundImage: `url(${unref(backgroundImage)})` })
        }, [
          _hoisted_1,
          createBaseVNode("div", _hoisted_2, [
            createVNode(_sfc_main$3, {
              expected: unref(expected),
              qrbox: 250,
              fps: 10,
              style: { "width": "400px", "height": "400px" },
              onResultat: onScan
            }, null, 8, ["expected"]),
            createBaseVNode("div", _hoisted_3, [
              createBaseVNode("img", {
                src: unref(oiseau),
                class: "ms-1 me-1",
                role: "button",
                onClick: _cache[0] || (_cache[0] = ($event) => unref(router2).push("/Page1"))
              }, null, 8, _hoisted_4),
              createBaseVNode("img", {
                src: unref(oiseau),
                class: "ms-1 me-1",
                role: "button",
                onClick: _cache[1] || (_cache[1] = ($event) => unref(router2).push("/Page2"))
              }, null, 8, _hoisted_5),
              createBaseVNode("img", {
                src: unref(oiseau),
                class: "ms-1 me-1",
                role: "button",
                onClick: _cache[2] || (_cache[2] = ($event) => unref(router2).push("/Page3"))
              }, null, 8, _hoisted_6),
              createBaseVNode("img", {
                src: unref(oiseau),
                class: "ms-1 me-1",
                role: "button",
                onClick: _cache[3] || (_cache[3] = ($event) => unref(router2).push("/Page4"))
              }, null, 8, _hoisted_7),
              createBaseVNode("img", {
                src: unref(oiseau),
                class: "ms-1 me-1",
                role: "button",
                onClick: _cache[4] || (_cache[4] = ($event) => unref(router2).push("/Page5"))
              }, null, 8, _hoisted_8)
            ]),
            createBaseVNode("footer", _hoisted_9, [
              createBaseVNode("a", _hoisted_10, [
                createBaseVNode("button", _hoisted_11, [
                  createVNode(unref(BIconArrowDown))
                ])
              ])
            ])
          ])
        ], 4),
        createBaseVNode("section", {
          id: "one",
          class: "main style2 right dark fullscreen",
          style: normalizeStyle({ backgroundImage: `url(${unref(backgroundImageOne)})` })
        }, _hoisted_13, 4)
      ], 64);
    };
  }
};
const routes = [
  {
    path: "/",
    name: "Accueil",
    component: _sfc_main$1,
    alias: "/index.html"
  },
  {
    path: "/Page1",
    name: "Page1",
    component: () => __vitePreload(() => import(
      /* webpackChunkName: "Page1" */
      "./Page1.50aa698a.js"
    ), true ? ["assets/Page1.50aa698a.js","assets/Page1.469b1ba2.css","assets/_plugin-vue_export-helper.cdc0426e.js"] : void 0)
  },
  {
    path: "/Page2",
    name: "Page2",
    component: () => __vitePreload(() => import(
      /* webpackChunkName: "Page2" */
      "./Page2.b6df9e23.js"
    ), true ? ["assets/Page2.b6df9e23.js","assets/Page2.8a20a878.css","assets/_plugin-vue_export-helper.cdc0426e.js"] : void 0)
  },
  {
    path: "/Page3",
    name: "Page3",
    component: () => __vitePreload(() => import(
      /* webpackChunkName: "Page3" */
      "./Page3.aed799c4.js"
    ), true ? ["assets/Page3.aed799c4.js","assets/Page3.a9a6927d.css","assets/_plugin-vue_export-helper.cdc0426e.js"] : void 0)
  },
  {
    path: "/Page4",
    name: "Page4",
    component: () => __vitePreload(() => import(
      /* webpackChunkName: "Page4" */
      "./Page4.8a5e4565.js"
    ), true ? ["assets/Page4.8a5e4565.js","assets/Page4.64a9b74e.css","assets/_plugin-vue_export-helper.cdc0426e.js"] : void 0)
  },
  {
    path: "/Page5",
    name: "Page5",
    component: () => __vitePreload(() => import(
      /* webpackChunkName: "Page5" */
      "./Page5.9604bbd2.js"
    ), true ? ["assets/Page5.9604bbd2.js","assets/Page5.950a440f.css","assets/_plugin-vue_export-helper.cdc0426e.js"] : void 0)
  }
];
const router = createRouter({
  history: createWebHistory(),
  routes,
  scrollBehavior(to, from, savedPosition) {
    return {
      top: 0,
      behavior: "smooth"
    };
  }
});
const bootstrap_min = "";
/*!
  * Bootstrap v5.0.2 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function(t2, e2) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).bootstrap = e2();
}(globalThis, function() {
  const t2 = { find: (t3, e3 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e3, t3)), findOne: (t3, e3 = document.documentElement) => Element.prototype.querySelector.call(e3, t3), children: (t3, e3) => [].concat(...t3.children).filter((t4) => t4.matches(e3)), parents(t3, e3) {
    const i3 = [];
    let n3 = t3.parentNode;
    for (; n3 && n3.nodeType === Node.ELEMENT_NODE && 3 !== n3.nodeType; )
      n3.matches(e3) && i3.push(n3), n3 = n3.parentNode;
    return i3;
  }, prev(t3, e3) {
    let i3 = t3.previousElementSibling;
    for (; i3; ) {
      if (i3.matches(e3))
        return [i3];
      i3 = i3.previousElementSibling;
    }
    return [];
  }, next(t3, e3) {
    let i3 = t3.nextElementSibling;
    for (; i3; ) {
      if (i3.matches(e3))
        return [i3];
      i3 = i3.nextElementSibling;
    }
    return [];
  } }, e2 = (t3) => {
    do {
      t3 += Math.floor(1e6 * Math.random());
    } while (document.getElementById(t3));
    return t3;
  }, i2 = (t3) => {
    let e3 = t3.getAttribute("data-bs-target");
    if (!e3 || "#" === e3) {
      let i3 = t3.getAttribute("href");
      if (!i3 || !i3.includes("#") && !i3.startsWith("."))
        return null;
      i3.includes("#") && !i3.startsWith("#") && (i3 = "#" + i3.split("#")[1]), e3 = i3 && "#" !== i3 ? i3.trim() : null;
    }
    return e3;
  }, n2 = (t3) => {
    const e3 = i2(t3);
    return e3 && document.querySelector(e3) ? e3 : null;
  }, s2 = (t3) => {
    const e3 = i2(t3);
    return e3 ? document.querySelector(e3) : null;
  }, o2 = (t3) => {
    t3.dispatchEvent(new Event("transitionend"));
  }, r2 = (t3) => !(!t3 || "object" != typeof t3) && (void 0 !== t3.jquery && (t3 = t3[0]), void 0 !== t3.nodeType), a2 = (e3) => r2(e3) ? e3.jquery ? e3[0] : e3 : "string" == typeof e3 && e3.length > 0 ? t2.findOne(e3) : null, l = (t3, e3, i3) => {
    Object.keys(i3).forEach((n3) => {
      const s3 = i3[n3], o3 = e3[n3], a3 = o3 && r2(o3) ? "element" : null == (l2 = o3) ? "" + l2 : {}.toString.call(l2).match(/\s([a-z]+)/i)[1].toLowerCase();
      var l2;
      if (!new RegExp(s3).test(a3))
        throw new TypeError(`${t3.toUpperCase()}: Option "${n3}" provided type "${a3}" but expected type "${s3}".`);
    });
  }, c2 = (t3) => !(!r2(t3) || 0 === t3.getClientRects().length) && "visible" === getComputedStyle(t3).getPropertyValue("visibility"), h2 = (t3) => !t3 || t3.nodeType !== Node.ELEMENT_NODE || !!t3.classList.contains("disabled") || (void 0 !== t3.disabled ? t3.disabled : t3.hasAttribute("disabled") && "false" !== t3.getAttribute("disabled")), d = (t3) => {
    if (!document.documentElement.attachShadow)
      return null;
    if ("function" == typeof t3.getRootNode) {
      const e3 = t3.getRootNode();
      return e3 instanceof ShadowRoot ? e3 : null;
    }
    return t3 instanceof ShadowRoot ? t3 : t3.parentNode ? d(t3.parentNode) : null;
  }, u2 = () => {
  }, f2 = (t3) => t3.offsetHeight, p2 = () => {
    const { jQuery: t3 } = window;
    return t3 && !document.body.hasAttribute("data-bs-no-jquery") ? t3 : null;
  }, m = [], g = () => "rtl" === document.documentElement.dir, _2 = (t3) => {
    var e3;
    e3 = () => {
      const e4 = p2();
      if (e4) {
        const i3 = t3.NAME, n3 = e4.fn[i3];
        e4.fn[i3] = t3.jQueryInterface, e4.fn[i3].Constructor = t3, e4.fn[i3].noConflict = () => (e4.fn[i3] = n3, t3.jQueryInterface);
      }
    }, "loading" === document.readyState ? (m.length || document.addEventListener("DOMContentLoaded", () => {
      m.forEach((t4) => t4());
    }), m.push(e3)) : e3();
  }, b = (t3) => {
    "function" == typeof t3 && t3();
  }, v2 = (t3, e3, i3 = true) => {
    if (!i3)
      return void b(t3);
    const n3 = ((t4) => {
      if (!t4)
        return 0;
      let { transitionDuration: e4, transitionDelay: i4 } = window.getComputedStyle(t4);
      const n4 = Number.parseFloat(e4), s4 = Number.parseFloat(i4);
      return n4 || s4 ? (e4 = e4.split(",")[0], i4 = i4.split(",")[0], 1e3 * (Number.parseFloat(e4) + Number.parseFloat(i4))) : 0;
    })(e3) + 5;
    let s3 = false;
    const r3 = ({ target: i4 }) => {
      i4 === e3 && (s3 = true, e3.removeEventListener("transitionend", r3), b(t3));
    };
    e3.addEventListener("transitionend", r3), setTimeout(() => {
      s3 || o2(e3);
    }, n3);
  }, y = (t3, e3, i3, n3) => {
    let s3 = t3.indexOf(e3);
    if (-1 === s3)
      return t3[!i3 && n3 ? t3.length - 1 : 0];
    const o3 = t3.length;
    return s3 += i3 ? 1 : -1, n3 && (s3 = (s3 + o3) % o3), t3[Math.max(0, Math.min(s3, o3 - 1))];
  }, w = /[^.]*(?=\..*)\.|.*/, E = /\..*/, A = /::\d+$/, T = {};
  let O = 1;
  const C = { mouseenter: "mouseover", mouseleave: "mouseout" }, k = /^(mouseenter|mouseleave)/i, L = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function x(t3, e3) {
    return e3 && `${e3}::${O++}` || t3.uidEvent || O++;
  }
  function D(t3) {
    const e3 = x(t3);
    return t3.uidEvent = e3, T[e3] = T[e3] || {}, T[e3];
  }
  function S(t3, e3, i3 = null) {
    const n3 = Object.keys(t3);
    for (let s3 = 0, o3 = n3.length; s3 < o3; s3++) {
      const o4 = t3[n3[s3]];
      if (o4.originalHandler === e3 && o4.delegationSelector === i3)
        return o4;
    }
    return null;
  }
  function I(t3, e3, i3) {
    const n3 = "string" == typeof e3, s3 = n3 ? i3 : e3;
    let o3 = M(t3);
    return L.has(o3) || (o3 = t3), [n3, s3, o3];
  }
  function N(t3, e3, i3, n3, s3) {
    if ("string" != typeof e3 || !t3)
      return;
    if (i3 || (i3 = n3, n3 = null), k.test(e3)) {
      const t4 = (t5) => function(e4) {
        if (!e4.relatedTarget || e4.relatedTarget !== e4.delegateTarget && !e4.delegateTarget.contains(e4.relatedTarget))
          return t5.call(this, e4);
      };
      n3 ? n3 = t4(n3) : i3 = t4(i3);
    }
    const [o3, r3, a3] = I(e3, i3, n3), l2 = D(t3), c3 = l2[a3] || (l2[a3] = {}), h3 = S(c3, r3, o3 ? i3 : null);
    if (h3)
      return void (h3.oneOff = h3.oneOff && s3);
    const d2 = x(r3, e3.replace(w, "")), u3 = o3 ? function(t4, e4, i4) {
      return function n4(s4) {
        const o4 = t4.querySelectorAll(e4);
        for (let { target: r4 } = s4; r4 && r4 !== this; r4 = r4.parentNode)
          for (let a4 = o4.length; a4--; )
            if (o4[a4] === r4)
              return s4.delegateTarget = r4, n4.oneOff && P.off(t4, s4.type, e4, i4), i4.apply(r4, [s4]);
        return null;
      };
    }(t3, i3, n3) : function(t4, e4) {
      return function i4(n4) {
        return n4.delegateTarget = t4, i4.oneOff && P.off(t4, n4.type, e4), e4.apply(t4, [n4]);
      };
    }(t3, i3);
    u3.delegationSelector = o3 ? i3 : null, u3.originalHandler = r3, u3.oneOff = s3, u3.uidEvent = d2, c3[d2] = u3, t3.addEventListener(a3, u3, o3);
  }
  function j(t3, e3, i3, n3, s3) {
    const o3 = S(e3[i3], n3, s3);
    o3 && (t3.removeEventListener(i3, o3, Boolean(s3)), delete e3[i3][o3.uidEvent]);
  }
  function M(t3) {
    return t3 = t3.replace(E, ""), C[t3] || t3;
  }
  const P = { on(t3, e3, i3, n3) {
    N(t3, e3, i3, n3, false);
  }, one(t3, e3, i3, n3) {
    N(t3, e3, i3, n3, true);
  }, off(t3, e3, i3, n3) {
    if ("string" != typeof e3 || !t3)
      return;
    const [s3, o3, r3] = I(e3, i3, n3), a3 = r3 !== e3, l2 = D(t3), c3 = e3.startsWith(".");
    if (void 0 !== o3) {
      if (!l2 || !l2[r3])
        return;
      return void j(t3, l2, r3, o3, s3 ? i3 : null);
    }
    c3 && Object.keys(l2).forEach((i4) => {
      !function(t4, e4, i5, n4) {
        const s4 = e4[i5] || {};
        Object.keys(s4).forEach((o4) => {
          if (o4.includes(n4)) {
            const n5 = s4[o4];
            j(t4, e4, i5, n5.originalHandler, n5.delegationSelector);
          }
        });
      }(t3, l2, i4, e3.slice(1));
    });
    const h3 = l2[r3] || {};
    Object.keys(h3).forEach((i4) => {
      const n4 = i4.replace(A, "");
      if (!a3 || e3.includes(n4)) {
        const e4 = h3[i4];
        j(t3, l2, r3, e4.originalHandler, e4.delegationSelector);
      }
    });
  }, trigger(t3, e3, i3) {
    if ("string" != typeof e3 || !t3)
      return null;
    const n3 = p2(), s3 = M(e3), o3 = e3 !== s3, r3 = L.has(s3);
    let a3, l2 = true, c3 = true, h3 = false, d2 = null;
    return o3 && n3 && (a3 = n3.Event(e3, i3), n3(t3).trigger(a3), l2 = !a3.isPropagationStopped(), c3 = !a3.isImmediatePropagationStopped(), h3 = a3.isDefaultPrevented()), r3 ? (d2 = document.createEvent("HTMLEvents"), d2.initEvent(s3, l2, true)) : d2 = new CustomEvent(e3, { bubbles: l2, cancelable: true }), void 0 !== i3 && Object.keys(i3).forEach((t4) => {
      Object.defineProperty(d2, t4, { get: () => i3[t4] });
    }), h3 && d2.preventDefault(), c3 && t3.dispatchEvent(d2), d2.defaultPrevented && void 0 !== a3 && a3.preventDefault(), d2;
  } }, H = /* @__PURE__ */ new Map();
  var R = { set(t3, e3, i3) {
    H.has(t3) || H.set(t3, /* @__PURE__ */ new Map());
    const n3 = H.get(t3);
    n3.has(e3) || 0 === n3.size ? n3.set(e3, i3) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n3.keys())[0]}.`);
  }, get: (t3, e3) => H.has(t3) && H.get(t3).get(e3) || null, remove(t3, e3) {
    if (!H.has(t3))
      return;
    const i3 = H.get(t3);
    i3.delete(e3), 0 === i3.size && H.delete(t3);
  } };
  class B {
    constructor(t3) {
      (t3 = a2(t3)) && (this._element = t3, R.set(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      R.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t3) => {
        this[t3] = null;
      });
    }
    _queueCallback(t3, e3, i3 = true) {
      v2(t3, e3, i3);
    }
    static getInstance(t3) {
      return R.get(t3, this.DATA_KEY);
    }
    static getOrCreateInstance(t3, e3 = {}) {
      return this.getInstance(t3) || new this(t3, "object" == typeof e3 ? e3 : null);
    }
    static get VERSION() {
      return "5.0.2";
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    static get DATA_KEY() {
      return "bs." + this.NAME;
    }
    static get EVENT_KEY() {
      return "." + this.DATA_KEY;
    }
  }
  class W extends B {
    static get NAME() {
      return "alert";
    }
    close(t3) {
      const e3 = t3 ? this._getRootElement(t3) : this._element, i3 = this._triggerCloseEvent(e3);
      null === i3 || i3.defaultPrevented || this._removeElement(e3);
    }
    _getRootElement(t3) {
      return s2(t3) || t3.closest(".alert");
    }
    _triggerCloseEvent(t3) {
      return P.trigger(t3, "close.bs.alert");
    }
    _removeElement(t3) {
      t3.classList.remove("show");
      const e3 = t3.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(t3), t3, e3);
    }
    _destroyElement(t3) {
      t3.remove(), P.trigger(t3, "closed.bs.alert");
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = W.getOrCreateInstance(this);
        "close" === t3 && e3[t3](this);
      });
    }
    static handleDismiss(t3) {
      return function(e3) {
        e3 && e3.preventDefault(), t3.close(this);
      };
    }
  }
  P.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', W.handleDismiss(new W())), _2(W);
  class q extends B {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = q.getOrCreateInstance(this);
        "toggle" === t3 && e3[t3]();
      });
    }
  }
  function z(t3) {
    return "true" === t3 || "false" !== t3 && (t3 === Number(t3).toString() ? Number(t3) : "" === t3 || "null" === t3 ? null : t3);
  }
  function $(t3) {
    return t3.replace(/[A-Z]/g, (t4) => "-" + t4.toLowerCase());
  }
  P.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (t3) => {
    t3.preventDefault();
    const e3 = t3.target.closest('[data-bs-toggle="button"]');
    q.getOrCreateInstance(e3).toggle();
  }), _2(q);
  const U = { setDataAttribute(t3, e3, i3) {
    t3.setAttribute("data-bs-" + $(e3), i3);
  }, removeDataAttribute(t3, e3) {
    t3.removeAttribute("data-bs-" + $(e3));
  }, getDataAttributes(t3) {
    if (!t3)
      return {};
    const e3 = {};
    return Object.keys(t3.dataset).filter((t4) => t4.startsWith("bs")).forEach((i3) => {
      let n3 = i3.replace(/^bs/, "");
      n3 = n3.charAt(0).toLowerCase() + n3.slice(1, n3.length), e3[n3] = z(t3.dataset[i3]);
    }), e3;
  }, getDataAttribute: (t3, e3) => z(t3.getAttribute("data-bs-" + $(e3))), offset(t3) {
    const e3 = t3.getBoundingClientRect();
    return { top: e3.top + document.body.scrollTop, left: e3.left + document.body.scrollLeft };
  }, position: (t3) => ({ top: t3.offsetTop, left: t3.offsetLeft }) }, F = { interval: 5e3, keyboard: true, slide: false, pause: "hover", wrap: true, touch: true }, V = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, K = "next", X = "prev", Y = "left", Q = "right", G = { ArrowLeft: Q, ArrowRight: Y };
  class Z extends B {
    constructor(e3, i3) {
      super(e3), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = false, this._isSliding = false, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(i3), this._indicatorsElement = t2.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners();
    }
    static get Default() {
      return F;
    }
    static get NAME() {
      return "carousel";
    }
    next() {
      this._slide(K);
    }
    nextWhenVisible() {
      !document.hidden && c2(this._element) && this.next();
    }
    prev() {
      this._slide(X);
    }
    pause(e3) {
      e3 || (this._isPaused = true), t2.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (o2(this._element), this.cycle(true)), clearInterval(this._interval), this._interval = null;
    }
    cycle(t3) {
      t3 || (this._isPaused = false), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
    }
    to(e3) {
      this._activeElement = t2.findOne(".active.carousel-item", this._element);
      const i3 = this._getItemIndex(this._activeElement);
      if (e3 > this._items.length - 1 || e3 < 0)
        return;
      if (this._isSliding)
        return void P.one(this._element, "slid.bs.carousel", () => this.to(e3));
      if (i3 === e3)
        return this.pause(), void this.cycle();
      const n3 = e3 > i3 ? K : X;
      this._slide(n3, this._items[e3]);
    }
    _getConfig(t3) {
      return t3 = { ...F, ...U.getDataAttributes(this._element), ..."object" == typeof t3 ? t3 : {} }, l("carousel", t3, V), t3;
    }
    _handleSwipe() {
      const t3 = Math.abs(this.touchDeltaX);
      if (t3 <= 40)
        return;
      const e3 = t3 / this.touchDeltaX;
      this.touchDeltaX = 0, e3 && this._slide(e3 > 0 ? Q : Y);
    }
    _addEventListeners() {
      this._config.keyboard && P.on(this._element, "keydown.bs.carousel", (t3) => this._keydown(t3)), "hover" === this._config.pause && (P.on(this._element, "mouseenter.bs.carousel", (t3) => this.pause(t3)), P.on(this._element, "mouseleave.bs.carousel", (t3) => this.cycle(t3))), this._config.touch && this._touchSupported && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      const e3 = (t3) => {
        !this._pointerEvent || "pen" !== t3.pointerType && "touch" !== t3.pointerType ? this._pointerEvent || (this.touchStartX = t3.touches[0].clientX) : this.touchStartX = t3.clientX;
      }, i3 = (t3) => {
        this.touchDeltaX = t3.touches && t3.touches.length > 1 ? 0 : t3.touches[0].clientX - this.touchStartX;
      }, n3 = (t3) => {
        !this._pointerEvent || "pen" !== t3.pointerType && "touch" !== t3.pointerType || (this.touchDeltaX = t3.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((t4) => this.cycle(t4), 500 + this._config.interval));
      };
      t2.find(".carousel-item img", this._element).forEach((t3) => {
        P.on(t3, "dragstart.bs.carousel", (t4) => t4.preventDefault());
      }), this._pointerEvent ? (P.on(this._element, "pointerdown.bs.carousel", (t3) => e3(t3)), P.on(this._element, "pointerup.bs.carousel", (t3) => n3(t3)), this._element.classList.add("pointer-event")) : (P.on(this._element, "touchstart.bs.carousel", (t3) => e3(t3)), P.on(this._element, "touchmove.bs.carousel", (t3) => i3(t3)), P.on(this._element, "touchend.bs.carousel", (t3) => n3(t3)));
    }
    _keydown(t3) {
      if (/input|textarea/i.test(t3.target.tagName))
        return;
      const e3 = G[t3.key];
      e3 && (t3.preventDefault(), this._slide(e3));
    }
    _getItemIndex(e3) {
      return this._items = e3 && e3.parentNode ? t2.find(".carousel-item", e3.parentNode) : [], this._items.indexOf(e3);
    }
    _getItemByOrder(t3, e3) {
      const i3 = t3 === K;
      return y(this._items, e3, i3, this._config.wrap);
    }
    _triggerSlideEvent(e3, i3) {
      const n3 = this._getItemIndex(e3), s3 = this._getItemIndex(t2.findOne(".active.carousel-item", this._element));
      return P.trigger(this._element, "slide.bs.carousel", { relatedTarget: e3, direction: i3, from: s3, to: n3 });
    }
    _setActiveIndicatorElement(e3) {
      if (this._indicatorsElement) {
        const i3 = t2.findOne(".active", this._indicatorsElement);
        i3.classList.remove("active"), i3.removeAttribute("aria-current");
        const n3 = t2.find("[data-bs-target]", this._indicatorsElement);
        for (let t3 = 0; t3 < n3.length; t3++)
          if (Number.parseInt(n3[t3].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e3)) {
            n3[t3].classList.add("active"), n3[t3].setAttribute("aria-current", "true");
            break;
          }
      }
    }
    _updateInterval() {
      const e3 = this._activeElement || t2.findOne(".active.carousel-item", this._element);
      if (!e3)
        return;
      const i3 = Number.parseInt(e3.getAttribute("data-bs-interval"), 10);
      i3 ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = i3) : this._config.interval = this._config.defaultInterval || this._config.interval;
    }
    _slide(e3, i3) {
      const n3 = this._directionToOrder(e3), s3 = t2.findOne(".active.carousel-item", this._element), o3 = this._getItemIndex(s3), r3 = i3 || this._getItemByOrder(n3, s3), a3 = this._getItemIndex(r3), l2 = Boolean(this._interval), c3 = n3 === K, h3 = c3 ? "carousel-item-start" : "carousel-item-end", d2 = c3 ? "carousel-item-next" : "carousel-item-prev", u3 = this._orderToDirection(n3);
      if (r3 && r3.classList.contains("active"))
        return void (this._isSliding = false);
      if (this._isSliding)
        return;
      if (this._triggerSlideEvent(r3, u3).defaultPrevented)
        return;
      if (!s3 || !r3)
        return;
      this._isSliding = true, l2 && this.pause(), this._setActiveIndicatorElement(r3), this._activeElement = r3;
      const p3 = () => {
        P.trigger(this._element, "slid.bs.carousel", { relatedTarget: r3, direction: u3, from: o3, to: a3 });
      };
      if (this._element.classList.contains("slide")) {
        r3.classList.add(d2), f2(r3), s3.classList.add(h3), r3.classList.add(h3);
        const t3 = () => {
          r3.classList.remove(h3, d2), r3.classList.add("active"), s3.classList.remove("active", d2, h3), this._isSliding = false, setTimeout(p3, 0);
        };
        this._queueCallback(t3, s3, true);
      } else
        s3.classList.remove("active"), r3.classList.add("active"), this._isSliding = false, p3();
      l2 && this.cycle();
    }
    _directionToOrder(t3) {
      return [Q, Y].includes(t3) ? g() ? t3 === Y ? X : K : t3 === Y ? K : X : t3;
    }
    _orderToDirection(t3) {
      return [K, X].includes(t3) ? g() ? t3 === X ? Y : Q : t3 === X ? Q : Y : t3;
    }
    static carouselInterface(t3, e3) {
      const i3 = Z.getOrCreateInstance(t3, e3);
      let { _config: n3 } = i3;
      "object" == typeof e3 && (n3 = { ...n3, ...e3 });
      const s3 = "string" == typeof e3 ? e3 : n3.slide;
      if ("number" == typeof e3)
        i3.to(e3);
      else if ("string" == typeof s3) {
        if (void 0 === i3[s3])
          throw new TypeError(`No method named "${s3}"`);
        i3[s3]();
      } else
        n3.interval && n3.ride && (i3.pause(), i3.cycle());
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        Z.carouselInterface(this, t3);
      });
    }
    static dataApiClickHandler(t3) {
      const e3 = s2(this);
      if (!e3 || !e3.classList.contains("carousel"))
        return;
      const i3 = { ...U.getDataAttributes(e3), ...U.getDataAttributes(this) }, n3 = this.getAttribute("data-bs-slide-to");
      n3 && (i3.interval = false), Z.carouselInterface(e3, i3), n3 && Z.getInstance(e3).to(n3), t3.preventDefault();
    }
  }
  P.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Z.dataApiClickHandler), P.on(window, "load.bs.carousel.data-api", () => {
    const e3 = t2.find('[data-bs-ride="carousel"]');
    for (let t3 = 0, i3 = e3.length; t3 < i3; t3++)
      Z.carouselInterface(e3[t3], Z.getInstance(e3[t3]));
  }), _2(Z);
  const J = { toggle: true, parent: "" }, tt = { toggle: "boolean", parent: "(string|element)" };
  class et extends B {
    constructor(e3, i3) {
      super(e3), this._isTransitioning = false, this._config = this._getConfig(i3), this._triggerArray = t2.find(`[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`);
      const s3 = t2.find('[data-bs-toggle="collapse"]');
      for (let e4 = 0, i4 = s3.length; e4 < i4; e4++) {
        const i5 = s3[e4], o3 = n2(i5), r3 = t2.find(o3).filter((t3) => t3 === this._element);
        null !== o3 && r3.length && (this._selector = o3, this._triggerArray.push(i5));
      }
      this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();
    }
    static get Default() {
      return J;
    }
    static get NAME() {
      return "collapse";
    }
    toggle() {
      this._element.classList.contains("show") ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._element.classList.contains("show"))
        return;
      let e3, i3;
      this._parent && (e3 = t2.find(".show, .collapsing", this._parent).filter((t3) => "string" == typeof this._config.parent ? t3.getAttribute("data-bs-parent") === this._config.parent : t3.classList.contains("collapse")), 0 === e3.length && (e3 = null));
      const n3 = t2.findOne(this._selector);
      if (e3) {
        const t3 = e3.find((t4) => n3 !== t4);
        if (i3 = t3 ? et.getInstance(t3) : null, i3 && i3._isTransitioning)
          return;
      }
      if (P.trigger(this._element, "show.bs.collapse").defaultPrevented)
        return;
      e3 && e3.forEach((t3) => {
        n3 !== t3 && et.collapseInterface(t3, "hide"), i3 || R.set(t3, "bs.collapse", null);
      });
      const s3 = this._getDimension();
      this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[s3] = 0, this._triggerArray.length && this._triggerArray.forEach((t3) => {
        t3.classList.remove("collapsed"), t3.setAttribute("aria-expanded", true);
      }), this.setTransitioning(true);
      const o3 = "scroll" + (s3[0].toUpperCase() + s3.slice(1));
      this._queueCallback(() => {
        this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[s3] = "", this.setTransitioning(false), P.trigger(this._element, "shown.bs.collapse");
      }, this._element, true), this._element.style[s3] = this._element[o3] + "px";
    }
    hide() {
      if (this._isTransitioning || !this._element.classList.contains("show"))
        return;
      if (P.trigger(this._element, "hide.bs.collapse").defaultPrevented)
        return;
      const t3 = this._getDimension();
      this._element.style[t3] = this._element.getBoundingClientRect()[t3] + "px", f2(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
      const e3 = this._triggerArray.length;
      if (e3 > 0)
        for (let t4 = 0; t4 < e3; t4++) {
          const e4 = this._triggerArray[t4], i3 = s2(e4);
          i3 && !i3.classList.contains("show") && (e4.classList.add("collapsed"), e4.setAttribute("aria-expanded", false));
        }
      this.setTransitioning(true), this._element.style[t3] = "", this._queueCallback(() => {
        this.setTransitioning(false), this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), P.trigger(this._element, "hidden.bs.collapse");
      }, this._element, true);
    }
    setTransitioning(t3) {
      this._isTransitioning = t3;
    }
    _getConfig(t3) {
      return (t3 = { ...J, ...t3 }).toggle = Boolean(t3.toggle), l("collapse", t3, tt), t3;
    }
    _getDimension() {
      return this._element.classList.contains("width") ? "width" : "height";
    }
    _getParent() {
      let { parent: e3 } = this._config;
      e3 = a2(e3);
      const i3 = `[data-bs-toggle="collapse"][data-bs-parent="${e3}"]`;
      return t2.find(i3, e3).forEach((t3) => {
        const e4 = s2(t3);
        this._addAriaAndCollapsedClass(e4, [t3]);
      }), e3;
    }
    _addAriaAndCollapsedClass(t3, e3) {
      if (!t3 || !e3.length)
        return;
      const i3 = t3.classList.contains("show");
      e3.forEach((t4) => {
        i3 ? t4.classList.remove("collapsed") : t4.classList.add("collapsed"), t4.setAttribute("aria-expanded", i3);
      });
    }
    static collapseInterface(t3, e3) {
      let i3 = et.getInstance(t3);
      const n3 = { ...J, ...U.getDataAttributes(t3), ..."object" == typeof e3 && e3 ? e3 : {} };
      if (!i3 && n3.toggle && "string" == typeof e3 && /show|hide/.test(e3) && (n3.toggle = false), i3 || (i3 = new et(t3, n3)), "string" == typeof e3) {
        if (void 0 === i3[e3])
          throw new TypeError(`No method named "${e3}"`);
        i3[e3]();
      }
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        et.collapseInterface(this, t3);
      });
    }
  }
  P.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', function(e3) {
    ("A" === e3.target.tagName || e3.delegateTarget && "A" === e3.delegateTarget.tagName) && e3.preventDefault();
    const i3 = U.getDataAttributes(this), s3 = n2(this);
    t2.find(s3).forEach((t3) => {
      const e4 = et.getInstance(t3);
      let n3;
      e4 ? (null === e4._parent && "string" == typeof i3.parent && (e4._config.parent = i3.parent, e4._parent = e4._getParent()), n3 = "toggle") : n3 = i3, et.collapseInterface(t3, n3);
    });
  }), _2(et);
  var it = "top", nt = "bottom", st = "right", ot = "left", rt = [it, nt, st, ot], at = rt.reduce(function(t3, e3) {
    return t3.concat([e3 + "-start", e3 + "-end"]);
  }, []), lt = [].concat(rt, ["auto"]).reduce(function(t3, e3) {
    return t3.concat([e3, e3 + "-start", e3 + "-end"]);
  }, []), ct = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];
  function ht(t3) {
    return t3 ? (t3.nodeName || "").toLowerCase() : null;
  }
  function dt(t3) {
    if (null == t3)
      return window;
    if ("[object Window]" !== t3.toString()) {
      var e3 = t3.ownerDocument;
      return e3 && e3.defaultView || window;
    }
    return t3;
  }
  function ut(t3) {
    return t3 instanceof dt(t3).Element || t3 instanceof Element;
  }
  function ft(t3) {
    return t3 instanceof dt(t3).HTMLElement || t3 instanceof HTMLElement;
  }
  function pt(t3) {
    return "undefined" != typeof ShadowRoot && (t3 instanceof dt(t3).ShadowRoot || t3 instanceof ShadowRoot);
  }
  var mt = { name: "applyStyles", enabled: true, phase: "write", fn: function(t3) {
    var e3 = t3.state;
    Object.keys(e3.elements).forEach(function(t4) {
      var i3 = e3.styles[t4] || {}, n3 = e3.attributes[t4] || {}, s3 = e3.elements[t4];
      ft(s3) && ht(s3) && (Object.assign(s3.style, i3), Object.keys(n3).forEach(function(t5) {
        var e4 = n3[t5];
        false === e4 ? s3.removeAttribute(t5) : s3.setAttribute(t5, true === e4 ? "" : e4);
      }));
    });
  }, effect: function(t3) {
    var e3 = t3.state, i3 = { popper: { position: e3.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    return Object.assign(e3.elements.popper.style, i3.popper), e3.styles = i3, e3.elements.arrow && Object.assign(e3.elements.arrow.style, i3.arrow), function() {
      Object.keys(e3.elements).forEach(function(t4) {
        var n3 = e3.elements[t4], s3 = e3.attributes[t4] || {}, o3 = Object.keys(e3.styles.hasOwnProperty(t4) ? e3.styles[t4] : i3[t4]).reduce(function(t5, e4) {
          return t5[e4] = "", t5;
        }, {});
        ft(n3) && ht(n3) && (Object.assign(n3.style, o3), Object.keys(s3).forEach(function(t5) {
          n3.removeAttribute(t5);
        }));
      });
    };
  }, requires: ["computeStyles"] };
  function gt(t3) {
    return t3.split("-")[0];
  }
  function _t(t3) {
    var e3 = t3.getBoundingClientRect();
    return { width: e3.width, height: e3.height, top: e3.top, right: e3.right, bottom: e3.bottom, left: e3.left, x: e3.left, y: e3.top };
  }
  function bt(t3) {
    var e3 = _t(t3), i3 = t3.offsetWidth, n3 = t3.offsetHeight;
    return Math.abs(e3.width - i3) <= 1 && (i3 = e3.width), Math.abs(e3.height - n3) <= 1 && (n3 = e3.height), { x: t3.offsetLeft, y: t3.offsetTop, width: i3, height: n3 };
  }
  function vt(t3, e3) {
    var i3 = e3.getRootNode && e3.getRootNode();
    if (t3.contains(e3))
      return true;
    if (i3 && pt(i3)) {
      var n3 = e3;
      do {
        if (n3 && t3.isSameNode(n3))
          return true;
        n3 = n3.parentNode || n3.host;
      } while (n3);
    }
    return false;
  }
  function yt(t3) {
    return dt(t3).getComputedStyle(t3);
  }
  function wt(t3) {
    return ["table", "td", "th"].indexOf(ht(t3)) >= 0;
  }
  function Et(t3) {
    return ((ut(t3) ? t3.ownerDocument : t3.document) || window.document).documentElement;
  }
  function At(t3) {
    return "html" === ht(t3) ? t3 : t3.assignedSlot || t3.parentNode || (pt(t3) ? t3.host : null) || Et(t3);
  }
  function Tt(t3) {
    return ft(t3) && "fixed" !== yt(t3).position ? t3.offsetParent : null;
  }
  function Ot(t3) {
    for (var e3 = dt(t3), i3 = Tt(t3); i3 && wt(i3) && "static" === yt(i3).position; )
      i3 = Tt(i3);
    return i3 && ("html" === ht(i3) || "body" === ht(i3) && "static" === yt(i3).position) ? e3 : i3 || function(t4) {
      var e4 = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && ft(t4) && "fixed" === yt(t4).position)
        return null;
      for (var i4 = At(t4); ft(i4) && ["html", "body"].indexOf(ht(i4)) < 0; ) {
        var n3 = yt(i4);
        if ("none" !== n3.transform || "none" !== n3.perspective || "paint" === n3.contain || -1 !== ["transform", "perspective"].indexOf(n3.willChange) || e4 && "filter" === n3.willChange || e4 && n3.filter && "none" !== n3.filter)
          return i4;
        i4 = i4.parentNode;
      }
      return null;
    }(t3) || e3;
  }
  function Ct(t3) {
    return ["top", "bottom"].indexOf(t3) >= 0 ? "x" : "y";
  }
  var kt = Math.max, Lt = Math.min, xt = Math.round;
  function Dt(t3, e3, i3) {
    return kt(t3, Lt(e3, i3));
  }
  function St(t3) {
    return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t3);
  }
  function It(t3, e3) {
    return e3.reduce(function(e4, i3) {
      return e4[i3] = t3, e4;
    }, {});
  }
  var Nt = { name: "arrow", enabled: true, phase: "main", fn: function(t3) {
    var e3, i3 = t3.state, n3 = t3.name, s3 = t3.options, o3 = i3.elements.arrow, r3 = i3.modifiersData.popperOffsets, a3 = gt(i3.placement), l2 = Ct(a3), c3 = [ot, st].indexOf(a3) >= 0 ? "height" : "width";
    if (o3 && r3) {
      var h3 = function(t4, e4) {
        return St("number" != typeof (t4 = "function" == typeof t4 ? t4(Object.assign({}, e4.rects, { placement: e4.placement })) : t4) ? t4 : It(t4, rt));
      }(s3.padding, i3), d2 = bt(o3), u3 = "y" === l2 ? it : ot, f3 = "y" === l2 ? nt : st, p3 = i3.rects.reference[c3] + i3.rects.reference[l2] - r3[l2] - i3.rects.popper[c3], m2 = r3[l2] - i3.rects.reference[l2], g2 = Ot(o3), _3 = g2 ? "y" === l2 ? g2.clientHeight || 0 : g2.clientWidth || 0 : 0, b2 = p3 / 2 - m2 / 2, v3 = h3[u3], y2 = _3 - d2[c3] - h3[f3], w2 = _3 / 2 - d2[c3] / 2 + b2, E2 = Dt(v3, w2, y2), A2 = l2;
      i3.modifiersData[n3] = ((e3 = {})[A2] = E2, e3.centerOffset = E2 - w2, e3);
    }
  }, effect: function(t3) {
    var e3 = t3.state, i3 = t3.options.element, n3 = void 0 === i3 ? "[data-popper-arrow]" : i3;
    null != n3 && ("string" != typeof n3 || (n3 = e3.elements.popper.querySelector(n3))) && vt(e3.elements.popper, n3) && (e3.elements.arrow = n3);
  }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }, jt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function Mt(t3) {
    var e3, i3 = t3.popper, n3 = t3.popperRect, s3 = t3.placement, o3 = t3.offsets, r3 = t3.position, a3 = t3.gpuAcceleration, l2 = t3.adaptive, c3 = t3.roundOffsets, h3 = true === c3 ? function(t4) {
      var e4 = t4.x, i4 = t4.y, n4 = window.devicePixelRatio || 1;
      return { x: xt(xt(e4 * n4) / n4) || 0, y: xt(xt(i4 * n4) / n4) || 0 };
    }(o3) : "function" == typeof c3 ? c3(o3) : o3, d2 = h3.x, u3 = void 0 === d2 ? 0 : d2, f3 = h3.y, p3 = void 0 === f3 ? 0 : f3, m2 = o3.hasOwnProperty("x"), g2 = o3.hasOwnProperty("y"), _3 = ot, b2 = it, v3 = window;
    if (l2) {
      var y2 = Ot(i3), w2 = "clientHeight", E2 = "clientWidth";
      y2 === dt(i3) && "static" !== yt(y2 = Et(i3)).position && (w2 = "scrollHeight", E2 = "scrollWidth"), y2 = y2, s3 === it && (b2 = nt, p3 -= y2[w2] - n3.height, p3 *= a3 ? 1 : -1), s3 === ot && (_3 = st, u3 -= y2[E2] - n3.width, u3 *= a3 ? 1 : -1);
    }
    var A2, T2 = Object.assign({ position: r3 }, l2 && jt);
    return a3 ? Object.assign({}, T2, ((A2 = {})[b2] = g2 ? "0" : "", A2[_3] = m2 ? "0" : "", A2.transform = (v3.devicePixelRatio || 1) < 2 ? "translate(" + u3 + "px, " + p3 + "px)" : "translate3d(" + u3 + "px, " + p3 + "px, 0)", A2)) : Object.assign({}, T2, ((e3 = {})[b2] = g2 ? p3 + "px" : "", e3[_3] = m2 ? u3 + "px" : "", e3.transform = "", e3));
  }
  var Pt = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(t3) {
    var e3 = t3.state, i3 = t3.options, n3 = i3.gpuAcceleration, s3 = void 0 === n3 || n3, o3 = i3.adaptive, r3 = void 0 === o3 || o3, a3 = i3.roundOffsets, l2 = void 0 === a3 || a3, c3 = { placement: gt(e3.placement), popper: e3.elements.popper, popperRect: e3.rects.popper, gpuAcceleration: s3 };
    null != e3.modifiersData.popperOffsets && (e3.styles.popper = Object.assign({}, e3.styles.popper, Mt(Object.assign({}, c3, { offsets: e3.modifiersData.popperOffsets, position: e3.options.strategy, adaptive: r3, roundOffsets: l2 })))), null != e3.modifiersData.arrow && (e3.styles.arrow = Object.assign({}, e3.styles.arrow, Mt(Object.assign({}, c3, { offsets: e3.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l2 })))), e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-placement": e3.placement });
  }, data: {} }, Ht = { passive: true }, Rt = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
  }, effect: function(t3) {
    var e3 = t3.state, i3 = t3.instance, n3 = t3.options, s3 = n3.scroll, o3 = void 0 === s3 || s3, r3 = n3.resize, a3 = void 0 === r3 || r3, l2 = dt(e3.elements.popper), c3 = [].concat(e3.scrollParents.reference, e3.scrollParents.popper);
    return o3 && c3.forEach(function(t4) {
      t4.addEventListener("scroll", i3.update, Ht);
    }), a3 && l2.addEventListener("resize", i3.update, Ht), function() {
      o3 && c3.forEach(function(t4) {
        t4.removeEventListener("scroll", i3.update, Ht);
      }), a3 && l2.removeEventListener("resize", i3.update, Ht);
    };
  }, data: {} }, Bt = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function Wt(t3) {
    return t3.replace(/left|right|bottom|top/g, function(t4) {
      return Bt[t4];
    });
  }
  var qt = { start: "end", end: "start" };
  function zt(t3) {
    return t3.replace(/start|end/g, function(t4) {
      return qt[t4];
    });
  }
  function $t(t3) {
    var e3 = dt(t3);
    return { scrollLeft: e3.pageXOffset, scrollTop: e3.pageYOffset };
  }
  function Ut(t3) {
    return _t(Et(t3)).left + $t(t3).scrollLeft;
  }
  function Ft(t3) {
    var e3 = yt(t3), i3 = e3.overflow, n3 = e3.overflowX, s3 = e3.overflowY;
    return /auto|scroll|overlay|hidden/.test(i3 + s3 + n3);
  }
  function Vt(t3, e3) {
    var i3;
    void 0 === e3 && (e3 = []);
    var n3 = function t4(e4) {
      return ["html", "body", "#document"].indexOf(ht(e4)) >= 0 ? e4.ownerDocument.body : ft(e4) && Ft(e4) ? e4 : t4(At(e4));
    }(t3), s3 = n3 === (null == (i3 = t3.ownerDocument) ? void 0 : i3.body), o3 = dt(n3), r3 = s3 ? [o3].concat(o3.visualViewport || [], Ft(n3) ? n3 : []) : n3, a3 = e3.concat(r3);
    return s3 ? a3 : a3.concat(Vt(At(r3)));
  }
  function Kt(t3) {
    return Object.assign({}, t3, { left: t3.x, top: t3.y, right: t3.x + t3.width, bottom: t3.y + t3.height });
  }
  function Xt(t3, e3) {
    return "viewport" === e3 ? Kt(function(t4) {
      var e4 = dt(t4), i3 = Et(t4), n3 = e4.visualViewport, s3 = i3.clientWidth, o3 = i3.clientHeight, r3 = 0, a3 = 0;
      return n3 && (s3 = n3.width, o3 = n3.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r3 = n3.offsetLeft, a3 = n3.offsetTop)), { width: s3, height: o3, x: r3 + Ut(t4), y: a3 };
    }(t3)) : ft(e3) ? function(t4) {
      var e4 = _t(t4);
      return e4.top = e4.top + t4.clientTop, e4.left = e4.left + t4.clientLeft, e4.bottom = e4.top + t4.clientHeight, e4.right = e4.left + t4.clientWidth, e4.width = t4.clientWidth, e4.height = t4.clientHeight, e4.x = e4.left, e4.y = e4.top, e4;
    }(e3) : Kt(function(t4) {
      var e4, i3 = Et(t4), n3 = $t(t4), s3 = null == (e4 = t4.ownerDocument) ? void 0 : e4.body, o3 = kt(i3.scrollWidth, i3.clientWidth, s3 ? s3.scrollWidth : 0, s3 ? s3.clientWidth : 0), r3 = kt(i3.scrollHeight, i3.clientHeight, s3 ? s3.scrollHeight : 0, s3 ? s3.clientHeight : 0), a3 = -n3.scrollLeft + Ut(t4), l2 = -n3.scrollTop;
      return "rtl" === yt(s3 || i3).direction && (a3 += kt(i3.clientWidth, s3 ? s3.clientWidth : 0) - o3), { width: o3, height: r3, x: a3, y: l2 };
    }(Et(t3)));
  }
  function Yt(t3) {
    return t3.split("-")[1];
  }
  function Qt(t3) {
    var e3, i3 = t3.reference, n3 = t3.element, s3 = t3.placement, o3 = s3 ? gt(s3) : null, r3 = s3 ? Yt(s3) : null, a3 = i3.x + i3.width / 2 - n3.width / 2, l2 = i3.y + i3.height / 2 - n3.height / 2;
    switch (o3) {
      case it:
        e3 = { x: a3, y: i3.y - n3.height };
        break;
      case nt:
        e3 = { x: a3, y: i3.y + i3.height };
        break;
      case st:
        e3 = { x: i3.x + i3.width, y: l2 };
        break;
      case ot:
        e3 = { x: i3.x - n3.width, y: l2 };
        break;
      default:
        e3 = { x: i3.x, y: i3.y };
    }
    var c3 = o3 ? Ct(o3) : null;
    if (null != c3) {
      var h3 = "y" === c3 ? "height" : "width";
      switch (r3) {
        case "start":
          e3[c3] = e3[c3] - (i3[h3] / 2 - n3[h3] / 2);
          break;
        case "end":
          e3[c3] = e3[c3] + (i3[h3] / 2 - n3[h3] / 2);
      }
    }
    return e3;
  }
  function Gt(t3, e3) {
    void 0 === e3 && (e3 = {});
    var i3 = e3, n3 = i3.placement, s3 = void 0 === n3 ? t3.placement : n3, o3 = i3.boundary, r3 = void 0 === o3 ? "clippingParents" : o3, a3 = i3.rootBoundary, l2 = void 0 === a3 ? "viewport" : a3, c3 = i3.elementContext, h3 = void 0 === c3 ? "popper" : c3, d2 = i3.altBoundary, u3 = void 0 !== d2 && d2, f3 = i3.padding, p3 = void 0 === f3 ? 0 : f3, m2 = St("number" != typeof p3 ? p3 : It(p3, rt)), g2 = "popper" === h3 ? "reference" : "popper", _3 = t3.elements.reference, b2 = t3.rects.popper, v3 = t3.elements[u3 ? g2 : h3], y2 = function(t4, e4, i4) {
      var n4 = "clippingParents" === e4 ? function(t5) {
        var e5 = Vt(At(t5)), i5 = ["absolute", "fixed"].indexOf(yt(t5).position) >= 0 && ft(t5) ? Ot(t5) : t5;
        return ut(i5) ? e5.filter(function(t6) {
          return ut(t6) && vt(t6, i5) && "body" !== ht(t6);
        }) : [];
      }(t4) : [].concat(e4), s4 = [].concat(n4, [i4]), o4 = s4[0], r4 = s4.reduce(function(e5, i5) {
        var n5 = Xt(t4, i5);
        return e5.top = kt(n5.top, e5.top), e5.right = Lt(n5.right, e5.right), e5.bottom = Lt(n5.bottom, e5.bottom), e5.left = kt(n5.left, e5.left), e5;
      }, Xt(t4, o4));
      return r4.width = r4.right - r4.left, r4.height = r4.bottom - r4.top, r4.x = r4.left, r4.y = r4.top, r4;
    }(ut(v3) ? v3 : v3.contextElement || Et(t3.elements.popper), r3, l2), w2 = _t(_3), E2 = Qt({ reference: w2, element: b2, strategy: "absolute", placement: s3 }), A2 = Kt(Object.assign({}, b2, E2)), T2 = "popper" === h3 ? A2 : w2, O2 = { top: y2.top - T2.top + m2.top, bottom: T2.bottom - y2.bottom + m2.bottom, left: y2.left - T2.left + m2.left, right: T2.right - y2.right + m2.right }, C2 = t3.modifiersData.offset;
    if ("popper" === h3 && C2) {
      var k2 = C2[s3];
      Object.keys(O2).forEach(function(t4) {
        var e4 = [st, nt].indexOf(t4) >= 0 ? 1 : -1, i4 = [it, nt].indexOf(t4) >= 0 ? "y" : "x";
        O2[t4] += k2[i4] * e4;
      });
    }
    return O2;
  }
  function Zt(t3, e3) {
    void 0 === e3 && (e3 = {});
    var i3 = e3, n3 = i3.placement, s3 = i3.boundary, o3 = i3.rootBoundary, r3 = i3.padding, a3 = i3.flipVariations, l2 = i3.allowedAutoPlacements, c3 = void 0 === l2 ? lt : l2, h3 = Yt(n3), d2 = h3 ? a3 ? at : at.filter(function(t4) {
      return Yt(t4) === h3;
    }) : rt, u3 = d2.filter(function(t4) {
      return c3.indexOf(t4) >= 0;
    });
    0 === u3.length && (u3 = d2);
    var f3 = u3.reduce(function(e4, i4) {
      return e4[i4] = Gt(t3, { placement: i4, boundary: s3, rootBoundary: o3, padding: r3 })[gt(i4)], e4;
    }, {});
    return Object.keys(f3).sort(function(t4, e4) {
      return f3[t4] - f3[e4];
    });
  }
  var Jt = { name: "flip", enabled: true, phase: "main", fn: function(t3) {
    var e3 = t3.state, i3 = t3.options, n3 = t3.name;
    if (!e3.modifiersData[n3]._skip) {
      for (var s3 = i3.mainAxis, o3 = void 0 === s3 || s3, r3 = i3.altAxis, a3 = void 0 === r3 || r3, l2 = i3.fallbackPlacements, c3 = i3.padding, h3 = i3.boundary, d2 = i3.rootBoundary, u3 = i3.altBoundary, f3 = i3.flipVariations, p3 = void 0 === f3 || f3, m2 = i3.allowedAutoPlacements, g2 = e3.options.placement, _3 = gt(g2), b2 = l2 || (_3 !== g2 && p3 ? function(t4) {
        if ("auto" === gt(t4))
          return [];
        var e4 = Wt(t4);
        return [zt(t4), e4, zt(e4)];
      }(g2) : [Wt(g2)]), v3 = [g2].concat(b2).reduce(function(t4, i4) {
        return t4.concat("auto" === gt(i4) ? Zt(e3, { placement: i4, boundary: h3, rootBoundary: d2, padding: c3, flipVariations: p3, allowedAutoPlacements: m2 }) : i4);
      }, []), y2 = e3.rects.reference, w2 = e3.rects.popper, E2 = /* @__PURE__ */ new Map(), A2 = true, T2 = v3[0], O2 = 0; O2 < v3.length; O2++) {
        var C2 = v3[O2], k2 = gt(C2), L2 = "start" === Yt(C2), x2 = [it, nt].indexOf(k2) >= 0, D2 = x2 ? "width" : "height", S2 = Gt(e3, { placement: C2, boundary: h3, rootBoundary: d2, altBoundary: u3, padding: c3 }), I2 = x2 ? L2 ? st : ot : L2 ? nt : it;
        y2[D2] > w2[D2] && (I2 = Wt(I2));
        var N2 = Wt(I2), j2 = [];
        if (o3 && j2.push(S2[k2] <= 0), a3 && j2.push(S2[I2] <= 0, S2[N2] <= 0), j2.every(function(t4) {
          return t4;
        })) {
          T2 = C2, A2 = false;
          break;
        }
        E2.set(C2, j2);
      }
      if (A2)
        for (var M2 = function(t4) {
          var e4 = v3.find(function(e5) {
            var i4 = E2.get(e5);
            if (i4)
              return i4.slice(0, t4).every(function(t5) {
                return t5;
              });
          });
          if (e4)
            return T2 = e4, "break";
        }, P2 = p3 ? 3 : 1; P2 > 0 && "break" !== M2(P2); P2--)
          ;
      e3.placement !== T2 && (e3.modifiersData[n3]._skip = true, e3.placement = T2, e3.reset = true);
    }
  }, requiresIfExists: ["offset"], data: { _skip: false } };
  function te(t3, e3, i3) {
    return void 0 === i3 && (i3 = { x: 0, y: 0 }), { top: t3.top - e3.height - i3.y, right: t3.right - e3.width + i3.x, bottom: t3.bottom - e3.height + i3.y, left: t3.left - e3.width - i3.x };
  }
  function ee(t3) {
    return [it, st, nt, ot].some(function(e3) {
      return t3[e3] >= 0;
    });
  }
  var ie = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(t3) {
    var e3 = t3.state, i3 = t3.name, n3 = e3.rects.reference, s3 = e3.rects.popper, o3 = e3.modifiersData.preventOverflow, r3 = Gt(e3, { elementContext: "reference" }), a3 = Gt(e3, { altBoundary: true }), l2 = te(r3, n3), c3 = te(a3, s3, o3), h3 = ee(l2), d2 = ee(c3);
    e3.modifiersData[i3] = { referenceClippingOffsets: l2, popperEscapeOffsets: c3, isReferenceHidden: h3, hasPopperEscaped: d2 }, e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-reference-hidden": h3, "data-popper-escaped": d2 });
  } }, ne = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(t3) {
    var e3 = t3.state, i3 = t3.options, n3 = t3.name, s3 = i3.offset, o3 = void 0 === s3 ? [0, 0] : s3, r3 = lt.reduce(function(t4, i4) {
      return t4[i4] = function(t5, e4, i5) {
        var n4 = gt(t5), s4 = [ot, it].indexOf(n4) >= 0 ? -1 : 1, o4 = "function" == typeof i5 ? i5(Object.assign({}, e4, { placement: t5 })) : i5, r4 = o4[0], a4 = o4[1];
        return r4 = r4 || 0, a4 = (a4 || 0) * s4, [ot, st].indexOf(n4) >= 0 ? { x: a4, y: r4 } : { x: r4, y: a4 };
      }(i4, e3.rects, o3), t4;
    }, {}), a3 = r3[e3.placement], l2 = a3.x, c3 = a3.y;
    null != e3.modifiersData.popperOffsets && (e3.modifiersData.popperOffsets.x += l2, e3.modifiersData.popperOffsets.y += c3), e3.modifiersData[n3] = r3;
  } }, se = { name: "popperOffsets", enabled: true, phase: "read", fn: function(t3) {
    var e3 = t3.state, i3 = t3.name;
    e3.modifiersData[i3] = Qt({ reference: e3.rects.reference, element: e3.rects.popper, strategy: "absolute", placement: e3.placement });
  }, data: {} }, oe = { name: "preventOverflow", enabled: true, phase: "main", fn: function(t3) {
    var e3 = t3.state, i3 = t3.options, n3 = t3.name, s3 = i3.mainAxis, o3 = void 0 === s3 || s3, r3 = i3.altAxis, a3 = void 0 !== r3 && r3, l2 = i3.boundary, c3 = i3.rootBoundary, h3 = i3.altBoundary, d2 = i3.padding, u3 = i3.tether, f3 = void 0 === u3 || u3, p3 = i3.tetherOffset, m2 = void 0 === p3 ? 0 : p3, g2 = Gt(e3, { boundary: l2, rootBoundary: c3, padding: d2, altBoundary: h3 }), _3 = gt(e3.placement), b2 = Yt(e3.placement), v3 = !b2, y2 = Ct(_3), w2 = "x" === y2 ? "y" : "x", E2 = e3.modifiersData.popperOffsets, A2 = e3.rects.reference, T2 = e3.rects.popper, O2 = "function" == typeof m2 ? m2(Object.assign({}, e3.rects, { placement: e3.placement })) : m2, C2 = { x: 0, y: 0 };
    if (E2) {
      if (o3 || a3) {
        var k2 = "y" === y2 ? it : ot, L2 = "y" === y2 ? nt : st, x2 = "y" === y2 ? "height" : "width", D2 = E2[y2], S2 = E2[y2] + g2[k2], I2 = E2[y2] - g2[L2], N2 = f3 ? -T2[x2] / 2 : 0, j2 = "start" === b2 ? A2[x2] : T2[x2], M2 = "start" === b2 ? -T2[x2] : -A2[x2], P2 = e3.elements.arrow, H2 = f3 && P2 ? bt(P2) : { width: 0, height: 0 }, R2 = e3.modifiersData["arrow#persistent"] ? e3.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, B2 = R2[k2], W2 = R2[L2], q2 = Dt(0, A2[x2], H2[x2]), z2 = v3 ? A2[x2] / 2 - N2 - q2 - B2 - O2 : j2 - q2 - B2 - O2, $2 = v3 ? -A2[x2] / 2 + N2 + q2 + W2 + O2 : M2 + q2 + W2 + O2, U2 = e3.elements.arrow && Ot(e3.elements.arrow), F2 = U2 ? "y" === y2 ? U2.clientTop || 0 : U2.clientLeft || 0 : 0, V2 = e3.modifiersData.offset ? e3.modifiersData.offset[e3.placement][y2] : 0, K2 = E2[y2] + z2 - V2 - F2, X2 = E2[y2] + $2 - V2;
        if (o3) {
          var Y2 = Dt(f3 ? Lt(S2, K2) : S2, D2, f3 ? kt(I2, X2) : I2);
          E2[y2] = Y2, C2[y2] = Y2 - D2;
        }
        if (a3) {
          var Q2 = "x" === y2 ? it : ot, G2 = "x" === y2 ? nt : st, Z2 = E2[w2], J2 = Z2 + g2[Q2], tt2 = Z2 - g2[G2], et2 = Dt(f3 ? Lt(J2, K2) : J2, Z2, f3 ? kt(tt2, X2) : tt2);
          E2[w2] = et2, C2[w2] = et2 - Z2;
        }
      }
      e3.modifiersData[n3] = C2;
    }
  }, requiresIfExists: ["offset"] };
  function re(t3, e3, i3) {
    void 0 === i3 && (i3 = false);
    var n3, s3, o3 = Et(e3), r3 = _t(t3), a3 = ft(e3), l2 = { scrollLeft: 0, scrollTop: 0 }, c3 = { x: 0, y: 0 };
    return (a3 || !a3 && !i3) && (("body" !== ht(e3) || Ft(o3)) && (l2 = (n3 = e3) !== dt(n3) && ft(n3) ? { scrollLeft: (s3 = n3).scrollLeft, scrollTop: s3.scrollTop } : $t(n3)), ft(e3) ? ((c3 = _t(e3)).x += e3.clientLeft, c3.y += e3.clientTop) : o3 && (c3.x = Ut(o3))), { x: r3.left + l2.scrollLeft - c3.x, y: r3.top + l2.scrollTop - c3.y, width: r3.width, height: r3.height };
  }
  var ae = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function le() {
    for (var t3 = arguments.length, e3 = new Array(t3), i3 = 0; i3 < t3; i3++)
      e3[i3] = arguments[i3];
    return !e3.some(function(t4) {
      return !(t4 && "function" == typeof t4.getBoundingClientRect);
    });
  }
  function ce(t3) {
    void 0 === t3 && (t3 = {});
    var e3 = t3, i3 = e3.defaultModifiers, n3 = void 0 === i3 ? [] : i3, s3 = e3.defaultOptions, o3 = void 0 === s3 ? ae : s3;
    return function(t4, e4, i4) {
      void 0 === i4 && (i4 = o3);
      var s4, r3, a3 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, ae, o3), modifiersData: {}, elements: { reference: t4, popper: e4 }, attributes: {}, styles: {} }, l2 = [], c3 = false, h3 = { state: a3, setOptions: function(i5) {
        d2(), a3.options = Object.assign({}, o3, a3.options, i5), a3.scrollParents = { reference: ut(t4) ? Vt(t4) : t4.contextElement ? Vt(t4.contextElement) : [], popper: Vt(e4) };
        var s5, r4, c4 = function(t5) {
          var e5 = function(t6) {
            var e6 = /* @__PURE__ */ new Map(), i6 = /* @__PURE__ */ new Set(), n4 = [];
            return t6.forEach(function(t7) {
              e6.set(t7.name, t7);
            }), t6.forEach(function(t7) {
              i6.has(t7.name) || function t8(s6) {
                i6.add(s6.name), [].concat(s6.requires || [], s6.requiresIfExists || []).forEach(function(n5) {
                  if (!i6.has(n5)) {
                    var s7 = e6.get(n5);
                    s7 && t8(s7);
                  }
                }), n4.push(s6);
              }(t7);
            }), n4;
          }(t5);
          return ct.reduce(function(t6, i6) {
            return t6.concat(e5.filter(function(t7) {
              return t7.phase === i6;
            }));
          }, []);
        }((s5 = [].concat(n3, a3.options.modifiers), r4 = s5.reduce(function(t5, e5) {
          var i6 = t5[e5.name];
          return t5[e5.name] = i6 ? Object.assign({}, i6, e5, { options: Object.assign({}, i6.options, e5.options), data: Object.assign({}, i6.data, e5.data) }) : e5, t5;
        }, {}), Object.keys(r4).map(function(t5) {
          return r4[t5];
        })));
        return a3.orderedModifiers = c4.filter(function(t5) {
          return t5.enabled;
        }), a3.orderedModifiers.forEach(function(t5) {
          var e5 = t5.name, i6 = t5.options, n4 = void 0 === i6 ? {} : i6, s6 = t5.effect;
          if ("function" == typeof s6) {
            var o4 = s6({ state: a3, name: e5, instance: h3, options: n4 });
            l2.push(o4 || function() {
            });
          }
        }), h3.update();
      }, forceUpdate: function() {
        if (!c3) {
          var t5 = a3.elements, e5 = t5.reference, i5 = t5.popper;
          if (le(e5, i5)) {
            a3.rects = { reference: re(e5, Ot(i5), "fixed" === a3.options.strategy), popper: bt(i5) }, a3.reset = false, a3.placement = a3.options.placement, a3.orderedModifiers.forEach(function(t6) {
              return a3.modifiersData[t6.name] = Object.assign({}, t6.data);
            });
            for (var n4 = 0; n4 < a3.orderedModifiers.length; n4++)
              if (true !== a3.reset) {
                var s5 = a3.orderedModifiers[n4], o4 = s5.fn, r4 = s5.options, l3 = void 0 === r4 ? {} : r4, d3 = s5.name;
                "function" == typeof o4 && (a3 = o4({ state: a3, options: l3, name: d3, instance: h3 }) || a3);
              } else
                a3.reset = false, n4 = -1;
          }
        }
      }, update: (s4 = function() {
        return new Promise(function(t5) {
          h3.forceUpdate(), t5(a3);
        });
      }, function() {
        return r3 || (r3 = new Promise(function(t5) {
          Promise.resolve().then(function() {
            r3 = void 0, t5(s4());
          });
        })), r3;
      }), destroy: function() {
        d2(), c3 = true;
      } };
      if (!le(t4, e4))
        return h3;
      function d2() {
        l2.forEach(function(t5) {
          return t5();
        }), l2 = [];
      }
      return h3.setOptions(i4).then(function(t5) {
        !c3 && i4.onFirstUpdate && i4.onFirstUpdate(t5);
      }), h3;
    };
  }
  var he = ce(), de = ce({ defaultModifiers: [Rt, se, Pt, mt] }), ue = ce({ defaultModifiers: [Rt, se, Pt, mt, ne, Jt, oe, Nt, ie] }), fe = Object.freeze({ __proto__: null, popperGenerator: ce, detectOverflow: Gt, createPopperBase: he, createPopper: ue, createPopperLite: de, top: it, bottom: nt, right: st, left: ot, auto: "auto", basePlacements: rt, start: "start", end: "end", clippingParents: "clippingParents", viewport: "viewport", popper: "popper", reference: "reference", variationPlacements: at, placements: lt, beforeRead: "beforeRead", read: "read", afterRead: "afterRead", beforeMain: "beforeMain", main: "main", afterMain: "afterMain", beforeWrite: "beforeWrite", write: "write", afterWrite: "afterWrite", modifierPhases: ct, applyStyles: mt, arrow: Nt, computeStyles: Pt, eventListeners: Rt, flip: Jt, hide: ie, offset: ne, popperOffsets: se, preventOverflow: oe });
  const pe = new RegExp("ArrowUp|ArrowDown|Escape"), me = g() ? "top-end" : "top-start", ge = g() ? "top-start" : "top-end", _e = g() ? "bottom-end" : "bottom-start", be = g() ? "bottom-start" : "bottom-end", ve = g() ? "left-start" : "right-start", ye = g() ? "right-start" : "left-start", we = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: true }, Ee = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" };
  class Ae extends B {
    constructor(t3, e3) {
      super(t3), this._popper = null, this._config = this._getConfig(e3), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();
    }
    static get Default() {
      return we;
    }
    static get DefaultType() {
      return Ee;
    }
    static get NAME() {
      return "dropdown";
    }
    toggle() {
      h2(this._element) || (this._element.classList.contains("show") ? this.hide() : this.show());
    }
    show() {
      if (h2(this._element) || this._menu.classList.contains("show"))
        return;
      const t3 = Ae.getParentFromElement(this._element), e3 = { relatedTarget: this._element };
      if (!P.trigger(this._element, "show.bs.dropdown", e3).defaultPrevented) {
        if (this._inNavbar)
          U.setDataAttribute(this._menu, "popper", "none");
        else {
          if (void 0 === fe)
            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
          let e4 = this._element;
          "parent" === this._config.reference ? e4 = t3 : r2(this._config.reference) ? e4 = a2(this._config.reference) : "object" == typeof this._config.reference && (e4 = this._config.reference);
          const i3 = this._getPopperConfig(), n3 = i3.modifiers.find((t4) => "applyStyles" === t4.name && false === t4.enabled);
          this._popper = ue(e4, this._menu, i3), n3 && U.setDataAttribute(this._menu, "popper", "static");
        }
        "ontouchstart" in document.documentElement && !t3.closest(".navbar-nav") && [].concat(...document.body.children).forEach((t4) => P.on(t4, "mouseover", u2)), this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), P.trigger(this._element, "shown.bs.dropdown", e3);
      }
    }
    hide() {
      if (h2(this._element) || !this._menu.classList.contains("show"))
        return;
      const t3 = { relatedTarget: this._element };
      this._completeHide(t3);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
    }
    _addEventListeners() {
      P.on(this._element, "click.bs.dropdown", (t3) => {
        t3.preventDefault(), this.toggle();
      });
    }
    _completeHide(t3) {
      P.trigger(this._element, "hide.bs.dropdown", t3).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t4) => P.off(t4, "mouseover", u2)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), U.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, "hidden.bs.dropdown", t3));
    }
    _getConfig(t3) {
      if (t3 = { ...this.constructor.Default, ...U.getDataAttributes(this._element), ...t3 }, l("dropdown", t3, this.constructor.DefaultType), "object" == typeof t3.reference && !r2(t3.reference) && "function" != typeof t3.reference.getBoundingClientRect)
        throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
      return t3;
    }
    _getMenuElement() {
      return t2.next(this._element, ".dropdown-menu")[0];
    }
    _getPlacement() {
      const t3 = this._element.parentNode;
      if (t3.classList.contains("dropend"))
        return ve;
      if (t3.classList.contains("dropstart"))
        return ye;
      const e3 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t3.classList.contains("dropup") ? e3 ? ge : me : e3 ? be : _e;
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }
    _getOffset() {
      const { offset: t3 } = this._config;
      return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e3) => t3(e3, this._element) : t3;
    }
    _getPopperConfig() {
      const t3 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
      return "static" === this._config.display && (t3.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t3, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t3) : this._config.popperConfig };
    }
    _selectMenuItem({ key: e3, target: i3 }) {
      const n3 = t2.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(c2);
      n3.length && y(n3, i3, "ArrowDown" === e3, !n3.includes(i3)).focus();
    }
    static dropdownInterface(t3, e3) {
      const i3 = Ae.getOrCreateInstance(t3, e3);
      if ("string" == typeof e3) {
        if (void 0 === i3[e3])
          throw new TypeError(`No method named "${e3}"`);
        i3[e3]();
      }
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        Ae.dropdownInterface(this, t3);
      });
    }
    static clearMenus(e3) {
      if (e3 && (2 === e3.button || "keyup" === e3.type && "Tab" !== e3.key))
        return;
      const i3 = t2.find('[data-bs-toggle="dropdown"]');
      for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
        const n4 = Ae.getInstance(i3[t3]);
        if (!n4 || false === n4._config.autoClose)
          continue;
        if (!n4._element.classList.contains("show"))
          continue;
        const s3 = { relatedTarget: n4._element };
        if (e3) {
          const t4 = e3.composedPath(), i4 = t4.includes(n4._menu);
          if (t4.includes(n4._element) || "inside" === n4._config.autoClose && !i4 || "outside" === n4._config.autoClose && i4)
            continue;
          if (n4._menu.contains(e3.target) && ("keyup" === e3.type && "Tab" === e3.key || /input|select|option|textarea|form/i.test(e3.target.tagName)))
            continue;
          "click" === e3.type && (s3.clickEvent = e3);
        }
        n4._completeHide(s3);
      }
    }
    static getParentFromElement(t3) {
      return s2(t3) || t3.parentNode;
    }
    static dataApiKeydownHandler(e3) {
      if (/input|textarea/i.test(e3.target.tagName) ? "Space" === e3.key || "Escape" !== e3.key && ("ArrowDown" !== e3.key && "ArrowUp" !== e3.key || e3.target.closest(".dropdown-menu")) : !pe.test(e3.key))
        return;
      const i3 = this.classList.contains("show");
      if (!i3 && "Escape" === e3.key)
        return;
      if (e3.preventDefault(), e3.stopPropagation(), h2(this))
        return;
      const n3 = () => this.matches('[data-bs-toggle="dropdown"]') ? this : t2.prev(this, '[data-bs-toggle="dropdown"]')[0];
      return "Escape" === e3.key ? (n3().focus(), void Ae.clearMenus()) : "ArrowUp" === e3.key || "ArrowDown" === e3.key ? (i3 || n3().click(), void Ae.getInstance(n3())._selectMenuItem(e3)) : void (i3 && "Space" !== e3.key || Ae.clearMenus());
    }
  }
  P.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', Ae.dataApiKeydownHandler), P.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", Ae.dataApiKeydownHandler), P.on(document, "click.bs.dropdown.data-api", Ae.clearMenus), P.on(document, "keyup.bs.dropdown.data-api", Ae.clearMenus), P.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', function(t3) {
    t3.preventDefault(), Ae.dropdownInterface(this);
  }), _2(Ae);
  class Te {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const t3 = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t3);
    }
    hide() {
      const t3 = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", (e3) => e3 + t3), this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", (e3) => e3 + t3), this._setElementAttributes(".sticky-top", "marginRight", (e3) => e3 - t3);
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
    }
    _setElementAttributes(t3, e3, i3) {
      const n3 = this.getWidth();
      this._applyManipulationCallback(t3, (t4) => {
        if (t4 !== this._element && window.innerWidth > t4.clientWidth + n3)
          return;
        this._saveInitialAttribute(t4, e3);
        const s3 = window.getComputedStyle(t4)[e3];
        t4.style[e3] = i3(Number.parseFloat(s3)) + "px";
      });
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), this._resetElementAttributes(".sticky-top", "marginRight");
    }
    _saveInitialAttribute(t3, e3) {
      const i3 = t3.style[e3];
      i3 && U.setDataAttribute(t3, e3, i3);
    }
    _resetElementAttributes(t3, e3) {
      this._applyManipulationCallback(t3, (t4) => {
        const i3 = U.getDataAttribute(t4, e3);
        void 0 === i3 ? t4.style.removeProperty(e3) : (U.removeDataAttribute(t4, e3), t4.style[e3] = i3);
      });
    }
    _applyManipulationCallback(e3, i3) {
      r2(e3) ? i3(e3) : t2.find(e3, this._element).forEach(i3);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
  }
  const Oe = { isVisible: true, isAnimated: false, rootElement: "body", clickCallback: null }, Ce = { isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" };
  class ke {
    constructor(t3) {
      this._config = this._getConfig(t3), this._isAppended = false, this._element = null;
    }
    show(t3) {
      this._config.isVisible ? (this._append(), this._config.isAnimated && f2(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => {
        b(t3);
      })) : b(t3);
    }
    hide(t3) {
      this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
        this.dispose(), b(t3);
      })) : b(t3);
    }
    _getElement() {
      if (!this._element) {
        const t3 = document.createElement("div");
        t3.className = "modal-backdrop", this._config.isAnimated && t3.classList.add("fade"), this._element = t3;
      }
      return this._element;
    }
    _getConfig(t3) {
      return (t3 = { ...Oe, ..."object" == typeof t3 ? t3 : {} }).rootElement = a2(t3.rootElement), l("backdrop", t3, Ce), t3;
    }
    _append() {
      this._isAppended || (this._config.rootElement.appendChild(this._getElement()), P.on(this._getElement(), "mousedown.bs.backdrop", () => {
        b(this._config.clickCallback);
      }), this._isAppended = true);
    }
    dispose() {
      this._isAppended && (P.off(this._element, "mousedown.bs.backdrop"), this._element.remove(), this._isAppended = false);
    }
    _emulateAnimation(t3) {
      v2(t3, this._getElement(), this._config.isAnimated);
    }
  }
  const Le = { backdrop: true, keyboard: true, focus: true }, xe = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" };
  class De extends B {
    constructor(e3, i3) {
      super(e3), this._config = this._getConfig(i3), this._dialog = t2.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._isShown = false, this._ignoreBackdropClick = false, this._isTransitioning = false, this._scrollBar = new Te();
    }
    static get Default() {
      return Le;
    }
    static get NAME() {
      return "modal";
    }
    toggle(t3) {
      return this._isShown ? this.hide() : this.show(t3);
    }
    show(t3) {
      this._isShown || this._isTransitioning || P.trigger(this._element, "show.bs.modal", { relatedTarget: t3 }).defaultPrevented || (this._isShown = true, this._isAnimated() && (this._isTransitioning = true), this._scrollBar.hide(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), P.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (t4) => this.hide(t4)), P.on(this._dialog, "mousedown.dismiss.bs.modal", () => {
        P.one(this._element, "mouseup.dismiss.bs.modal", (t4) => {
          t4.target === this._element && (this._ignoreBackdropClick = true);
        });
      }), this._showBackdrop(() => this._showElement(t3)));
    }
    hide(t3) {
      if (t3 && ["A", "AREA"].includes(t3.target.tagName) && t3.preventDefault(), !this._isShown || this._isTransitioning)
        return;
      if (P.trigger(this._element, "hide.bs.modal").defaultPrevented)
        return;
      this._isShown = false;
      const e3 = this._isAnimated();
      e3 && (this._isTransitioning = true), this._setEscapeEvent(), this._setResizeEvent(), P.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), P.off(this._element, "click.dismiss.bs.modal"), P.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, e3);
    }
    dispose() {
      [window, this._dialog].forEach((t3) => P.off(t3, ".bs.modal")), this._backdrop.dispose(), super.dispose(), P.off(document, "focusin.bs.modal");
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new ke({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
    }
    _getConfig(t3) {
      return t3 = { ...Le, ...U.getDataAttributes(this._element), ..."object" == typeof t3 ? t3 : {} }, l("modal", t3, xe), t3;
    }
    _showElement(e3) {
      const i3 = this._isAnimated(), n3 = t2.findOne(".modal-body", this._dialog);
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n3 && (n3.scrollTop = 0), i3 && f2(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus(), this._queueCallback(() => {
        this._config.focus && this._element.focus(), this._isTransitioning = false, P.trigger(this._element, "shown.bs.modal", { relatedTarget: e3 });
      }, this._dialog, i3);
    }
    _enforceFocus() {
      P.off(document, "focusin.bs.modal"), P.on(document, "focusin.bs.modal", (t3) => {
        document === t3.target || this._element === t3.target || this._element.contains(t3.target) || this._element.focus();
      });
    }
    _setEscapeEvent() {
      this._isShown ? P.on(this._element, "keydown.dismiss.bs.modal", (t3) => {
        this._config.keyboard && "Escape" === t3.key ? (t3.preventDefault(), this.hide()) : this._config.keyboard || "Escape" !== t3.key || this._triggerBackdropTransition();
      }) : P.off(this._element, "keydown.dismiss.bs.modal");
    }
    _setResizeEvent() {
      this._isShown ? P.on(window, "resize.bs.modal", () => this._adjustDialog()) : P.off(window, "resize.bs.modal");
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
        document.body.classList.remove("modal-open"), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, "hidden.bs.modal");
      });
    }
    _showBackdrop(t3) {
      P.on(this._element, "click.dismiss.bs.modal", (t4) => {
        this._ignoreBackdropClick ? this._ignoreBackdropClick = false : t4.target === t4.currentTarget && (true === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition());
      }), this._backdrop.show(t3);
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (P.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented)
        return;
      const { classList: t3, scrollHeight: e3, style: i3 } = this._element, n3 = e3 > document.documentElement.clientHeight;
      !n3 && "hidden" === i3.overflowY || t3.contains("modal-static") || (n3 || (i3.overflowY = "hidden"), t3.add("modal-static"), this._queueCallback(() => {
        t3.remove("modal-static"), n3 || this._queueCallback(() => {
          i3.overflowY = "";
        }, this._dialog);
      }, this._dialog), this._element.focus());
    }
    _adjustDialog() {
      const t3 = this._element.scrollHeight > document.documentElement.clientHeight, e3 = this._scrollBar.getWidth(), i3 = e3 > 0;
      (!i3 && t3 && !g() || i3 && !t3 && g()) && (this._element.style.paddingLeft = e3 + "px"), (i3 && !t3 && !g() || !i3 && t3 && g()) && (this._element.style.paddingRight = e3 + "px");
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }
    static jQueryInterface(t3, e3) {
      return this.each(function() {
        const i3 = De.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === i3[t3])
            throw new TypeError(`No method named "${t3}"`);
          i3[t3](e3);
        }
      });
    }
  }
  P.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function(t3) {
    const e3 = s2(this);
    ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), P.one(e3, "show.bs.modal", (t4) => {
      t4.defaultPrevented || P.one(e3, "hidden.bs.modal", () => {
        c2(this) && this.focus();
      });
    }), De.getOrCreateInstance(e3).toggle(this);
  }), _2(De);
  const Se = { backdrop: true, keyboard: true, scroll: false }, Ie = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" };
  class Ne extends B {
    constructor(t3, e3) {
      super(t3), this._config = this._getConfig(e3), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._addEventListeners();
    }
    static get NAME() {
      return "offcanvas";
    }
    static get Default() {
      return Se;
    }
    toggle(t3) {
      return this._isShown ? this.hide() : this.show(t3);
    }
    show(t3) {
      this._isShown || P.trigger(this._element, "show.bs.offcanvas", { relatedTarget: t3 }).defaultPrevented || (this._isShown = true, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (new Te().hide(), this._enforceFocusOnElement(this._element)), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add("show"), this._queueCallback(() => {
        P.trigger(this._element, "shown.bs.offcanvas", { relatedTarget: t3 });
      }, this._element, true));
    }
    hide() {
      this._isShown && (P.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (P.off(document, "focusin.bs.offcanvas"), this._element.blur(), this._isShown = false, this._element.classList.remove("show"), this._backdrop.hide(), this._queueCallback(() => {
        this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new Te().reset(), P.trigger(this._element, "hidden.bs.offcanvas");
      }, this._element, true)));
    }
    dispose() {
      this._backdrop.dispose(), super.dispose(), P.off(document, "focusin.bs.offcanvas");
    }
    _getConfig(t3) {
      return t3 = { ...Se, ...U.getDataAttributes(this._element), ..."object" == typeof t3 ? t3 : {} }, l("offcanvas", t3, Ie), t3;
    }
    _initializeBackDrop() {
      return new ke({ isVisible: this._config.backdrop, isAnimated: true, rootElement: this._element.parentNode, clickCallback: () => this.hide() });
    }
    _enforceFocusOnElement(t3) {
      P.off(document, "focusin.bs.offcanvas"), P.on(document, "focusin.bs.offcanvas", (e3) => {
        document === e3.target || t3 === e3.target || t3.contains(e3.target) || t3.focus();
      }), t3.focus();
    }
    _addEventListeners() {
      P.on(this._element, "click.dismiss.bs.offcanvas", '[data-bs-dismiss="offcanvas"]', () => this.hide()), P.on(this._element, "keydown.dismiss.bs.offcanvas", (t3) => {
        this._config.keyboard && "Escape" === t3.key && this.hide();
      });
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = Ne.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
            throw new TypeError(`No method named "${t3}"`);
          e3[t3](this);
        }
      });
    }
  }
  P.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function(e3) {
    const i3 = s2(this);
    if (["A", "AREA"].includes(this.tagName) && e3.preventDefault(), h2(this))
      return;
    P.one(i3, "hidden.bs.offcanvas", () => {
      c2(this) && this.focus();
    });
    const n3 = t2.findOne(".offcanvas.show");
    n3 && n3 !== i3 && Ne.getInstance(n3).hide(), Ne.getOrCreateInstance(i3).toggle(this);
  }), P.on(window, "load.bs.offcanvas.data-api", () => t2.find(".offcanvas.show").forEach((t3) => Ne.getOrCreateInstance(t3).show())), _2(Ne);
  const je = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Me = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i, Pe = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, He = (t3, e3) => {
    const i3 = t3.nodeName.toLowerCase();
    if (e3.includes(i3))
      return !je.has(i3) || Boolean(Me.test(t3.nodeValue) || Pe.test(t3.nodeValue));
    const n3 = e3.filter((t4) => t4 instanceof RegExp);
    for (let t4 = 0, e4 = n3.length; t4 < e4; t4++)
      if (n3[t4].test(i3))
        return true;
    return false;
  };
  function Re(t3, e3, i3) {
    if (!t3.length)
      return t3;
    if (i3 && "function" == typeof i3)
      return i3(t3);
    const n3 = new window.DOMParser().parseFromString(t3, "text/html"), s3 = Object.keys(e3), o3 = [].concat(...n3.body.querySelectorAll("*"));
    for (let t4 = 0, i4 = o3.length; t4 < i4; t4++) {
      const i5 = o3[t4], n4 = i5.nodeName.toLowerCase();
      if (!s3.includes(n4)) {
        i5.remove();
        continue;
      }
      const r3 = [].concat(...i5.attributes), a3 = [].concat(e3["*"] || [], e3[n4] || []);
      r3.forEach((t5) => {
        He(t5, a3) || i5.removeAttribute(t5.nodeName);
      });
    }
    return n3.body.innerHTML;
  }
  const Be = new RegExp("(^|\\s)bs-tooltip\\S+", "g"), We = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), qe = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }, ze = { AUTO: "auto", TOP: "top", RIGHT: g() ? "left" : "right", BOTTOM: "bottom", LEFT: g() ? "right" : "left" }, $e = { animation: true, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: false, selector: false, placement: "top", offset: [0, 0], container: false, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: true, sanitizeFn: null, allowList: { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, popperConfig: null }, Ue = { HIDE: "hide.bs.tooltip", HIDDEN: "hidden.bs.tooltip", SHOW: "show.bs.tooltip", SHOWN: "shown.bs.tooltip", INSERTED: "inserted.bs.tooltip", CLICK: "click.bs.tooltip", FOCUSIN: "focusin.bs.tooltip", FOCUSOUT: "focusout.bs.tooltip", MOUSEENTER: "mouseenter.bs.tooltip", MOUSELEAVE: "mouseleave.bs.tooltip" };
  class Fe extends B {
    constructor(t3, e3) {
      if (void 0 === fe)
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t3), this._isEnabled = true, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e3), this.tip = null, this._setListeners();
    }
    static get Default() {
      return $e;
    }
    static get NAME() {
      return "tooltip";
    }
    static get Event() {
      return Ue;
    }
    static get DefaultType() {
      return qe;
    }
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle(t3) {
      if (this._isEnabled)
        if (t3) {
          const e3 = this._initializeOnDelegatedTarget(t3);
          e3._activeTrigger.click = !e3._activeTrigger.click, e3._isWithActiveTrigger() ? e3._enter(null, e3) : e3._leave(null, e3);
        } else {
          if (this.getTipElement().classList.contains("show"))
            return void this._leave(null, this);
          this._enter(null, this);
        }
    }
    dispose() {
      clearTimeout(this._timeout), P.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose();
    }
    show() {
      if ("none" === this._element.style.display)
        throw new Error("Please use show on visible elements");
      if (!this.isWithContent() || !this._isEnabled)
        return;
      const t3 = P.trigger(this._element, this.constructor.Event.SHOW), i3 = d(this._element), n3 = null === i3 ? this._element.ownerDocument.documentElement.contains(this._element) : i3.contains(this._element);
      if (t3.defaultPrevented || !n3)
        return;
      const s3 = this.getTipElement(), o3 = e2(this.constructor.NAME);
      s3.setAttribute("id", o3), this._element.setAttribute("aria-describedby", o3), this.setContent(), this._config.animation && s3.classList.add("fade");
      const r3 = "function" == typeof this._config.placement ? this._config.placement.call(this, s3, this._element) : this._config.placement, a3 = this._getAttachment(r3);
      this._addAttachmentClass(a3);
      const { container: l2 } = this._config;
      R.set(s3, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l2.appendChild(s3), P.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = ue(this._element, s3, this._getPopperConfig(a3)), s3.classList.add("show");
      const c3 = "function" == typeof this._config.customClass ? this._config.customClass() : this._config.customClass;
      c3 && s3.classList.add(...c3.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t4) => {
        P.on(t4, "mouseover", u2);
      });
      const h3 = this.tip.classList.contains("fade");
      this._queueCallback(() => {
        const t4 = this._hoverState;
        this._hoverState = null, P.trigger(this._element, this.constructor.Event.SHOWN), "out" === t4 && this._leave(null, this);
      }, this.tip, h3);
    }
    hide() {
      if (!this._popper)
        return;
      const t3 = this.getTipElement();
      if (P.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented)
        return;
      t3.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach((t4) => P.off(t4, "mouseover", u2)), this._activeTrigger.click = false, this._activeTrigger.focus = false, this._activeTrigger.hover = false;
      const e3 = this.tip.classList.contains("fade");
      this._queueCallback(() => {
        this._isWithActiveTrigger() || ("show" !== this._hoverState && t3.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), P.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null));
      }, this.tip, e3), this._hoverState = "";
    }
    update() {
      null !== this._popper && this._popper.update();
    }
    isWithContent() {
      return Boolean(this.getTitle());
    }
    getTipElement() {
      if (this.tip)
        return this.tip;
      const t3 = document.createElement("div");
      return t3.innerHTML = this._config.template, this.tip = t3.children[0], this.tip;
    }
    setContent() {
      const e3 = this.getTipElement();
      this.setElementContent(t2.findOne(".tooltip-inner", e3), this.getTitle()), e3.classList.remove("fade", "show");
    }
    setElementContent(t3, e3) {
      if (null !== t3)
        return r2(e3) ? (e3 = a2(e3), void (this._config.html ? e3.parentNode !== t3 && (t3.innerHTML = "", t3.appendChild(e3)) : t3.textContent = e3.textContent)) : void (this._config.html ? (this._config.sanitize && (e3 = Re(e3, this._config.allowList, this._config.sanitizeFn)), t3.innerHTML = e3) : t3.textContent = e3);
    }
    getTitle() {
      let t3 = this._element.getAttribute("data-bs-original-title");
      return t3 || (t3 = "function" == typeof this._config.title ? this._config.title.call(this._element) : this._config.title), t3;
    }
    updateAttachment(t3) {
      return "right" === t3 ? "end" : "left" === t3 ? "start" : t3;
    }
    _initializeOnDelegatedTarget(t3, e3) {
      const i3 = this.constructor.DATA_KEY;
      return (e3 = e3 || R.get(t3.delegateTarget, i3)) || (e3 = new this.constructor(t3.delegateTarget, this._getDelegateConfig()), R.set(t3.delegateTarget, i3, e3)), e3;
    }
    _getOffset() {
      const { offset: t3 } = this._config;
      return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e3) => t3(e3, this._element) : t3;
    }
    _getPopperConfig(t3) {
      const e3 = { placement: t3, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "onChange", enabled: true, phase: "afterWrite", fn: (t4) => this._handlePopperPlacementChange(t4) }], onFirstUpdate: (t4) => {
        t4.options.placement !== t4.placement && this._handlePopperPlacementChange(t4);
      } };
      return { ...e3, ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(e3) : this._config.popperConfig };
    }
    _addAttachmentClass(t3) {
      this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(t3));
    }
    _getAttachment(t3) {
      return ze[t3.toUpperCase()];
    }
    _setListeners() {
      this._config.trigger.split(" ").forEach((t3) => {
        if ("click" === t3)
          P.on(this._element, this.constructor.Event.CLICK, this._config.selector, (t4) => this.toggle(t4));
        else if ("manual" !== t3) {
          const e3 = "hover" === t3 ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, i3 = "hover" === t3 ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          P.on(this._element, e3, this._config.selector, (t4) => this._enter(t4)), P.on(this._element, i3, this._config.selector, (t4) => this._leave(t4));
        }
      }), this._hideModalHandler = () => {
        this._element && this.hide();
      }, P.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle();
    }
    _fixTitle() {
      const t3 = this._element.getAttribute("title"), e3 = typeof this._element.getAttribute("data-bs-original-title");
      (t3 || "string" !== e3) && (this._element.setAttribute("data-bs-original-title", t3 || ""), !t3 || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t3), this._element.setAttribute("title", ""));
    }
    _enter(t3, e3) {
      e3 = this._initializeOnDelegatedTarget(t3, e3), t3 && (e3._activeTrigger["focusin" === t3.type ? "focus" : "hover"] = true), e3.getTipElement().classList.contains("show") || "show" === e3._hoverState ? e3._hoverState = "show" : (clearTimeout(e3._timeout), e3._hoverState = "show", e3._config.delay && e3._config.delay.show ? e3._timeout = setTimeout(() => {
        "show" === e3._hoverState && e3.show();
      }, e3._config.delay.show) : e3.show());
    }
    _leave(t3, e3) {
      e3 = this._initializeOnDelegatedTarget(t3, e3), t3 && (e3._activeTrigger["focusout" === t3.type ? "focus" : "hover"] = e3._element.contains(t3.relatedTarget)), e3._isWithActiveTrigger() || (clearTimeout(e3._timeout), e3._hoverState = "out", e3._config.delay && e3._config.delay.hide ? e3._timeout = setTimeout(() => {
        "out" === e3._hoverState && e3.hide();
      }, e3._config.delay.hide) : e3.hide());
    }
    _isWithActiveTrigger() {
      for (const t3 in this._activeTrigger)
        if (this._activeTrigger[t3])
          return true;
      return false;
    }
    _getConfig(t3) {
      const e3 = U.getDataAttributes(this._element);
      return Object.keys(e3).forEach((t4) => {
        We.has(t4) && delete e3[t4];
      }), (t3 = { ...this.constructor.Default, ...e3, ..."object" == typeof t3 && t3 ? t3 : {} }).container = false === t3.container ? document.body : a2(t3.container), "number" == typeof t3.delay && (t3.delay = { show: t3.delay, hide: t3.delay }), "number" == typeof t3.title && (t3.title = t3.title.toString()), "number" == typeof t3.content && (t3.content = t3.content.toString()), l("tooltip", t3, this.constructor.DefaultType), t3.sanitize && (t3.template = Re(t3.template, t3.allowList, t3.sanitizeFn)), t3;
    }
    _getDelegateConfig() {
      const t3 = {};
      if (this._config)
        for (const e3 in this._config)
          this.constructor.Default[e3] !== this._config[e3] && (t3[e3] = this._config[e3]);
      return t3;
    }
    _cleanTipClass() {
      const t3 = this.getTipElement(), e3 = t3.getAttribute("class").match(Be);
      null !== e3 && e3.length > 0 && e3.map((t4) => t4.trim()).forEach((e4) => t3.classList.remove(e4));
    }
    _handlePopperPlacementChange(t3) {
      const { state: e3 } = t3;
      e3 && (this.tip = e3.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e3.placement)));
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = Fe.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3])
            throw new TypeError(`No method named "${t3}"`);
          e3[t3]();
        }
      });
    }
  }
  _2(Fe);
  const Ve = new RegExp("(^|\\s)bs-popover\\S+", "g"), Ke = { ...Fe.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, Xe = { ...Fe.DefaultType, content: "(string|element|function)" }, Ye = { HIDE: "hide.bs.popover", HIDDEN: "hidden.bs.popover", SHOW: "show.bs.popover", SHOWN: "shown.bs.popover", INSERTED: "inserted.bs.popover", CLICK: "click.bs.popover", FOCUSIN: "focusin.bs.popover", FOCUSOUT: "focusout.bs.popover", MOUSEENTER: "mouseenter.bs.popover", MOUSELEAVE: "mouseleave.bs.popover" };
  class Qe extends Fe {
    static get Default() {
      return Ke;
    }
    static get NAME() {
      return "popover";
    }
    static get Event() {
      return Ye;
    }
    static get DefaultType() {
      return Xe;
    }
    isWithContent() {
      return this.getTitle() || this._getContent();
    }
    getTipElement() {
      return this.tip || (this.tip = super.getTipElement(), this.getTitle() || t2.findOne(".popover-header", this.tip).remove(), this._getContent() || t2.findOne(".popover-body", this.tip).remove()), this.tip;
    }
    setContent() {
      const e3 = this.getTipElement();
      this.setElementContent(t2.findOne(".popover-header", e3), this.getTitle());
      let i3 = this._getContent();
      "function" == typeof i3 && (i3 = i3.call(this._element)), this.setElementContent(t2.findOne(".popover-body", e3), i3), e3.classList.remove("fade", "show");
    }
    _addAttachmentClass(t3) {
      this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(t3));
    }
    _getContent() {
      return this._element.getAttribute("data-bs-content") || this._config.content;
    }
    _cleanTipClass() {
      const t3 = this.getTipElement(), e3 = t3.getAttribute("class").match(Ve);
      null !== e3 && e3.length > 0 && e3.map((t4) => t4.trim()).forEach((e4) => t3.classList.remove(e4));
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = Qe.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3])
            throw new TypeError(`No method named "${t3}"`);
          e3[t3]();
        }
      });
    }
  }
  _2(Qe);
  const Ge = { offset: 10, method: "auto", target: "" }, Ze = { offset: "number", method: "string", target: "(string|element)" };
  class Je extends B {
    constructor(t3, e3) {
      super(t3), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e3), this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, P.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process();
    }
    static get Default() {
      return Ge;
    }
    static get NAME() {
      return "scrollspy";
    }
    refresh() {
      const e3 = this._scrollElement === this._scrollElement.window ? "offset" : "position", i3 = "auto" === this._config.method ? e3 : this._config.method, s3 = "position" === i3 ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), t2.find(this._selector).map((e4) => {
        const o3 = n2(e4), r3 = o3 ? t2.findOne(o3) : null;
        if (r3) {
          const t3 = r3.getBoundingClientRect();
          if (t3.width || t3.height)
            return [U[i3](r3).top + s3, o3];
        }
        return null;
      }).filter((t3) => t3).sort((t3, e4) => t3[0] - e4[0]).forEach((t3) => {
        this._offsets.push(t3[0]), this._targets.push(t3[1]);
      });
    }
    dispose() {
      P.off(this._scrollElement, ".bs.scrollspy"), super.dispose();
    }
    _getConfig(t3) {
      if ("string" != typeof (t3 = { ...Ge, ...U.getDataAttributes(this._element), ..."object" == typeof t3 && t3 ? t3 : {} }).target && r2(t3.target)) {
        let { id: i3 } = t3.target;
        i3 || (i3 = e2("scrollspy"), t3.target.id = i3), t3.target = "#" + i3;
      }
      return l("scrollspy", t3, Ze), t3;
    }
    _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }
    _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
    _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }
    _process() {
      const t3 = this._getScrollTop() + this._config.offset, e3 = this._getScrollHeight(), i3 = this._config.offset + e3 - this._getOffsetHeight();
      if (this._scrollHeight !== e3 && this.refresh(), t3 >= i3) {
        const t4 = this._targets[this._targets.length - 1];
        this._activeTarget !== t4 && this._activate(t4);
      } else {
        if (this._activeTarget && t3 < this._offsets[0] && this._offsets[0] > 0)
          return this._activeTarget = null, void this._clear();
        for (let e4 = this._offsets.length; e4--; )
          this._activeTarget !== this._targets[e4] && t3 >= this._offsets[e4] && (void 0 === this._offsets[e4 + 1] || t3 < this._offsets[e4 + 1]) && this._activate(this._targets[e4]);
      }
    }
    _activate(e3) {
      this._activeTarget = e3, this._clear();
      const i3 = this._selector.split(",").map((t3) => `${t3}[data-bs-target="${e3}"],${t3}[href="${e3}"]`), n3 = t2.findOne(i3.join(","));
      n3.classList.contains("dropdown-item") ? (t2.findOne(".dropdown-toggle", n3.closest(".dropdown")).classList.add("active"), n3.classList.add("active")) : (n3.classList.add("active"), t2.parents(n3, ".nav, .list-group").forEach((e4) => {
        t2.prev(e4, ".nav-link, .list-group-item").forEach((t3) => t3.classList.add("active")), t2.prev(e4, ".nav-item").forEach((e5) => {
          t2.children(e5, ".nav-link").forEach((t3) => t3.classList.add("active"));
        });
      })), P.trigger(this._scrollElement, "activate.bs.scrollspy", { relatedTarget: e3 });
    }
    _clear() {
      t2.find(this._selector).filter((t3) => t3.classList.contains("active")).forEach((t3) => t3.classList.remove("active"));
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = Je.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3])
            throw new TypeError(`No method named "${t3}"`);
          e3[t3]();
        }
      });
    }
  }
  P.on(window, "load.bs.scrollspy.data-api", () => {
    t2.find('[data-bs-spy="scroll"]').forEach((t3) => new Je(t3));
  }), _2(Je);
  class ti extends B {
    static get NAME() {
      return "tab";
    }
    show() {
      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active"))
        return;
      let e3;
      const i3 = s2(this._element), n3 = this._element.closest(".nav, .list-group");
      if (n3) {
        const i4 = "UL" === n3.nodeName || "OL" === n3.nodeName ? ":scope > li > .active" : ".active";
        e3 = t2.find(i4, n3), e3 = e3[e3.length - 1];
      }
      const o3 = e3 ? P.trigger(e3, "hide.bs.tab", { relatedTarget: this._element }) : null;
      if (P.trigger(this._element, "show.bs.tab", { relatedTarget: e3 }).defaultPrevented || null !== o3 && o3.defaultPrevented)
        return;
      this._activate(this._element, n3);
      const r3 = () => {
        P.trigger(e3, "hidden.bs.tab", { relatedTarget: this._element }), P.trigger(this._element, "shown.bs.tab", { relatedTarget: e3 });
      };
      i3 ? this._activate(i3, i3.parentNode, r3) : r3();
    }
    _activate(e3, i3, n3) {
      const s3 = (!i3 || "UL" !== i3.nodeName && "OL" !== i3.nodeName ? t2.children(i3, ".active") : t2.find(":scope > li > .active", i3))[0], o3 = n3 && s3 && s3.classList.contains("fade"), r3 = () => this._transitionComplete(e3, s3, n3);
      s3 && o3 ? (s3.classList.remove("show"), this._queueCallback(r3, e3, true)) : r3();
    }
    _transitionComplete(e3, i3, n3) {
      if (i3) {
        i3.classList.remove("active");
        const e4 = t2.findOne(":scope > .dropdown-menu .active", i3.parentNode);
        e4 && e4.classList.remove("active"), "tab" === i3.getAttribute("role") && i3.setAttribute("aria-selected", false);
      }
      e3.classList.add("active"), "tab" === e3.getAttribute("role") && e3.setAttribute("aria-selected", true), f2(e3), e3.classList.contains("fade") && e3.classList.add("show");
      let s3 = e3.parentNode;
      if (s3 && "LI" === s3.nodeName && (s3 = s3.parentNode), s3 && s3.classList.contains("dropdown-menu")) {
        const i4 = e3.closest(".dropdown");
        i4 && t2.find(".dropdown-toggle", i4).forEach((t3) => t3.classList.add("active")), e3.setAttribute("aria-expanded", true);
      }
      n3 && n3();
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = ti.getOrCreateInstance(this);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3])
            throw new TypeError(`No method named "${t3}"`);
          e3[t3]();
        }
      });
    }
  }
  P.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', function(t3) {
    ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), h2(this) || ti.getOrCreateInstance(this).show();
  }), _2(ti);
  const ei = { animation: "boolean", autohide: "boolean", delay: "number" }, ii = { animation: true, autohide: true, delay: 5e3 };
  class ni extends B {
    constructor(t3, e3) {
      super(t3), this._config = this._getConfig(e3), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
    }
    static get DefaultType() {
      return ei;
    }
    static get Default() {
      return ii;
    }
    static get NAME() {
      return "toast";
    }
    show() {
      P.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), f2(this._element), this._element.classList.add("showing"), this._queueCallback(() => {
        this._element.classList.remove("showing"), this._element.classList.add("show"), P.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide();
      }, this._element, this._config.animation));
    }
    hide() {
      this._element.classList.contains("show") && (P.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.remove("show"), this._queueCallback(() => {
        this._element.classList.add("hide"), P.trigger(this._element, "hidden.bs.toast");
      }, this._element, this._config.animation)));
    }
    dispose() {
      this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose();
    }
    _getConfig(t3) {
      return t3 = { ...ii, ...U.getDataAttributes(this._element), ..."object" == typeof t3 && t3 ? t3 : {} }, l("toast", t3, this.constructor.DefaultType), t3;
    }
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay)));
    }
    _onInteraction(t3, e3) {
      switch (t3.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e3;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e3;
      }
      if (e3)
        return void this._clearTimeout();
      const i3 = t3.relatedTarget;
      this._element === i3 || this._element.contains(i3) || this._maybeScheduleHide();
    }
    _setListeners() {
      P.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', () => this.hide()), P.on(this._element, "mouseover.bs.toast", (t3) => this._onInteraction(t3, true)), P.on(this._element, "mouseout.bs.toast", (t3) => this._onInteraction(t3, false)), P.on(this._element, "focusin.bs.toast", (t3) => this._onInteraction(t3, true)), P.on(this._element, "focusout.bs.toast", (t3) => this._onInteraction(t3, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null;
    }
    static jQueryInterface(t3) {
      return this.each(function() {
        const e3 = ni.getOrCreateInstance(this, t3);
        if ("string" == typeof t3) {
          if (void 0 === e3[t3])
            throw new TypeError(`No method named "${t3}"`);
          e3[t3](this);
        }
      });
    }
  }
  return _2(ni), { Alert: W, Button: q, Carousel: Z, Collapse: et, Dropdown: Ae, Modal: De, Offcanvas: Ne, Popover: Qe, ScrollSpy: Je, Tab: ti, Toast: ni, Tooltip: Fe };
});
const style = "";
const _sfc_main = {
  __name: "App",
  setup(__props) {
    useRouter();
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(_component_router_view);
    };
  }
};
const app = createApp(_sfc_main);
app.use(router).mount("#app");
export {
  BIconHouseFill as B,
  Fragment as F,
  createBaseVNode as a,
  unref as b,
  createElementBlock as c,
  createVNode as d,
  popScopeId as e,
  createTextVNode as f,
  normalizeStyle as n,
  openBlock as o,
  pushScopeId as p,
  useRouter as u
};
